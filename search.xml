<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CAP &amp; BASE理论</title>
    <url>/post/4d60196d/</url>
    <content><![CDATA[<h2 id="从集中式到分布式"><a href="#从集中式到分布式" class="headerlink" title="从集中式到分布式"></a>从集中式到分布式</h2><p>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</p>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>集中式是指有<strong>一台或者多台</strong>计算机组成的<strong>中心节点</strong>，<strong>数据集中存储</strong>于这个中心节点中，并且<strong>整个系统的所有业务单元</strong>都<strong>集中部署</strong>在这个中心节点上，<strong>系统的所有功能均由集中处理</strong>。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式系统是一个硬件或者软件分布在<strong>不同的网络计算机</strong>上，彼此之间仅仅<strong>通过消费传递进行通信和协调</strong>的系统。</p>
<p><strong>分布式系统特征：</strong></p>
<ol>
<li>分布性</li>
<li>对等性</li>
<li>并发性</li>
<li>缺乏全球时钟（由于分布式系统由一些列的空间上任意分布的多个进程组成，具有分布性，很难定义两个事件究竟是谁先谁后）</li>
<li>故障总是会发生<span id="more"></span></li>
</ol>
<p><strong>分布式系统典型难题：</strong></p>
<ol>
<li>通信问题</li>
<li>网络分区（当网络发生异常时候，只有部分节点进行正常通信，另一些节点不可用，网络分区严重情况下面会导致“脑裂”）</li>
<li>三态（成功、失败、超时）</li>
<li>节点故障</li>
</ol>
<p><strong>分布式事物：</strong>指事物参与者、支持事物的服务器、资源服务器以及事物管理器分别于分布式系统的不同节点之上。通常一个分布式事物中会涉及对多个数据源或者业务系统的操作。</p>
<p>本地事物可以采用ACID模型保证数据的严格一致性。但在分布式系统中，实现事物的严格一致性会和服务的可用性产生冲突，这是有分布式系统的特征决定的。因此，在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为一个难题，因此出现了诸如CAP和BASE这样的分布式经典理论。</p>
<h4 id="分布式系统的典型应用"><a href="#分布式系统的典型应用" class="headerlink" title="分布式系统的典型应用"></a>分布式系统的典型应用</h4><p>分布式系统是一个非常广泛的概念，它最终要落实到解决实际问题上，不同的问题有不同的方法和架构。所有的开源软件都是以某个应用场景出现，而纯粹以“分布式”概念进行划分的比较少见。<br>但如果以算法划分，到能分出几类：</p>
<ol>
<li>以Leader选举为主的一类算法，比如paxos、viewstamp，就是现在zookeeper、Chuby等工具的主体</li>
<li>以分布式事务为主的一类主要是二段提交，这些分布式数据库管理器及数据库都支持</li>
<li>以弱一致性为主的，主要代表是Cassandra的W、R、N可调节的一致性</li>
<li>以租赁机制为主的，主要是一些分布式锁的概念，目前还没有看到纯粹“分布式”锁的实现</li>
<li>以失败探测为主的，主要是Gossip和phi失败探测算法，当然也包括简单的心跳</li>
<li>以弱一致性、因果一致性、顺序一致性为主的，开源尚不多，但大都应用在Linkedin、Twitter、Facebook等公司内部</li>
<li>当然以异步解耦为主的，还有各类Queue</li>
</ol>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP 理论/定理</a>起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>
<p>2年后，麻省理工学院的Seth Gilbert和Nancy Lynch 发表了布鲁尔猜想的证明，CAP理论正式成为分布式领域的定理。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220215235554095.png" style="zoom: 60%;" />

<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>
<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>
<ul>
<li><p><strong>一致性（Consistency）</strong>：一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
</li>
<li><p><strong>可用性（Availability）</strong>：可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<p>非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</p>
<blockquote>
<p>返回结果的可用性：</p>
<ol>
<li>指用户的一个操作，系统必须能够在<strong>指定的时间内</strong>返回对应的处理结果，如果超过了这个时间，系统就认为不可用。</li>
<li>返回结果是可用性的另一个重要指标，要求系统在完成对用户请求处理后，返回一个<strong>正常的响应结果</strong>，失败或者成功，而不是一个困惑的结果</li>
</ol>
</blockquote>
</li>
<li><p><strong>分区容错性（Partition tolerance）</strong>：在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
</li>
</ul>
<p><strong>什么是网络分区？</strong></p>
<blockquote>
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，分布式系统中的节点被划分为若干个孤立的区域，每个区域内部可以通信，但是区域之间无法通信，这就叫<strong>网络分区</strong>。</p>
</blockquote>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220215231634891.png" style="zoom:80%;" />

<h3 id="不是所谓的“3-选-2”"><a href="#不是所谓的“3-选-2”" class="headerlink" title="不是所谓的“3 选 2”"></a>不是所谓的“3 选 2”</h3><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>
<blockquote>
<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>
<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>
</blockquote>
<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如  ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>
<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>
<p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>
<h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<p><strong>如果放弃分区可容性（CA without P）</strong>，如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
<p><strong>如果放弃可用性（CP without A）</strong>，意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长（也就是等待数据同步完才能正常访问服务），一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。此时，问题相当于退化到前面“全局事务”中一个系统使用多个数据源的场景之中，可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。</p>
<blockquote>
<p>设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p>在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。</p>
</blockquote>
<p><strong>如果放弃一致性（AP without C）</strong>，意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。</p>
<blockquote>
<p>目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。<br>可横向对比的如注册中心的Zookeeper与Eureka，Zookeeper实现CP，Eureka实现AP</p>
</blockquote>
<p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p>
<blockquote>
<p>典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
</blockquote>
<p>理论相关解释： <a href="https://www.cnblogs.com/hxsyl/p/4381980.html">分布式系统之CAP理论</a></p>
<h3 id="CAP-实际应用案例"><a href="#CAP-实际应用案例" class="headerlink" title="CAP 实际应用案例"></a>CAP 实际应用案例</h3><p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>
<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>
<p>注册中心负责<strong>服务地址的注册与查找</strong>，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心<strong>不转发请求</strong>，压力较小。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220215232230280.png" style="zoom:80%;" />

<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos…。</p>
<ol>
<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是 ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>
<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>
<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>
</ol>
<h4 id="与NoSQL的关系"><a href="#与NoSQL的关系" class="headerlink" title="与NoSQL的关系"></a>与NoSQL的关系</h4><p>传统的关系型数据库在功能支持上通常很宽泛，从简单的键值查询，到复杂的多表联合查询再到事务机制的支持。而与之不同的是，NoSQL系统通常<strong>注重性能和扩展性，而非事务机制</strong>（事务就是强一致性的体现） 。<br>　　传统的SQL数据库的事务通常都是支持ACID的强事务机制。A代表原子性，即在事务中执行多个操作是原子性的，要么事务中的操作全部执行，要么一个都不执行；C代表一致性，即保证进行事务的过程中整个数据加的状态是一致的，不会出现数据不一致的情况；代表隔离性，即两个事务不会相互影响，覆盖彼此数据等；D表示持久化，即事务一量完成，那么数据应该是被写到安全的，持久化存储的设备上（比如磁盘）。<br>　　NoSQL系统<strong>仅提供对行级别的原子性保证</strong>，也就是说同时对同一个Key下的数据进行的两个操作，在实际执行的时候是会串行的执行，保证了每一个Key-Value对不会被破坏。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在分布式环境中，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。<strong>也就是说分区容错性是分布式系统的一个最基本要求。</strong></p>
<p>在CAP理论中，不能同时满足一致性、分区容忍性、可用性，而分区容忍性优势分布式系统的基本要求，因此在架构设计的时候只能在CA或者CP中取舍，也就是只能在一致性或者可用性之间取舍。</p>
<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等。</p>
<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的<strong>前提</strong>是<strong>系统发生了“分区”</strong>。</p>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>
<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
<h3 id="CAP理论中几个重要的细节"><a href="#CAP理论中几个重要的细节" class="headerlink" title="CAP理论中几个重要的细节"></a>CAP理论中几个重要的细节</h3><ul>
<li><p><strong>CAP 关注的粒度是数据，而不是整个系统。</strong>C 与 A 之间的取舍可以在同一系统内以非常细小的粒度反复发生，而每一次的决策可能因为具体的操作，乃至因为牵涉到特定的数据或用户而有所不同。但在实际设计过程中，每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择 CP，有的数据必须选择 AP。而如果我们做设计时，从整个系统的角度去选择 CP 还是 AP，就会发现顾此失彼，无论怎么做都是有问题的。</p>
<blockquote>
<p>以一个最简单的用户管理系统为例，用户管理系统包含用户账号数据（用户 ID、密码）、用户信息数据（昵称、兴趣、爱好、性别、自我介绍等）。通常情况下，用户账号数据会选择 CP，而用户信息数据会选择 AP，如果限定整个系统为 CP，则不符合用户信息数据的应用场景；如果限定整个系统为 AP，则又不符合用户账号数据的应用场景。</p>
</blockquote>
</li>
<li><p><strong>CAP 是忽略网络延迟的。</strong>意味着，CAP 理论中的 C 在实践中是不可能完美实现的，在数据复制的过程中，节点 A 和节点 B 的数据并不一致。</p>
</li>
<li><p><strong>正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA。</strong>CAP 理论告诉我们分布式系统只能选择 CP 或者 AP，但其实这里的前提是系统发生了“分区”现象。如果系统没有发生分区现象，也就是说 P 不存在的时候（节点间的网络连接一切正常），我们没有必要放弃 C 或者 A，应该 C 和 A 都可以保证，这就要求架构设计的时候既要考虑分区发生时选择 CP 还是 AP，也要考虑分区没有发生时如何保证 CA。</p>
<blockquote>
<p>同样以用户管理系统为例，即使是实现 CA，不同的数据实现方式也可能不一样：用户账号数据可以采用“消息队列”的方式来实现 CA，因为消息队列可以比较好地控制实时性，但实现起来就复杂一些；而用户信息数据可以采用“数据库同步”的方式来实现 CA，因为数据库的方式虽然在某些场景下可能延迟较高，但使用起来简单。</p>
</blockquote>
</li>
<li><p><strong>放弃并不等于什么都不做，需要为分区恢复后做准备。</strong></p>
</li>
</ul>
<h3 id="思考：按照CAP理论如何设计一个电商系统？"><a href="#思考：按照CAP理论如何设计一个电商系统？" class="headerlink" title="思考：按照CAP理论如何设计一个电商系统？"></a>思考：按照CAP理论如何设计一个电商系统？</h3><p>首先一个电商网站核心模块有<strong>用户，订单，商品，支付，促销管理</strong>等</p>
<ol>
<li>对于用户模块，包括登录，个人设置，个人订单，购物车，收藏夹等，这些模块保证AP，数据短时间不一致不影响使用。</li>
<li>订单模块的下单付款扣减库存操作是整个系统的核心，CA都需要保证，极端情况下面牺牲A保证C</li>
<li>商品模块的商品上下架和库存管理保证CP</li>
<li>搜索功能因为本身就不是实时性非常高的模块，所以保证AP就可以了。</li>
<li>促销是短时间的数据不一致，结果就是优惠信息看不到，但是已有的优惠要保证可用，而且优惠可以提前预计算，所以可以保证AP。</li>
<li>支付这一块是独立的系统，或者使用第三方的支付宝，微信。其实CAP是由第三方来保证的，支付系统是一个对CAP要求极高的系统，C是必须要保证的，AP中A相对更重要，不能因为分区，导致所有人都不能支付。</li>
</ol>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4">CAP 定理简化</a></li>
<li><a href="https://juejin.im/post/6844903936718012430">神一样的 CAP 理论被应用在何方</a></li>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">请停止呼叫数据库 CP 或 AP </a></li>
</ul>
<h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128">BASE 理论</a>起源于 2008 年， 由eBay的架构师Dan Pritchett在ACM上发表。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h3 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h3><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是<strong>牺牲数据的一致性来满足系统的高可用性</strong>，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>
<p><strong>为什么这样说呢？</strong></p>
<p>CAP 理论这节我们也说过了：</p>
<blockquote>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
</blockquote>
<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h3 id="BASE-理论三要素"><a href="#BASE-理论三要素" class="headerlink" title="BASE 理论三要素"></a>BASE 理论三要素</h3><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219004353775.png" style="zoom:80%;" />

<ol>
<li><p>基本可用</p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><p><strong>响应时间上的损失</strong>：正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障（比如系统部分机房发生断电或断网故障），处理用户请求的时间变为 1-2 s。</p>
</li>
<li><p><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</p>
<blockquote>
<p>例如，正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。软状态</p>
</blockquote>
</li>
</ul>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<blockquote>
<p>分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p>
</blockquote>
</li>
<li><p>最终一致性</p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍。他认为最终一致性时一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够获取到最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于<strong>网络延迟</strong>，<strong>系统负载</strong>和<strong>数据复制方案设计</strong>等因素。</p>
</blockquote>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><p><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</p>
<blockquote>
<p>系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读到最新的值，这样的系统被认为是具有强一致性的。</p>
</blockquote>
</li>
<li><p><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</p>
</li>
<li><p><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</p>
</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<p>那实现最终一致性的具体方式是什么呢？<a href="http://gk.link/a/10rZM">《分布式协议与算法实战》</a> 中是这样介绍：</p>
<blockquote>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</blockquote>
<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种：</p>
<ul>
<li><p><strong>因果一致性</strong>：</p>
<p>​    因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。</p>
</li>
<li><p><strong>读己之所写</strong>：</p>
<p>​    读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。</p>
</li>
<li><p><strong>会话一致性</strong>：</p>
<p>​    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
</li>
<li><p><strong>单调读一致性</strong>：</p>
<p>​    单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</p>
</li>
<li><p><strong>单调写一致性</strong>：</p>
<p>​    单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</p>
</li>
</ul>
<p>以上就是最终一致性的五类常见的变种，在系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。事实上，可以将其中的若干个变种相互结合起来，以构建一个具有最终一致性特性的分布式系统。事实上，最终一致性并不是只有那些大型分布式系统才设计的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多都会采用同步和异步方式来实现主备数据复制技术。在<strong>同步方式</strong>中，<strong>数据的复制通常是更新事务的一部分</strong>，因此在事务完成后，主备数据库的数据就会达到一致。而在<strong>异步方式</strong>中，备库的<strong>更新往往存在延时</strong>，这取决于事务日志在主备数据库之间传输的时间长短，如果传输时间过长或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么很显然，从备库中读取的的数据将是旧的，因此就出现了不一致的情况。当然，无论是采用<strong>多次重试</strong>还是认为数据订正，关系型数据库还是能够保证最终数据达到一致——这就是系统提供最终一致性保证的经典案例。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://javaguide.cn/distributed-system/theorem&algorithm&protocol/cap&base-theorem/">CAP &amp; BASE理论</a></strong></p>
</li>
<li><p><strong><a href="https://www.jianshu.com/p/46b90dfc7c90">分布式基础之CAP和BASE理论</a></strong></p>
</li>
<li><p><strong><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html#%E4%B8%89%E3%80%81cap"> 分布式 - CAP &amp; BASE</a></strong></p>
</li>
<li><p><strong><a href="https://rbmon.gitee.io/learning-note/#/src/main/java/com/toc/DISTRIBUTED-SYSTEM?id=cap%e7%90%86%e8%ae%batop">分布式基本概念 - CAP 理论</a></strong></p>
</li>
<li><p><strong><a href="https://www.cnblogs.com/duanxz/p/5229352.html">CAP原则(CAP定理)、BASE理论</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA .properties 文件中文乱码</title>
    <url>/post/5816ad50/</url>
    <content><![CDATA[<p>问题：从 Gitee中拉下来的项目发现打开配置文件（.properties）中的中文是乱码的。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219104856672.png" style="zoom:75%;" />

<p>原因是我电脑上（Windows）的默认编码格式为 ISO-8859-1，mac上默认是UTF-8。</p>
<p>解决办法：<strong>File -&gt; setting -&gt; Editor -&gt; File Encodings</strong> 修改 properties 文件的编码格式。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219105354734.png" style="zoom:75%;" />

<p>最后中文乱码问题解决：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219105508764.png" style="zoom:75%;" />]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>properties</tag>
        <tag>配置文件</tag>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 的 7 种遍历方式与性能分析</title>
    <url>/post/844a20bd/</url>
    <content><![CDATA[<p>随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式，但应该选择那种遍历方式？反而成了一个问题。</p>
<span id="more"></span>
<p>本文<strong>先从 HashMap 的遍历方法讲起，然后再从性能、原理以及安全性等方面，来分析 HashMap 各种遍历方式的优势与不足</strong>，本文主要内容如下图所示：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220203232307417.png" style="zoom:75%;" />

<h2 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h2><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li>迭代器（Iterator）方式遍历；</li>
<li>For Each 方式遍历；</li>
<li>Lambda 表达式遍历（JDK 1.8+）；</li>
<li>Streams API 遍历（JDK 1.8+）。</li>
</ol>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p>
<ol>
<li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li>
<li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li>
<li>使用 For Each EntrySet 的方式进行遍历；</li>
<li>使用 For Each KeySet 的方式进行遍历；</li>
<li>使用 Lambda 表达式的方式进行遍历；</li>
<li>使用 Streams API 单线程的方式进行遍历；</li>
<li>使用 Streams API 多线程的方式进行遍历。</li>
</ol>
<p>接下来我们来看每种遍历方式的具体实现代码。</p>
<h3 id="迭代器-EntrySet"><a href="#迭代器-EntrySet" class="headerlink" title="迭代器 EntrySet"></a>迭代器 EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Java</span><br><span class="line">2</span><br><span class="line">JDK</span><br><span class="line">3</span><br><span class="line">Spring Framework</span><br><span class="line">4</span><br><span class="line">MyBatis Framework</span><br><span class="line">5</span><br><span class="line">Java中文社群</span><br></pre></td></tr></table></figure>

<h3 id="迭代器-KeySet"><a href="#迭代器-KeySet" class="headerlink" title="迭代器 KeySet"></a>迭代器 KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="ForEach-EntrySet"><a href="#ForEach-EntrySet" class="headerlink" title="ForEach EntrySet"></a>ForEach EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="ForEach-KeySet"><a href="#ForEach-KeySet" class="headerlink" title="ForEach KeySet"></a>ForEach KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Streams-API-单线程"><a href="#Streams-API-单线程" class="headerlink" title="Streams API 单线程"></a>Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Streams-API-多线程"><a href="#Streams-API-多线程" class="headerlink" title="Streams API 多线程"></a>Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>接下来使用 Oracle 官方提供的性能测试工具 <strong>JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）</strong>来测试一下这 7 种循环的性能。</p>
<p>首先，先要引入 JMH 框架，在 <code>pom.xml</code> 文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写测试代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 测试完成时间</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热 2 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试 5 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Fork(1)</span> <span class="comment">// fork 1 个线程</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个测试线程一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapCycleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            put(i, <span class="string">&quot;val:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动基准测试</span></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(HashMapCycle.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line">                .output(<span class="string">&quot;/Users/admin/Desktop/jmh-map.log&quot;</span>) <span class="comment">// 输出测试结果的文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer k = iterator.next();</span><br><span class="line">            String v = map.get(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            Integer k = key;</span><br><span class="line">            String v = map.get(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            Integer k = key;</span><br><span class="line">            String v = value;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单线程遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parallelStreamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有被添加了 <code>@Benchmark</code> 注解的方法都会被测试，因为 parallelStream 为多线程版本性能一定是最好的，所以就不参与测试了，其他 6 个方法的测试结果如下：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220203233203211.png"></p>
<p>其中 Units 为 <code>ns/op</code> 意思是执行完成时间（单位为纳秒），而 Score 列为平均执行时间， <code>±</code> 符号表示误差。从以上结果可以看出，两个 <code>entrySet</code> 的性能相近，并且执行速度最快，接下来是 <code>stream</code> ，然后是两个 <code>keySet</code>，性能最差的是 <code>lambda</code> 。</p>
<blockquote>
<p>注：以上结果基于测试环境：JDK 1.8 / Mac mini (2018) / Idea 2020.1</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>从以上结果可以看出 entrySet 的性能比 keySet 的性能高出了一倍之多，因此我们应该尽量使用 entrySet 来实现 Map 集合的遍历</strong>。</p>
<h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p>要理解以上的测试结果，我们需要把所有遍历代码通过 <code>javac</code> 编译成字节码来看具体的原因。</p>
<p>编译后，我们使用 Idea 打开字节码，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var1 = <span class="number">0</span>; var1 &lt; <span class="number">2</span>; ++var1) &#123;</span><br><span class="line">                <span class="keyword">this</span>.put(var1, <span class="string">&quot;val:&quot;</span> + var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        entrySet();</span><br><span class="line">        keySet();</span><br><span class="line">        forEachEntrySet();</span><br><span class="line">        forEachKeySet();</span><br><span class="line">        lambda();</span><br><span class="line">        streamApi();</span><br><span class="line">        parallelStreamApi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Entry var1 = (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Integer var1 = (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Entry var1 = (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Integer var1 = (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.forEach((var0, var1) -&gt; &#123;</span><br><span class="line">            System.out.println(var0);</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.entrySet().stream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelStreamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.entrySet().parallelStream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 <code>for</code> 循环的遍历的 <code>EntrySet</code> 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 <code>Entry</code> ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Entry var1 = (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Entry var1 = (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>KeySet</code> 的代码也是类似的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Integer var1 = (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Integer var1 = (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在使用迭代器或是 <code>for</code> 循环 <code>EntrySet</code> 时，他们的性能都是相同的，因为他们最终生成的字节码基本都是一样的；同理 <code>KeySet</code> 的两种遍历方式也是类似的。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“<code>Entry&lt;Integer, String&gt; entry = iterator.next()</code>”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h2 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h2><p>从上面的性能测试结果和原理分析，我想大家应该选用哪种遍历方式，已经心中有数的，而接下来从「安全」的角度入手，来分析哪种遍历方式更安全。</p>
<p>把以上遍历划分为四类进行测试：迭代器方式、For 循环方式、Lambda 方式和 Stream 方式，测试代码如下。</p>
<h3 id="迭代器方式"><a href="#迭代器方式" class="headerlink" title="迭代器方式"></a>迭代器方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">show:0</span><br><span class="line">del:1</span><br><span class="line">show:2</span><br></pre></td></tr></table></figure>

<p>测试结果：<strong>迭代器中循环删除数据安全</strong>。</p>
<h3 id="For-循环方式"><a href="#For-循环方式" class="headerlink" title="For 循环方式"></a>For 循环方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204114938065.png" style="zoom:80%;" />

<p>测试结果：<strong>For 循环中删除数据非安全</strong>。</p>
<h3 id="Lambda-方式"><a href="#Lambda-方式" class="headerlink" title="Lambda 方式"></a>Lambda 方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204115254456.png" style="zoom:80%;" />

<p>测试结果：<strong>Lambda 循环中删除数据非安全</strong>。</p>
<p><strong>Lambda 删除的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 map 中的 key 去判断删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; key == <span class="number">1</span>);</span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">show:0</span><br><span class="line">show:2</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，可以先使用 <code>Lambda</code> 的 <code>removeIf</code> 删除多余的数据，再进行循环是一种正确操作集合的方式。</p>
<h3 id="Stream-方式"><a href="#Stream-方式" class="headerlink" title="Stream 方式"></a>Stream 方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204115422219.png" style="zoom:80%;" />

<p>image.png</p>
<p>测试结果：<strong>Stream 循环中删除数据非安全</strong>。</p>
<p><strong>Stream 循环的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().filter(m -&gt; <span class="number">1</span> != m.getKey()).forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：同上。</p>
<p>从上面的代码可以看出，可以使用 <code>Stream</code> 中的 <code>filter</code> 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们讲了 HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，<strong>我们应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap 的 7 种遍历方式与性能分析</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java项目开发命名规范</title>
    <url>/post/158b228/</url>
    <content><![CDATA[<h2 id="Java中的命名规范"><a href="#Java中的命名规范" class="headerlink" title="Java中的命名规范"></a>Java中的命名规范</h2><p>好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速理清程序的脉络。不同语言中采用的命名形式大相径庭，Java 中常用到的命名形式共有三种，既首字母大写的 UpperCamelCase ，首字母小写的 lowerCamelCase 以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，<strong>类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。</strong></p>
<span id="more"></span>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">约束</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">项目名</td>
<td align="left">全部小写，多个单词用中划线分隔 ‘-’</td>
<td align="left">spring-cloud</td>
</tr>
<tr>
<td align="left">包名</td>
<td align="left">全部小写</td>
<td align="left">com.alibaba.fastjson</td>
</tr>
<tr>
<td align="left">类名</td>
<td align="left">单词首字母大写</td>
<td align="left">Feature, ParserConfig,DefaultFieldDeserializer</td>
</tr>
<tr>
<td align="left">变量名</td>
<td align="left">首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td>
<td align="left">password, userName</td>
</tr>
<tr>
<td align="left">常量名</td>
<td align="left">全部大写，多个单词，用‘_’分隔</td>
<td align="left">CACHE_EXPIRED_TIME</td>
</tr>
<tr>
<td align="left">方法</td>
<td align="left">同变量</td>
<td align="left">read(), readObject(), getById()</td>
</tr>
</tbody></table>
<h2 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h2><p><strong>包名</strong>统一使用<strong>小写</strong>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p>
<p>包名的构成可以分为以下几四部分<strong>【前缀】 【发起者名】【项目名】【模块名】</strong>。常见的前缀可以分为以下几种：</p>
<table>
<thead>
<tr>
<th align="left">前缀名</th>
<th align="left">例</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indi（或onem ）</td>
<td align="left">indi.发起者名.项目名.模块名.……</td>
<td align="left">个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。</td>
</tr>
<tr>
<td align="left">pers</td>
<td align="left">pers.个人名.项目名.模块名.……</td>
<td align="left">个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人</td>
</tr>
<tr>
<td align="left">priv</td>
<td align="left">priv.个人名.项目名.模块名.……</td>
<td align="left">私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。</td>
</tr>
<tr>
<td align="left">team</td>
<td align="left">team.团队名.项目名.模块名.……</td>
<td align="left">团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有</td>
</tr>
<tr>
<td align="left">顶级域名</td>
<td align="left">com.公司名.项目名.模块名.……</td>
<td align="left">公司项目，copyright由项目发起的公司所有</td>
</tr>
</tbody></table>
<h2 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h2><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用<strong>形容词或形容词短语</strong>，如 Cloneable，Callable 等，<strong>表示实现该接口的类有某种功能或能力</strong>。对于<strong>测试类则以它要测试的类开头，以 Test 结尾</strong>，如 HashMapTest。</p>
<p>对于一些特殊<strong>特有名词缩写也可以使用全大写</strong>命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest 命名，对于这种特殊的缩写，原则是统一就好。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">约束</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">抽象类</td>
<td align="left">Abstract 或者 Base 开头</td>
<td align="left">BaseUserService</td>
</tr>
<tr>
<td align="left">枚举类</td>
<td align="left">Enum 作为后缀</td>
<td align="left">GenderEnum</td>
</tr>
<tr>
<td align="left">工具类</td>
<td align="left">Utils 作为后缀</td>
<td align="left">StringUtils</td>
</tr>
<tr>
<td align="left">异常类</td>
<td align="left">Exception 结尾</td>
<td align="left">RuntimeException</td>
</tr>
<tr>
<td align="left">接口实现类</td>
<td align="left">接口名 + Impl</td>
<td align="left">UserServiceImpl</td>
</tr>
<tr>
<td align="left">领域模型相关</td>
<td align="left">/DO/DTO/VO/DAO</td>
<td align="left">正例：UserDAO 反例： UserDo， UserDao</td>
</tr>
<tr>
<td align="left">设计模式相关类</td>
<td align="left">Builder，Factory等</td>
<td align="left">当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td>
</tr>
<tr>
<td align="left">处理特定功能的</td>
<td align="left">Handler，Predicate，Validator</td>
<td align="left">表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td>
</tr>
<tr>
<td align="left">测试类</td>
<td align="left">Test 结尾</td>
<td align="left">UserServiceTest， 表示用来测试UserService类的</td>
</tr>
<tr>
<td align="left">MVC分层</td>
<td align="left">Controller，Service，ServiceImpl，DAO后缀</td>
<td align="left">UserManageController，UserManageDAO</td>
</tr>
</tbody></table>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即<strong>动词 + 名词</strong>。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>
<h3 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h3><p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">is</td>
<td align="left">对象是否符合期待的状态</td>
<td align="left">isValid</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">can</td>
<td align="left">对象能否执行所期待的动作</td>
<td align="left">canRemove</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">should</td>
<td align="left">调用方执行某个命令或方法是好还是不好，应不应该，或者说推荐还是不推荐</td>
<td align="left">shouldMigrate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">has</td>
<td align="left">对象是否持有所期待的数据和属性</td>
<td align="left">hasObservers</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">needs</td>
<td align="left">调用方是否需要执行某个命令或方法</td>
<td align="left">needsMigrate</td>
</tr>
</tbody></table>
<h3 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ensure</td>
<td align="left">检查是否为期待的状态，不是则抛出异常或返回error code</td>
<td align="left">ensureCapacity</td>
</tr>
<tr>
<td align="left">validate</td>
<td align="left">检查是否为正确的状态，不是则抛出异常或返回error code</td>
<td align="left">validateInputs</td>
</tr>
</tbody></table>
<h3 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Suffix</td>
<td align="left">IfNeeded</td>
<td align="left">需要的时候执行，不需要的时候什么都不做</td>
<td align="left">drawIfNeeded</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">might</td>
<td align="left">同上</td>
<td align="left">mightCreate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">try</td>
<td align="left">尝试执行，失败时抛出异常或是返回errorcode</td>
<td align="left">tryCreate</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">OrDefault</td>
<td align="left">尝试执行，失败时返回默认值</td>
<td align="left">getOrDefault</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">OrElse</td>
<td align="left">尝试执行、失败时返回实际参数中指定的值</td>
<td align="left">getOrElse</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">force</td>
<td align="left">强制尝试执行，error抛出异常或是返回值</td>
<td align="left">forceCreate, forceStop</td>
</tr>
</tbody></table>
<h3 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">blocking</td>
<td align="left">线程阻塞方法</td>
<td align="left">blockingGetUser</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">InBackground</td>
<td align="left">执行在后台的线程</td>
<td align="left">doInBackground</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">Async</td>
<td align="left">异步方法</td>
<td align="left">sendAsync</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">Sync</td>
<td align="left">对应已有异步方法的同步方法</td>
<td align="left">sendSync</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">schedule</td>
<td align="left">Job和Task放入队列</td>
<td align="left">schedule, scheduleJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">post</td>
<td align="left">同上</td>
<td align="left">postJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">execute</td>
<td align="left">执行异步方法（注：我一般拿这个做同步方法名）</td>
<td align="left">execute, executeTask</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">start</td>
<td align="left">同上</td>
<td align="left">start, startJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">cancel</td>
<td align="left">停止异步方法</td>
<td align="left">cancel, cancelJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">stop</td>
<td align="left">同上</td>
<td align="left">stop, stopJob</td>
</tr>
</tbody></table>
<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">on</td>
<td align="left">事件发生时执行</td>
<td align="left">onCompleted</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">before</td>
<td align="left">事件发生前执行</td>
<td align="left">beforeUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">pre</td>
<td align="left">同上</td>
<td align="left">preUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">will</td>
<td align="left">同上</td>
<td align="left">willUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">after</td>
<td align="left">事件发生后执行</td>
<td align="left">afterUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">post</td>
<td align="left">同上</td>
<td align="left">postUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">did</td>
<td align="left">同上</td>
<td align="left">didUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">should</td>
<td align="left">确认事件是否可以发生时执行</td>
<td align="left">shouldUpdate</td>
</tr>
</tbody></table>
<h3 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">initialize</td>
<td align="left">初始化。也可作为延迟初始化使用</td>
<td align="left">initialize</td>
</tr>
<tr>
<td align="left">pause</td>
<td align="left">暂停</td>
<td align="left">onPause ，pause</td>
</tr>
<tr>
<td align="left">stop</td>
<td align="left">停止</td>
<td align="left">onStop，stop</td>
</tr>
<tr>
<td align="left">abandon</td>
<td align="left">销毁的替代</td>
<td align="left">abandon</td>
</tr>
<tr>
<td align="left">destroy</td>
<td align="left">同上</td>
<td align="left">destroy</td>
</tr>
<tr>
<td align="left">dispose</td>
<td align="left">同上</td>
<td align="left">dispose</td>
</tr>
</tbody></table>
<h3 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contains</td>
<td align="left">是否持有与指定对象相同的对象</td>
<td align="left">contains</td>
</tr>
<tr>
<td align="left">add</td>
<td align="left">添加</td>
<td align="left">addJob</td>
</tr>
<tr>
<td align="left">append</td>
<td align="left">添加</td>
<td align="left">appendJob</td>
</tr>
<tr>
<td align="left">insert</td>
<td align="left">插入到下标 n 的位置</td>
<td align="left">insertJob</td>
</tr>
<tr>
<td align="left">put</td>
<td align="left">添加与key对应的元素</td>
<td align="left">putJob</td>
</tr>
<tr>
<td align="left">remove</td>
<td align="left">移除元素</td>
<td align="left">removeJob</td>
</tr>
<tr>
<td align="left">enqueue</td>
<td align="left">添加到队列的最末位</td>
<td align="left">enqueueJob</td>
</tr>
<tr>
<td align="left">dequeue</td>
<td align="left">从队列中头部取出并移除</td>
<td align="left">dequeueJob</td>
</tr>
<tr>
<td align="left">push</td>
<td align="left">添加到栈头</td>
<td align="left">pushJob</td>
</tr>
<tr>
<td align="left">pop</td>
<td align="left">从栈头取出并移除</td>
<td align="left">popJob</td>
</tr>
<tr>
<td align="left">peek</td>
<td align="left">从栈头取出但不移除</td>
<td align="left">peekJob</td>
</tr>
<tr>
<td align="left">find</td>
<td align="left">寻找符合条件的某物</td>
<td align="left">findById</td>
</tr>
</tbody></table>
<h3 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">create</td>
<td align="left">新创建</td>
<td align="left">createAccount</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">新创建</td>
<td align="left">newAccount</td>
</tr>
<tr>
<td align="left">from</td>
<td align="left">从既有的某物新建，或是从其他的数据新建</td>
<td align="left">fromConfig</td>
</tr>
<tr>
<td align="left">to</td>
<td align="left">转换</td>
<td align="left">toString</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">更新既有某物</td>
<td align="left">updateAccount</td>
</tr>
<tr>
<td align="left">load</td>
<td align="left">读取</td>
<td align="left">loadAccount</td>
</tr>
<tr>
<td align="left">fetch</td>
<td align="left">远程读取</td>
<td align="left">fetchAccount</td>
</tr>
<tr>
<td align="left">delete</td>
<td align="left">删除</td>
<td align="left">deleteAccount</td>
</tr>
<tr>
<td align="left">remove</td>
<td align="left">删除</td>
<td align="left">removeAccount</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">保存</td>
<td align="left">saveAccount</td>
</tr>
<tr>
<td align="left">store</td>
<td align="left">保存</td>
<td align="left">storeAccount</td>
</tr>
<tr>
<td align="left">commit</td>
<td align="left">保存</td>
<td align="left">commitChange</td>
</tr>
<tr>
<td align="left">apply</td>
<td align="left">保存或应用</td>
<td align="left">applyChange</td>
</tr>
<tr>
<td align="left">clear</td>
<td align="left">清除数据或是恢复到初始状态</td>
<td align="left">clearAll</td>
</tr>
<tr>
<td align="left">reset</td>
<td align="left">清除数据或是恢复到初始状态</td>
<td align="left">resetAll</td>
</tr>
</tbody></table>
<h3 id="成对出现的动词"><a href="#成对出现的动词" class="headerlink" title="成对出现的动词"></a>成对出现的动词</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">get 获取</td>
<td align="left">set 设置</td>
</tr>
<tr>
<td align="left">add 增加</td>
<td align="left">remove 删除</td>
</tr>
<tr>
<td align="left">create 创建</td>
<td align="left">destory 移除</td>
</tr>
<tr>
<td align="left">start 启动</td>
<td align="left">stop 停止</td>
</tr>
<tr>
<td align="left">open 打开</td>
<td align="left">close 关闭</td>
</tr>
<tr>
<td align="left">read 读取</td>
<td align="left">write 写入</td>
</tr>
<tr>
<td align="left">load 载入</td>
<td align="left">save 保存</td>
</tr>
<tr>
<td align="left">create 创建</td>
<td align="left">destroy 销毁</td>
</tr>
<tr>
<td align="left">begin 开始</td>
<td align="left">end 结束</td>
</tr>
<tr>
<td align="left">backup 备份</td>
<td align="left">restore 恢复</td>
</tr>
<tr>
<td align="left">import 导入</td>
<td align="left">export 导出</td>
</tr>
<tr>
<td align="left">split 分割</td>
<td align="left">merge 合并</td>
</tr>
<tr>
<td align="left">inject 注入</td>
<td align="left">extract 提取</td>
</tr>
<tr>
<td align="left">attach 附着</td>
<td align="left">detach 脱离</td>
</tr>
<tr>
<td align="left">bind 绑定</td>
<td align="left">separate 分离</td>
</tr>
<tr>
<td align="left">view 查看</td>
<td align="left">browse 浏览</td>
</tr>
<tr>
<td align="left">edit 编辑</td>
<td align="left">modify 修改</td>
</tr>
<tr>
<td align="left">select 选取</td>
<td align="left">mark 标记</td>
</tr>
<tr>
<td align="left">copy 复制</td>
<td align="left">paste 粘贴</td>
</tr>
<tr>
<td align="left">undo 撤销</td>
<td align="left">redo 重做</td>
</tr>
<tr>
<td align="left">insert 插入</td>
<td align="left">delete 移除</td>
</tr>
<tr>
<td align="left">add 加入</td>
<td align="left">append 添加</td>
</tr>
<tr>
<td align="left">clean 清理</td>
<td align="left">clear 清除</td>
</tr>
<tr>
<td align="left">index 索引</td>
<td align="left">sort 排序</td>
</tr>
<tr>
<td align="left">find 查找</td>
<td align="left">search 搜索</td>
</tr>
<tr>
<td align="left">increase 增加</td>
<td align="left">decrease 减少</td>
</tr>
<tr>
<td align="left">play 播放</td>
<td align="left">pause 暂停</td>
</tr>
<tr>
<td align="left">launch 启动</td>
<td align="left">run 运行</td>
</tr>
<tr>
<td align="left">compile 编译</td>
<td align="left">execute 执行</td>
</tr>
<tr>
<td align="left">debug 调试</td>
<td align="left">trace 跟踪</td>
</tr>
<tr>
<td align="left">observe 观察</td>
<td align="left">listen 监听</td>
</tr>
<tr>
<td align="left">build 构建</td>
<td align="left">publish 发布</td>
</tr>
<tr>
<td align="left">input 输入</td>
<td align="left">output 输出</td>
</tr>
<tr>
<td align="left">encode 编码</td>
<td align="left">decode 解码</td>
</tr>
<tr>
<td align="left">encrypt 加密</td>
<td align="left">decrypt 解密</td>
</tr>
<tr>
<td align="left">compress 压缩</td>
<td align="left">decompress 解压缩</td>
</tr>
<tr>
<td align="left">pack 打包</td>
<td align="left">unpack 解包</td>
</tr>
<tr>
<td align="left">parse 解析</td>
<td align="left">emit 生成</td>
</tr>
<tr>
<td align="left">connect 连接</td>
<td align="left">disconnect 断开</td>
</tr>
<tr>
<td align="left">send 发送</td>
<td align="left">receive 接收</td>
</tr>
<tr>
<td align="left">download 下载</td>
<td align="left">upload 上传</td>
</tr>
<tr>
<td align="left">refresh 刷新</td>
<td align="left">synchronize 同步</td>
</tr>
<tr>
<td align="left">update 更新</td>
<td align="left">revert 复原</td>
</tr>
<tr>
<td align="left">lock 锁定</td>
<td align="left">unlock 解锁</td>
</tr>
<tr>
<td align="left">check out 签出</td>
<td align="left">check in 签入</td>
</tr>
<tr>
<td align="left">submit 提交</td>
<td align="left">commit 交付</td>
</tr>
<tr>
<td align="left">push 推</td>
<td align="left">pull 拉</td>
</tr>
<tr>
<td align="left">expand 展开</td>
<td align="left">collapse 折叠</td>
</tr>
<tr>
<td align="left">begin 起始</td>
<td align="left">end 结束</td>
</tr>
<tr>
<td align="left">start 开始</td>
<td align="left">finish 完成</td>
</tr>
<tr>
<td align="left">enter 进入</td>
<td align="left">exit 退出</td>
</tr>
<tr>
<td align="left">abort 放弃</td>
<td align="left">quit 离开</td>
</tr>
<tr>
<td align="left">obsolete 废弃</td>
<td align="left">depreciate 废旧</td>
</tr>
<tr>
<td align="left">collect 收集</td>
<td align="left">aggregate 聚集</td>
</tr>
</tbody></table>
<h2 id="变量-amp-常量命名"><a href="#变量-amp-常量命名" class="headerlink" title="变量&amp;常量命名"></a>变量&amp;常量命名</h2><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量是指在程序运行中可以改变其值的量，包括<strong>成员变量</strong>和<strong>局部变量</strong>。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称<strong>骆驼式命名法（也称驼峰命名法）</strong>，如 computedValues，index、变量命名时，<strong>尽量简短且能清楚的表达变量的作用</strong>，命名体现具体的业务含义即可。</p>
<p><strong>变量名不应以下划线或美元符号开头</strong>，尽管这在语法上是允许的。变量名应<strong>简短且富于描述</strong>。变量名的选用应该易于记忆，即，能够指出其用途。<strong>尽量避免单个字符的变量名，除非是一次性的临时变量</strong>。pojo中的布尔变量，都不要加is（数据库中的布尔字段全都要加 is_ 前缀）。</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量命名CONSTANT_CASE，一般采用<strong>全部大写（作为方法参数时除外）</strong>，<strong>单词间用下划线分割</strong>。那么什么是常量呢？</p>
<p>常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，<strong>全局常量（public static final修饰）</strong>，<strong>类内常量（private static final 修饰）</strong>以及<strong>局部常量（方法内，或者参数中的常量）</strong>，<strong>局部常量比较特殊，通常采用小驼峰命名即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(正例)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_MESSAGE_CACHE_EXPIRE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(反例，命名不清晰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MESSAGE_CACHE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">&quot; error message&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印 &#123;<span class="doctag">@code</span> message&#125; 信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体，局部常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量一般都有自己的业务含义，<strong>不要害怕长度过长而进行省略或者缩写</strong>。如：用户消息缓存过期时间的表示，哪种方式更佳清晰，交给你来评判。</p>
<h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol>
<li>尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。 正例： BeiJing， HangZhou 反例： validateCanShu</li>
<li>命名过程中尽量不要出现特殊的字符，常量除外。</li>
<li>尽量不要和 jdk或者框架中已存在的类重名，也不能使用 java中的关键字命名。</li>
<li>妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。 如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。</li>
</ol>
<h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="注解的原则"><a href="#注解的原则" class="headerlink" title="注解的原则"></a>注解的原则</h3><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p>
<ol>
<li><p><strong>Nothing is strange</strong> 没有注解的代码对于阅读者非常不友好，哪怕代码写的再清楚，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还要说清楚修改的逻辑。</p>
</li>
<li><p><strong>Less is more</strong> 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取信息【废话注解】</span></span><br><span class="line">getMessageById(id)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Advance with the time</strong> 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</p>
</li>
</ol>
<h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成 JavaAPI为外部用户提供有效的支持 javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。</p>
<h4 id="包注解"><a href="#包注解" class="headerlink" title="包注解"></a>包注解</h4><p>包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 落地也质量检测</span></span><br><span class="line"><span class="comment"> * 1. 用来解决什么问题</span></span><br><span class="line"><span class="comment"> * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 如何实现</span></span><br><span class="line"><span class="comment"> * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意： 网络环境配置信息&#123;<span class="doctag">@link</span> cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum&#125;目前使用是常规速度，可以根据实际情况进行调整</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/12/7 20:3 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.mycookies.landingpagecheck;</span><br></pre></td></tr></table></figure>

<h4 id="类注接"><a href="#类注接" class="headerlink" title="类注接"></a>类注接</h4><p>javadoc注解中，每个类都必须有注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (C), 2019-2020, Jann  balabala...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>   类创建者姓名 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>     创建日期 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>  版本号 保持对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h4><p>在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 提示信息 */</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>

<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法的详细说明，能干嘛，怎么实现的，注意事项...</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx   参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回结果的说明， 不同情况下会返回怎样的结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h4 id="构造方法注释"><a href="#构造方法注释" class="headerlink" title="构造方法注释"></a>构造方法注释</h4><p>在每个构造方法前面必须加上注释，注释模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法的详细说明</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx   参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<p>而简单注解往往是需要工程师自己定义，在使用注解时应该注意一下几点：</p>
<ol>
<li><strong>枚举类的各个属性值都要使用注解</strong>，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。</li>
<li><strong>保持排版整洁，不要使用行尾注释</strong>；<strong>双斜杠和星号之后要用1个空格分隔</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">1</span>;<span class="comment">// 反例：不要使用行尾注释</span></span><br><span class="line"><span class="comment">//反例：换行符与注释之间没有缩进</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 正例：姓名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 多行注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 对于不同的逻辑说明，可以用空行分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>




<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://www.cnblogs.com/liqiangchn/p/12000361.html">告别编码5分钟，命名2小时！史上最全的Java命名规范参考！</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（基础）</title>
    <url>/post/7f164aae/</url>
    <content><![CDATA[<h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称<strong>主线程</strong>。</p>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202211820997.png" style="zoom:75%;" />

<h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[5] Attach Listener //添加事件</span><br><span class="line">[4] Signal Dispatcher //分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer //调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler //清除 reference 线程</span><br><span class="line">[1] main //main 线程,程序入口</span><br></pre></td></tr></table></figure>

<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p>
<h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202212556937.png" style="zoom:80%;" />

<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h3 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h3><ul>
<li><strong>虚拟机栈：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong>等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是<strong>所有线程共享的资源</strong>，其中<strong>堆是进程中最大的一块内存</strong>，主要用于存放<strong>新创建的对象</strong>（几乎所有对象都在这里分配内存），方法区主要用于存放<strong>已被加载的类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</p>
<h2 id="说说并发与并行的区别？"><a href="#说说并发与并行的区别？" class="headerlink" title="说说并发与并行的区别？"></a>说说并发与并行的区别？</h2><p><strong>并发：</strong>同一时间段，多个任务都在执行（单位时间内不一定同时执行）；</p>
<p><strong>并行：</strong>单位时间内（同一时刻），多个任务同时执行。</p>
<h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是<strong>程序执行的最小单位</strong>，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>：多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
<h2 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h2 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202220155953.png" alt="图源《Java 并发编程艺术》4.1.4 节"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202220327647.png" alt="图源《Java 并发编程艺术》4.1.4 节"></p>
<blockquote>
<p>订正(来自<a href="https://github.com/Snailclimb/JavaGuide/issues/736">issue736</a>)：原图中 wait 到 runnable 状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p>
</blockquote>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong>（摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">java线程运行怎么有第六种状态？ - Dawell的回答</a>）现在的<strong>时分</strong>（time-sharing）<strong>多任务</strong>（multi-task）操作系统架构通常都是用所谓的“<strong>时间分片</strong>（time quantum or time slice）”方式进行<strong>抢占式</strong>（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202221236800.png"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING（超时等待）</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code>方法或 <code>wait(long millis)</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用<strong>同步方法</strong>时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</a></p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>线程在执行过程中会有自己的<strong>运行条件和状态</strong>（也称<strong>上下文</strong>），比如上文所说到过的<strong>程序计数器</strong>，<strong>栈信息</strong>等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行。</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="什么是线程死锁？如何避免死锁？"><a href="#什么是线程死锁？如何避免死锁？" class="headerlink" title="什么是线程死锁？如何避免死锁？"></a>什么是线程死锁？如何避免死锁？</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202222752163.png"></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<p>产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称&lt;P1、P2、P3…..Pn&gt;序列为安全序列。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">	System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul>
<li>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程<strong>进入了就绪状态</strong>，当分配到时间片后就可以<strong>开始运行</strong>了。 <code>start()</code> 会执行线程的相应<strong>准备工作</strong>，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">Java 并发常见知识点&amp;面试题总结（基础篇）</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven parent.relativePath 说明</title>
    <url>/post/b60506ad/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br></pre></td></tr></table></figure>

<p> xml 原生英文解释：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;relativePath&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span> <span class="attr">default</span>=<span class="string">&quot;../pom.xml&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:documentation</span> <span class="attr">source</span>=<span class="string">&quot;version&quot;</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:documentation</span> <span class="attr">source</span>=<span class="string">&quot;description&quot;</span>&gt;</span></span><br><span class="line">      The relative path of the parent <span class="symbol">&amp;lt;</span>code<span class="symbol">&amp;gt;</span>pom.xml<span class="symbol">&amp;lt;</span>/code<span class="symbol">&amp;gt;</span> file within the check out.</span><br><span class="line">      The default value is <span class="symbol">&amp;lt;</span>code<span class="symbol">&amp;gt;</span>../pom.xml<span class="symbol">&amp;lt;</span>/code<span class="symbol">&amp;gt;</span>.</span><br><span class="line">      Maven looks for the parent pom first in the reactor of currently building projects, then in this location on</span><br><span class="line">      the filesystem, then the local repository, and lastly in the remote repo.</span><br><span class="line">      <span class="symbol">&amp;lt;</span>code<span class="symbol">&amp;gt;</span>relativePath<span class="symbol">&amp;lt;</span>/code<span class="symbol">&amp;gt;</span> allows you to select a different location,</span><br><span class="line">      for example when your structure is flat, or deeper without an intermediate parent pom.</span><br><span class="line">      However, the group ID, artifact ID and version are still required,</span><br><span class="line">      and must match the file in the location given or it will revert to the repository for the POM.</span><br><span class="line">      This feature is only for enhancing the development in a local checkout of that project.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:documentation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><p>relativePath 是Maven为了寻找父模块pom.xml所额外增加的一个寻找路径</p>
</li>
<li><p>relativePath 默认值为 ../pom.xml</p>
</li>
<li><p><strong>Maven 寻找父模块pom.xml 的顺序如下：</strong></p>
<ol>
<li><p>first in the reactor of currently building projects<br>这里一个maven概念 反应堆（reactor ），意思就是先从工程里面有依赖相关的模块中找你引入的 parent 的pom.xml。</p>
</li>
<li><p>then in this location on the filesystem<br>然后从你定义的  <code>&lt;relativePath&gt;</code> 路径中找，当然你如果只是 <code>/</code>  即空值，则跳过该步骤，默认值 ../pom.xml 则是从上级目录中找。</p>
</li>
<li><p>then the local repository</p>
<p>如果 （1） （2） 步骤没有则从 本地仓库找。</p>
</li>
<li><p>and lastly in the remote repo</p>
<p>上面都找不到了，最后只能从远程仓库找，再找不到就报错。</p>
</li>
</ol>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://blog.csdn.net/gzt19881123/article/details/105255138">Maven parent.relativePath 说明</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/post/9fa75fc1/</url>
    <content><![CDATA[<p>Java <em>Lambda 表达式</em>的一个重要用法是简化某些<em>匿名内部类</em>（<code>Anonymous Classes</code>）的写法。实际上 Lambda 表达式并不仅仅是匿名内部类的语法糖，JVM 内部是通过<em>invokedynamic</em>指令来实现 Lambda 表达式的。具体原理放到下一篇。本篇我们首先感受一下使用 Lambda 表达式带来的便利之处。</p>
<span id="more"></span>
<h2 id="Lambda-and-Anonymous-Classes-I"><a href="#Lambda-and-Anonymous-Classes-I" class="headerlink" title="Lambda and Anonymous Classes(I)"></a>Lambda and Anonymous Classes(I)</h2><p>本节将介绍如何使用 Lambda 表达式简化匿名内部类的书写，但 Lambda 表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。先别在乎细节，看几个例子再说。</p>
<p>例子 1：无参函数的简写</p>
<p>如果需要新建一个线程，一种常见的写法是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;<span class="comment">// 接口名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Thread run()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>上述代码给<code>Tread</code>类传递了一个匿名的<code>Runnable</code>对象，重载<code>Runnable</code>接口的<code>run()</code>方法来实现相应逻辑。这是 JDK7 以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在 Java 8 中可以简化为如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">		() -&gt; System.out.println(<span class="string">&quot;Thread run()&quot;</span>)<span class="comment">// 省略接口名和方法名</span></span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的，但比匿名内部类更进一步。这里连<strong>接口名和函数名都一同省掉</strong>了，写起来更加神清气爽。如果函数体有多行，可以用大括号括起来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式代码块写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; Hoolee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>例子 2：带参函数的简写</p>
<p>如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7 的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;<span class="comment">// 接口名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码通过内部类重载了<code>Comparator</code>接口的<code>compare()</code>方法，实现比较逻辑。采用 Lambda 表达式可简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt;&#123;<span class="comment">// 省略参数表的类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于<code>javac</code>的<strong>类型推断</strong>机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java 是强类型语言，每个变量和对象都必需有明确的类型。</p>
<h3 id="简写的依据"><a href="#简写的依据" class="headerlink" title="简写的依据"></a>简写的依据</h3><p>也许你已经想到了，<strong>能够使用 Lambda 的依据是必须有相应的函数接口</strong>（函数接口，是指内部只有一个抽象方法的接口）。这一点跟 Java 是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写 Lambda 表达式。实际上<em>Lambda 的类型就是对应函数接口的类型</em>。<strong>Lambda 表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda 表达更多合法的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的书写形式</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">// 1</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>);<span class="comment">// 2</span></span><br><span class="line">Runnable multiLine = () -&gt; &#123;<span class="comment">// 3 代码块</span></span><br><span class="line">    System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; Hoolee&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class="comment">// 4</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class="comment">// 5 类型推断</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，1 展示了无参函数的简写；2 处展示了有参函数的简写，以及类型推断机制；3 是代码块的写法；4 和 5 再次展示了类型推断机制。</p>
<h3 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h3><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的@FunctionalInterface 是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override 标注会检查是否重载了函数一样。</p>
<p>有了上述接口定义，就可以写出类似如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>进一步的，还可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myForEach</span><span class="params">(ConsumerInterface&lt;T&gt; consumer)</span></span>&#123;<span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">for</span>(T t : list)&#123;</span><br><span class="line">			consumer.accept(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyStream&lt;String&gt; stream = <span class="keyword">new</span> MyStream&lt;String&gt;();</span><br><span class="line">stream.myForEach(str -&gt; System.out.println(str));<span class="comment">// 使用自定义函数接口书写Lambda表达式</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda-and-Anonymous-Classes-II"><a href="#Lambda-and-Anonymous-Classes-II" class="headerlink" title="Lambda and Anonymous Classes(II)"></a>Lambda and Anonymous Classes(II)</h2><p>读过上一篇之后，相信对 Lambda 表达式的语法以及基本原理有了一定了解。对于编写代码，有这些知识已经够用。本文将<strong>进一步区分 Lambda 表达式和匿名内部类在 JVM 层面的区别，如果对这一部分不感兴趣，可以跳过</strong>。</p>
<p>经过第一篇的的介绍，我们看到 Lambda 表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的 Lambda 表达式替换成匿名内部类就可以了。但实时并非如此。在 JVM 层面，Lambda 表达式和匿名内部类有着明显的差别。</p>
<h3 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h3><p><strong>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名</strong>。因此如果有如下形式的代码，编译之后将会产生两个 class 文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Anonymous Class Thread run()&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>编译之后文件分布如下，两个 class 文件分别是主类和匿名内部类产生的：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/2-AnonymousClass.png"></p>
<p>进一步分析主类 MainAnonymousClass.class 的字节码，可发现其创建了匿名内部类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c MainAnonymousClass.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class MainAnonymousClass$1 /*创建内部类对象*/</span></span><br><span class="line">       <span class="number">7</span>: dup</span><br><span class="line">       <span class="number">8</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method MainAnonymousClass$1.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">11</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式实现"><a href="#Lambda-表达式实现" class="headerlink" title="Lambda 表达式实现"></a>Lambda 表达式实现</h3><p><strong>Lambda 表达式通过 invokedynamic 指令实现，书写 Lambda 表达式不会产生新的类</strong>。如果有如下代码，编译之后只有一个 class 文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(</span><br><span class="line">				() -&gt; System.out.println(<span class="string">&quot;Lambda Thread run()&quot;</span>)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的结果：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/2-Lambda.png"></p>
<p>通过 javap 反编译命名，我们更能看出 Lambda 表达式内部表示的不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c -p MainLambda.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokedynamic #<span class="number">3</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();  <span class="comment">/*Lambda表达式被封装成主类的私有方法*/</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Lambda Thread run()</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后我们发现 Lambda 表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p>
<h3 id="推论，this-引用的意义"><a href="#推论，this-引用的意义" class="headerlink" title="推论，this 引用的意义"></a>推论，this 引用的意义</h3><p>既然 Lambda 表达式不是内部类的简写，那么 Lambda 内部的<code>this</code>引用也就跟内部类对象没什么关系了。在 Lambda 表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出两遍<code>Hello Hoolee</code>，而不是两个引用地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>); &#125;;</span><br><span class="line">	Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">		<span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello Hoolee&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h2><p>我们先从最熟悉的*Java 集合框架(Java Collections Framework, JCF)*开始说起。</p>
<p>为引入 Lambda 表达式，Java8 新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是 Lambda 表达式的基础，Java 集合框架也新增部分接口，以便与 Lambda 表达式对接。</p>
<p>首先回顾一下 Java 集合框架的接口继承结构：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/JCF_Collection_Interfaces.png"></p>
<p>上图中绿色标注的接口类，表示在 Java8 中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8 新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟 Lambda 表达式相关。我们将逐一学习这些方法。</p>
<h3 id="Collection-中的新方法"><a href="#Collection-中的新方法" class="headerlink" title="Collection 中的新方法"></a>Collection 中的新方法</h3><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以是<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于 3 的字符串.</em></p>
<p>Java7 及以前我们可以用增强的 for 循环实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记 Lambda 表达式，使用 Lambda 表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码给<code>forEach()</code>方法传入一个 Lambda 表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于 3 的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用 Lambda 表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的 Lambda 表达式就行了。</p>
<h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于 3 的元素转换成大写，其余元素不变。</em></p>
<p>Java7 及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的 Lambda 表达式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于 Java7 以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在可以直接使用<code>List.sort()方法</code>，结合 Lambda 表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h4 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream()和 parallelStream()"></a>stream()和 parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。**<code>Stream</code>是 Java 函数式编程的核心类**，我们会在后面章节中学习。</p>
<h3 id="Map-中的新方法"><a href="#Map-中的新方法" class="headerlink" title="Map 中的新方法"></a>Map 中的新方法</h3><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md">Java7<code>HashMap</code>实现原理</a>，将有助于理解下文。</p>
<h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的 Map，请输出 Map 中的所有映射关系．</em></p>
<p>Java7 以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;=&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有 Lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟 Lambda 表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是**按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>**。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的 Map，输出 4 对应的英文单词，如果不存在则输出 NoValue</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;NoValue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">&quot;NoValue&quot;</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟 Lambda 表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8 新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做．</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在 Java7 及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8 在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的 Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7 以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用 Lambda 表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>简洁到让人难以置信．</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的使用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>

<h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>

<h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;yi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Java8 为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写 Lambda 表达式时类型推断帮我们做了一切．</li>
</ol>
<h2 id="Streams-API-I"><a href="#Streams-API-I" class="headerlink" title="Streams API(I)"></a>Streams API(I)</h2><p>你可能没意识到 Java 对函数式编程的重视程度，看看 Java 8 加入函数式编程扩充多少功能就清楚了。Java 8 之所以费这么大功夫引入函数式编程，原因有二：</p>
<ol>
<li><strong>代码简洁</strong>函数式编程写出的代码简洁且意图明确，使用<em>stream</em>接口让你从此告别<em>for</em>循环。</li>
<li><strong>多核友好</strong>，Java 函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下<code>parallel()</code>方法。</li>
</ol>
<p>这一节我们学习<em>stream</em>，也就是 Java 函数式编程的主角。对于 Java 7 来说<em>stream</em>完全是个陌生东西，<em>stream</em>并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java 容器或 I/O channel 等。正因如此要得到一个<em>stream</em>通常不会手动创建，而是调用对应的工具方法，比如：</p>
<ul>
<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>
<li>调用<code>Arrays.stream(T[] array)</code>方法</li>
</ul>
<p>常见的<em>stream</em>接口继承关系如图：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Java_stream_Interfaces.png"></p>
<p>图中 4 种<em>stream</em>接口继承自<code>BaseStream</code>，其中<code>IntStream, LongStream, DoubleStream</code>对应三种基本类型（<code>int, long, double</code>，注意不是包装类型），<code>Stream</code>对应所有剩余类型的<em>stream</em>视图。为不同数据类型设置不同<em>stream</em>接口，可以 1.提高性能，2.增加特定接口函数。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/WRONG_Java_stream_Interfaces.png"></p>
<p>你可能会奇怪为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为 Java 不允许只有返回类型不同的方法重载。</p>
<p>虽然大部分情况下<em>stream</em>是容器调用<code>Collection.stream()</code>方法得到的，但<em>stream</em>和<em>collections</em>有以下不同：</p>
<ul>
<li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java 容器或 I/O channel 等。</li>
<li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li>
<li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>对<em>stream</em>的操作分为为两类，**中间操作(intermediate operations)和结束操作(terminal operations)**，二者特点是：</p>
<ol>
<li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li>
<li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li>
</ol>
<p>如果你熟悉 Apache Spark RDD，对<em>stream</em>的这个特点应该不陌生。</p>
<p>下表汇总了<code>Stream</code>接口的部分常见方法：</p>
<table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">接口方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中间操作</td>
<td align="left">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td align="left">结束操作</td>
<td align="left">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody></table>
<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p>
<h3 id="stream-方法使用"><a href="#stream-方法使用" class="headerlink" title="stream 方法使用"></a>stream 方法使用</h3><p><em>stream</em>跟函数接口关系非常紧密，没有函数接口<em>stream</em>就无法工作。回顾一下：<strong>函数接口是指内部只有一个抽象方法的接口</strong>。通常函数接口出现的地方都可以使用 Lambda 表达式，所以不必记忆函数接口的名字。</p>
<h4 id="forEach-2"><a href="#forEach-2" class="headerlink" title="forEach()"></a>forEach()</h4><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>由于<code>forEach()</code>是结束方法，上述代码会立即执行，输出所有字符串。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.filter.png"></p>
<p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出为长度等于 3 的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.distinct.png"></p>
<p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码会输出去掉一个<code>too</code>之后的其余字符串。</p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt; sorted()</code>和<code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.map.png"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);stream.map(str -&gt; str.toUpperCase())    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出原字符串的大写形式。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.flatMap.png"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都”摊平”之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));stream.flatMap(list -&gt; list.stream())    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>

<p>上述代码中，原来的<code>stream</code>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个<code>List</code>都“摊平”成了一个个的数字，所以会新产生一个由 5 个数字组成的<code>Stream</code>。所以最终将输出 1~5 这 5 个数字。</p>
<p>截止到目前我们感觉良好，已介绍<code>Stream</code>接口函数理解起来并不费劲儿。如果你就此以为函数式编程不过如此，恐怕是高兴地太早了。下一节对<code>Stream</code>规约操作的介绍将刷新你现在的认识。</p>
<h2 id="Streams-API-II"><a href="#Streams-API-II" class="headerlink" title="Streams API(II)"></a>Streams API(II)</h2><p>上一节介绍了部分<em>Stream</em>常见接口方法，理解起来并不困难，但<em>Stream</em>的用法不止于此，本节我们将仍然以<em>Stream</em>为例，介绍流的规约操作。</p>
<p>规约操作（_reduction operation_）又被称作折叠操作（_fold_），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<em>Stream</em>类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>
<p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍<code>reduce()</code>和<code>collect()</code>，这是比较有魔法的地方。</p>
<h3 id="多面手-reduce"><a href="#多面手-reduce" class="headerlink" title="多面手 reduce()"></a>多面手 reduce()</h3><p><em>reduce</em>操作可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<em>reduce</em>操作，将他们单独设为函数只是因为常用。<code>reduce()</code>的方法定义有三种重写形式：</p>
<ul>
<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></li>
<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></li>
<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>
</ul>
<p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数<em>identity</em>），或者是指定并行执行时多个部分结果的合并方式（参数<em>combiner</em>）。<code>reduce()</code>最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>
<p>需求：_从一组单词中找出最长的单词_。这里“大”的含义就是“长”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>

<p>上述代码会选出最长的单词<em>love</em>，其中<em>Optional</em>是（一个）值的容器，使用它可以避免<em>null</em>值的麻烦。当然可以使用<code>Stream.max(Comparator&lt;? super T&gt; comparator)</code>方法来达到同等效果，但<code>reduce()</code>自有其存在的理由。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.reduce_parameter.png"></p>
<p>需求：_求出一组单词的长度之和_。这是个“求和”操作，操作对象输入类型是<em>String</em>，而结果类型是<em>Integer</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求单词长度之和</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Integer lengthSum = stream.reduce(<span class="number">0</span>,　<span class="comment">// 初始值　// (1)</span></span><br><span class="line">        (sum, str) -&gt; sum+str.length(), <span class="comment">// 累加器 // (2)</span></span><br><span class="line">        (a, b) -&gt; a+b);　<span class="comment">// 部分和拼接器，并行执行时才会用到 // (3)</span></span><br><span class="line"><span class="comment">// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();</span></span><br><span class="line">System.out.println(lengthSum);</span><br></pre></td></tr></table></figure>

<p>上述代码标号(2)处将 i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用<code>reduce()</code>函数将这两步合二为一，更有助于提升性能。如果想要使用<code>map()</code>和<code>sum()</code>组合来达到上述目的，也是可以的。</p>
<p><code>reduce()</code>擅长的是生成一个值，如果想要从<em>Stream</em>生成一个集合或者<em>Map</em>等复杂的对象该怎么办呢？终极武器<code>collect()</code>横空出世！</p>
<h3 id="终极武器-collect"><a href="#终极武器-collect" class="headerlink" title="终极武器 collect()"></a>终极武器 collect()</h3><p>不夸张的讲，如果你发现某个功能在<em>Stream</em>接口中没找到，十有八九可以通过<code>collect()</code>方法实现。<code>collect()</code>是<em>Stream</em>接口方法中最灵活的一个，学会它才算真正入门 Java 函数式编程。先看几个热身的小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成容器或Map</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)</span></span><br></pre></td></tr></table></figure>

<p>上述代码分别列举了如何将<em>Stream</em>转换成<em>List</em>、<em>Set</em>和<em>Map</em>。虽然代码语义很明确，可是我们仍然会有几个疑问：</p>
<ol>
<li><code>Function.identity()</code>是干什么的？</li>
<li><code>String::length</code>是什么意思？</li>
<li><em>Collectors</em>是个什么东西？</li>
</ol>
<h3 id="接口的静态方法和默认方法"><a href="#接口的静态方法和默认方法" class="headerlink" title="接口的静态方法和默认方法"></a>接口的静态方法和默认方法</h3><p><em>Function</em>是一个接口，那么<code>Function.identity()</code>是什么意思呢？这要从两方面解释：</p>
<ol>
<li>Java 8 允许在接口中加入具体方法。接口中的具体方法有两种，<em>default</em>方法和<em>static</em>方法，<code>identity()</code>就是<em>Function</em>接口的一个静态方法。</li>
<li><code>Function.identity()</code>返回一个输出跟输入一样的 Lambda 表达式对象，等价于形如<code>t -&gt; t</code>形式的 Lambda 表达式。</li>
</ol>
<p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得<code>t -&gt; t</code>比<code>identity()</code>方法更直观。我会告诉你接口中的<em>default</em>方法是一个无奈之举，在 Java 7 及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在<em>Collection</em>接口中加入一个<code>stream()</code>抽象方法会怎样？<em>default</em>方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了<em>default</em>方法，为何不再加入<em>static</em>方法来避免专门的工具类呢！</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>诸如<code>String::length</code>的语法形式叫做方法引用（_method references_），这种语法用来替代某些特定形式 Lambda 表达式。如果 Lambda 表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代 Lambda 表达式。方法引用可以细分为四类：</p>
<table>
<thead>
<tr>
<th align="left">方法引用类别</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">引用静态方法</td>
<td align="left"><code>Integer::sum</code></td>
</tr>
<tr>
<td align="left">引用某个对象的方法</td>
<td align="left"><code>list::add</code></td>
</tr>
<tr>
<td align="left">引用某个类的方法</td>
<td align="left"><code>String::length</code></td>
</tr>
<tr>
<td align="left">引用构造方法</td>
<td align="left"><code>HashMap::new</code></td>
</tr>
</tbody></table>
<p>我们会在后面的例子中使用方法引用。</p>
<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>相信前面繁琐的内容已彻底打消了你学习 Java 函数式编程的热情，不过很遗憾，下面的内容更繁琐。但这不能怪 Stream 类库，因为要实现的功能本身很复杂。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.collect_parameter.png"></p>
<p>收集器（_Collector_）是为<code>Stream.collect()</code>方法量身打造的工具接口（类）。考虑一下将一个<em>Stream</em>转换成一个容器（或者<em>Map</em>）需要做哪些工作？我们至少需要两样东西：</p>
<ol>
<li>目标容器是什么？是<em>ArrayList</em>还是<em>HashSet</em>，或者是个<em>TreeMap</em>。</li>
<li>新元素如何添加到容器中？是<code>List.add()</code>还是<code>Map.put()</code>。</li>
</ol>
<p>如果并行的进行规约，还需要告诉<em>collect()</em> 3. 多个部分结果如何合并成一个。</p>
<p>结合以上分析，<em>collect()<em>方法定义为<code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>，三个参数依次对应上述三条分析。不过每次调用</em>collect()<em>都要传入这三个参数太麻烦，收集器</em>Collector</em>就是对这三个参数的简单封装,所以<em>collect()<em>的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。</em>Collectors</em>工具类可通过静态方法生成各种常用的<em>Collector</em>。举例来说，如果要将<em>Stream</em>规约成<em>List</em>可以通过如下两种方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>通常情况下我们不需要手动指定<em>collect()<em>的三个参数，而是调用<code>collect(Collector&lt;? super T,A,R&gt; collector)</code>方法，并且参数中的</em>Collector</em>对象大都是直接通过<em>Collectors</em>工具类获得。实际上传入的<strong>收集器的行为决定了<code>collect()</code>的行为</strong>。</p>
<h3 id="使用-collect-生成-Collection"><a href="#使用-collect-生成-Collection" class="headerlink" title="使用 collect()生成 Collection"></a>使用 collect()生成 Collection</h3><p>前面已经提到通过<code>collect()</code>方法将<em>Stream</em>转换成容器的方法，这里再汇总一下。将<em>Stream</em>转换成<em>List</em>或<em>Set</em>是比较常见的操作，所以<em>Collectors</em>工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成List或Set</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br></pre></td></tr></table></figure>

<p>上述代码(3)处指定规约结果是<em>ArrayList</em>，而(4)处指定规约结果为<em>HashSet</em>。一切如你所愿。</p>
<h3 id="使用-collect-生成-Map"><a href="#使用-collect-生成-Map" class="headerlink" title="使用 collect()生成 Map"></a>使用 collect()生成 Map</h3><p>前面已经说过<em>Stream</em>背后依赖于某种数据源，数据源可以是数组、容器等，但不能是<em>Map</em>。反过来从<em>Stream</em>生成<em>Map</em>是可以的，但我们要想清楚<em>Map</em>的<em>key</em>和<em>value</em>分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下<code>collect()</code>的结果会是<em>Map</em>：</p>
<ol>
<li>使用<code>Collectors.toMap()</code>生成的收集器，用户需要指定如何生成<em>Map</em>的<em>key</em>和<em>value</em>。</li>
<li>使用<code>Collectors.partitioningBy()</code>生成的收集器，对元素进行二分区操作时用到。</li>
<li>使用<code>Collectors.groupingBy()</code>生成的收集器，对元素做<em>group</em>操作时用到。</li>
</ol>
<p>情况 1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，前面例子中已提到，这是和<code>Collectors.toCollection()</code>并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的<em>Map</em>。非常直观，无需多言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toMap()统计学生GPA</span></span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Function.identity(),<span class="comment">// 如何生成key</span></span><br><span class="line">                                     student -&gt; computeGPA(student)));<span class="comment">// 如何生成value</span></span><br></pre></td></tr></table></figure>

<p>情况 2：使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将<code>Stream</code>中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partition students into passing and failing</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>

<p>情况 3：使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟 SQL 中的<em>group by</em>语句类似，这里的<em>groupingBy()<em>也是按照某个属性对数据进行分组，属性相同的元素会被对应到</em>Map</em>的同一个<em>key</em>上。下列代码展示将员工按照部门进行分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group employees by department</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure>

<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在 SQL 中使用<em>group by</em>是为了协助其他查询，比如<em>1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数</em>。Java 类库设计者也考虑到了这种情况，增强版的<code>groupingBy()</code>能够满足这种需求。增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器</strong>(<em>downstream Collector</em>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下游收集器统计每个部门的人数</span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));<span class="comment">// 下游收集器</span></span><br></pre></td></tr></table></figure>

<p>上面代码的逻辑是不是越看越像 SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果<em>我们想得到每个员工的名字（字符串），而不是一个个</em>Employee<em>对象</em>，可通过如下方式做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照部门对员工分布组，并只保留员工的名字</span></span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,<span class="comment">// 下游收集器</span></span><br><span class="line">                                Collectors.toList())));<span class="comment">// 更下游的收集器</span></span><br></pre></td></tr></table></figure>

<p>如果看到这里你还没有对 Java 函数式编程失去信心，恭喜你，你已经顺利成为 Java 函数式编程大师了。</p>
<h3 id="使用-collect-做字符串-join"><a href="#使用-collect-做字符串-join" class="headerlink" title="使用 collect()做字符串 join"></a>使用 collect()做字符串 join</h3><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用<code>Collectors.joining()</code>生成的收集器，从此告别<em>for</em>循环。<code>Collectors.joining()</code>方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Collectors.joining()拼接字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining());// &quot;Iloveyou&quot;</span></span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining(&quot;,&quot;));// &quot;I,love,you&quot;</span></span><br><span class="line">String joined = stream.collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));<span class="comment">// &quot;&#123;I,love,you&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="collect-还可以做更多"><a href="#collect-还可以做更多" class="headerlink" title="collect()还可以做更多"></a>collect()还可以做更多</h3><p>除了可以使用<em>Collectors</em>工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用<code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>方法，<strong>收集任何形式你想要的信息</strong>。不过<em>Collectors</em>工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。</p>
<h2 id="Stream-Pipelines"><a href="#Stream-Pipelines" class="headerlink" title="Stream Pipelines"></a>Stream Pipelines</h2><p>前面我们已经学会如何使用 Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的 API 是如何实现的呢？比如 Pipeline 是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习 Stream 流水线的原理，这是 Stream 实现的关键所在。</p>
<p>首先回顾一下容器执行 Lambda 表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList.forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);<span class="comment">// 回调方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个<em>for</em>循环，在该<em>for</em>循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在 Java GUI 的监听器中广泛使用。Lambda 表达式的作用就是相当于一个回调方法，这很好理解。</p>
<p>Stream API 中大量使用 Lambda 表达式作为回调方法，但这并不是关键。理解 Stream 我们更关心的是另外两个问题：流水线和自动并行。使用 Stream 或许很容易写入如下形式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">        = strings.stream()</span><br><span class="line">              .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">              .mapToInt(String::length)</span><br><span class="line">              .max();</span><br></pre></td></tr></table></figure>

<p>上述代码求出以字母<em>A</em>开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（_Pipeline_）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了 Stream 的所有操作。</p>
<table>
<thead>
<tr>
<th>Stream 操作分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>中间操作(Intermediate operations)</td>
<td>无状态(Stateless)</td>
<td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>
</tr>
<tr>
<td>有状态(Stateful)</td>
<td>distinct() sorted() sorted() limit() skip()</td>
<td></td>
</tr>
<tr>
<td>结束操作(Terminal operations)</td>
<td>非短路操作</td>
<td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td>
</tr>
<tr>
<td>短路操作(short-circuiting)</td>
<td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>
<td></td>
</tr>
</tbody></table>
<p>Stream 上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(<em>Stateless</em>)和有状态的(<em>Stateful</em>)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如<em>找到第一个满足条件的元素</em>。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>
<h3 id="一种直白的实现方式"><a href="#一种直白的实现方式" class="headerlink" title="一种直白的实现方式"></a>一种直白的实现方式</h3><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_naive.png"></p>
<p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以<em>A</em>开头的字符串并放到一个列表 list1 中，之后让 list1 传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到 list2 中，最后遍历 list2 找出最大的数字作为最终结果。程序的执行流程如如所示：</p>
<p>这样做实现起来非常简单直观，但有两个明显的弊端：</p>
<ol>
<li>迭代次数多。迭代次数跟函数调用的次数相等。</li>
<li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li>
</ol>
<p>这些弊端使得效率底下，根本无法接受。如果不使用 Stream API 我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;A&quot;</span>))&#123;<span class="comment">// 1. filter(), 保留以A开头的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></span><br><span class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟 Stream API 等价的功能，但问题是 Stream 类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p>
<h3 id="Stream-流水线解决方案"><a href="#Stream-流水线解决方案" class="headerlink" title="Stream 流水线解决方案"></a>Stream 流水线解决方案</h3><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p>
<ol>
<li>用户的操作如何记录？</li>
<li>操作如何叠加？</li>
<li>叠加之后的操作如何执行？</li>
<li>执行后的结果（如果有）在哪里？</li>
</ol>
<h4 id="操作如何记录？"><a href="#操作如何记录？" class="headerlink" title="操作如何记录？"></a>操作如何记录？</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Java_stream_pipeline_classes.png"></p>
<p>注意这里使用的是“_操作(operation)_”一词，指的是“Stream 中间操作”的操作，很多 Stream 操作会需要一个回调函数（Lambda 表达式），因此一个完整的操作是&lt;_数据来源，操作，回调函数_&gt;构成的三元组。Stream 中使用 Stage 的概念来描述一个完整的操作，并用某种实例化后的<em>PipelineHelper</em>来代表 Stage，将具有先后顺序的各个 Stage 连到一起，就构成了整个流水线。跟 Stream 相关类和接口的继承关系图示。</p>
<p>还有<em>IntPipeline, LongPipeline, DoublePipeline</em>没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟<em>ReferencePipeline</em>是并列关系。图中<em>Head</em>用于表示第一个 Stage，即调用调用诸如<em>Collection.stream()<em>方法产生的 Stage，很显然这个 Stage 里不包含任何操作；</em>StatelessOp</em>和<em>StatefulOp</em>分别表示无状态和有状态的 Stage，对应于无状态和有状态的中间操作。</p>
<p>Stream 流水线组织结构示意图如下：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_example.png"></p>
<p>图中通过<code>Collection.stream()</code>方法得到<em>Head</em>也就是 stage0，紧接着调用一系列的中间操作，不断产生新的 Stream。<strong>这些 Stream 对象以双向链表的形式组织在一起，构成整个流水线，由于每个 Stage 都记录了前一个 Stage 和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作</strong>。这就是 Stream 记录操作的方式。</p>
<h4 id="操作如何叠加？"><a href="#操作如何叠加？" class="headerlink" title="操作如何叠加？"></a>操作如何叠加？</h4><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的 head 开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的 Stage 并不知道后面 Stage 到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前 Stage 本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻 Stage 之间的调用关系。</p>
<p>这种协议由<em>Sink</em>接口完成，<em>Sink</em>接口包含的方法如下表所示：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void begin(long size)</td>
<td>开始遍历元素之前调用该方法，通知 Sink 做好准备。</td>
</tr>
<tr>
<td>void end()</td>
<td>所有元素遍历完成之后调用，通知 Sink 没有更多的元素了。</td>
</tr>
<tr>
<td>boolean cancellationRequested()</td>
<td>是否可以结束操作，可以让短路操作尽早结束。</td>
</tr>
<tr>
<td>void accept(T t)</td>
<td>遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage 把自己包含的操作和回调方法封装到该方法里，前一个 Stage 只需要调用当前 Stage.accept(T t)方法就行了。</td>
</tr>
</tbody></table>
<p>有了上面的协议，相邻 Stage 之间调用就很方便了，每个 Stage 都会将自己的操作封装到一个 Sink 里，前一个 Stage 只需调用后一个 Stage 的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink 的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如 Stream.sorted()是一个有状态的中间操作，其对应的 Sink.begin()方法可能创建一个盛放结果的容器，而 accept()方法负责将元素添加到该容器，最后 end()负责对容器进行排序。对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如 Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回<em>true</em>，以便调用者尽快结束查找。Sink 的四个接口方法常常相互协作，共同完成计算任务。<strong>实际上 Stream API 内部实现的的本质，就是如何重载 Sink 的这四个接口方法</strong>。</p>
<p>有了 Sink 对操作的包装，Stage 之间的调用问题就解决了，执行时只需要从流水线的 head 开始对数据源依次调用每个 Stage 对应的 Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的 Sink.accept()方法流程是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span> 使用当前Sink包装的回调函数处理u</span><br><span class="line">    <span class="number">2.</span> 将处理结果传递给流水线下游的Sink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sink 接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看 Stream 的中间操作是如何将自身的操作包装成 Sink 以及 Sink 是如何将处理结果转发给下一个 Sink 的。先看 Stream.map()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    R r = mapper.apply(u);<span class="comment">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class="line">                    downstream.accept(r);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<em>mapper</em>包装到一个 Sink 当中。由于 Stream.map()是一个无状态的中间操作，所以 map()方法返回了一个 StatelessOp 内部类对象（一个新的 Stream），调用这个新 Stream 的 opWripSink()方法将得到一个包装了当前回调函数的 Sink。</p>
<p>再来看一个复杂一点的例子。Stream.sorted()方法将对 Stream 中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成 Sink 的呢？sorted()一种可能封装的 Sink 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.sort()方法用到的Sink实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;<span class="comment">// 存放用于排序的元素</span></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(downstream, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建一个存放排序元素的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.sort(comparator);<span class="comment">// 只有元素全部接收之后才能开始排序</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;<span class="comment">// 下游Sink不包含短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 下游Sink包含短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;<span class="comment">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);<span class="comment">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码完美的展现了 Sink 的四个接口方法是如何协同工作的：</p>
<ol>
<li>首先 beging()方法告诉 Sink 参与排序的元素个数，方便确定中间结果容器的的大小；</li>
<li>之后通过 accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li>
<li>最后 end()方法告诉 Sink 所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的 Sink；</li>
<li>如果下游的 Sink 是短路操作，将结果传递给下游时不断询问下游 cancellationRequested()是否可以结束处理。</li>
</ol>
<h4 id="叠加之后的操作如何执行？"><a href="#叠加之后的操作如何执行？" class="headerlink" title="叠加之后的操作如何执行？"></a>叠加之后的操作如何执行？</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_Sink.png"></p>
<p>Sink 完美封装了 Stream 每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</p>
<p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的 Sink，这也是流水线中最后一个 Sink，这个 Sink 只需要处理数据而不需要将结果传递给下游的 Sink（因为没有下游）。对于 Sink 的[处理-&gt;转发]模型，结束操作的 Sink 就是调用链的出口。</p>
<p>我们再来考察一下上游的 Sink 是如何找到下游 Sink 的。一种可选的方案是在<em>PipelineHelper</em>中设置一个 Sink 字段，在流水线中找到下游 Stage 并访问 Sink 字段即可。但 Stream 类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到 Sink，该方法的作用是返回一个新的包含了当前 Stage 代表的操作以及能够将结果传递给 downstream 的 Sink 对象。为什么要产生一个新对象而不是返回一个 Sink 字段？这是因为使用 opWrapSink()可以将当前操作与下游 Sink（上文中的 downstream 参数）结合成新 Sink。试想只要从流水线的最后一个 Stage 开始，不断调用上一个 Stage 的 opWrapSink()方法直到最开始（不包括 stage0，因为 stage0 代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的 Sink，用代码表示就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.wrapSink()</span></span><br><span class="line"><span class="comment">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class="line"><span class="comment">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在流水线上从开始到结束的所有的操作都被包装到了一个 Sink 里，执行这个 Sink 就相当于执行整个流水线，执行 Sink 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class="comment">// 通知开始遍历</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);<span class="comment">// 迭代</span></span><br><span class="line">        wrappedSink.end();<span class="comment">// 通知遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先调用 wrappedSink.begin()方法告诉 Sink 数据即将到来，然后调用 spliterator.forEachRemaining()方法对数据进行迭代（Spliterator 是容器的一种迭代器，<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda%20and%20Collections.md#spliterator">参阅</a>），最后调用 wrappedSink.end()方法通知 Sink 数据处理结束。逻辑如此清晰。</p>
<h4 id="执行后的结果在哪里？"><a href="#执行后的结果在哪里？" class="headerlink" title="执行后的结果在哪里？"></a>执行后的结果在哪里？</h4><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的 Stream 结束操作都需要返回结果，有些操作只是为了使用其副作用(<em>Side-effects</em>)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p>
<blockquote>
<p>特别说明：副作用不应该被滥用，也许你会觉得在 Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为 Stream 可能会并行执行。大多数使用副作用的地方都可以使用<strong>归约操作</strong>更安全和有效的完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的收集方式</span></span><br><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"><span class="comment">// 正确的收集方式</span></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">             .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure>

<p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的 Stream 结束操作。</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>对应的结束操作</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>anyMatch() allMatch() noneMatch()</td>
</tr>
<tr>
<td>Optional</td>
<td>findFirst() findAny()</td>
</tr>
<tr>
<td>归约结果</td>
<td>reduce() collect()</td>
</tr>
<tr>
<td>数组</td>
<td>toArray()</td>
</tr>
</tbody></table>
<ol>
<li>对于表中返回 boolean 或者 Optional 的操作（Optional 是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 Sink 中记录这个值，等到执行结束时返回就可以了。</li>
<li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过<strong>收集器</strong>指定）。collect(), reduce(), max(), min()都是归约操作，虽然 max()和 min()也是返回一个 Optional，但事实上底层是通过调用<code>reduce()</code>方法实现的。</li>
<li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做<em>Node</em>的数据结构中的。Node 是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于 Node 的具体结构，我们会在下一节探究 Stream 如何并行执行时给出详细说明。</li>
</ol>
<p>本文详细介绍了 Stream 流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的 Stream 代码，同时打消你对 Stream API 效率方面的顾虑。如你所见，Stream API 实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。</p>
<p>注：留下本文所用的 JDK 版本，以便有考究癖的人考证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_101&quot;</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_101</span>-b13)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> Server <span class="title">VM</span> <span class="params">(build <span class="number">25.101</span>-b13, mixed mode)</span></span></span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://github.com/CarpenterLee/JavaLambdaInternals">https://github.com/CarpenterLee/JavaLambdaInternals</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/post/7273cdc/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/Apache_Maven">Apache Maven</a> 是一个<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>（特别是<a href="https://zh.wikipedia.org/wiki/Java_(%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)">Java</a>软件）<a href="https://zh.wikipedia.org/wiki/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">项目管理</a>及<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA">自动构建</a>工具，由<a href="https://zh.wikipedia.org/wiki/Apache%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A">Apache软件基金会</a>所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p>
<p><a href="http://maven.apache.org/">Maven官网</a></p>
<span id="more"></span>
<h3 id="软件开发中的阶段"><a href="#软件开发中的阶段" class="headerlink" title="软件开发中的阶段"></a>软件开发中的阶段</h3><p>需要分析： <strong>分析项目具体完成的功能</strong>，有什么要求， 具体怎么实现。</p>
<p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p>
<p>开发阶段：编码实现功能。 编译代码。自我测试。</p>
<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p>
<p>项目的打包，发布阶段： 给用户安装项目。</p>
<p><strong>传统项目开发存在的问题</strong></p>
<p>一个项目做成一个工程，造成工程比较庞大，需要使用<strong>多模块</strong>来划分项目；</p>
<p>项目中需要的数量众多的 jar 包，需要手动下载并引入，并且多个项目需要的 jar 包存在重复的问题；</p>
<p>项目中需要的 jar 包有版本兼容的问题，需要手动解决；</p>
<p>项目中需要的 jar 包又依赖其它的 jar 包，需要手动解决。</p>
<p><strong>Maven 概述</strong></p>
<p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的<strong>项目构建</strong>和<strong>依赖管理</strong>。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或 [‘mevn]。</p>
<blockquote>
<p> 依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>
</blockquote>
<p>Maven 是目前最流行的自动化构建工具，对于生产环境下多框架、多模块整合开发有重要作用，Maven 是一款在大型项目开发过程中不可或缺的重要工具。</p>
<p>Maven 可以<strong>整合多个项目之间的引用关系</strong>，我们可以根据业务和分层需要任意拆分一个项目；</p>
<p>Maven 提供规范的管理各个常用 jar 包及其各个版本，并且可以自动下载和引入项目中；</p>
<p>Maven 可以<strong>根据指定版本自动解决 jar 包版本兼容问题</strong>；</p>
<p>Maven 可以<strong>把 jar 包所依赖的其它 jar 包自动下载并引入项目</strong>。</p>
<p>类似自动化构建工具还有：Ant, Gradle。</p>
<h3 id="项目构建过程"><a href="#项目构建过程" class="headerlink" title="项目构建过程"></a>项目构建过程</h3><p>构建过程中的各个环节：清理、编译、测试、报告、打包、安装、部署。</p>
<p>构建（build）是面向过程的（从开始到结尾的多个步骤），涉及到多个环节的协同工作。 构建过程的几个主要环节：</p>
<ol>
<li>清理：删除以前的编译结果，为重新编译做好准备。</li>
<li>编译：将Java源程序编译为字节码文件。</li>
<li>测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。</li>
<li>报告：在每一次测试后以标准的格式记录和展示测试结果。</li>
<li>打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应war包。</li>
<li>安装：在Maven环境下特指将打包的结果——jar包或war包安装到本地仓库中。</li>
<li>部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</li>
</ol>
<h3 id="Maven-核心概念"><a href="#Maven-核心概念" class="headerlink" title="Maven 核心概念"></a>Maven 核心概念</h3><p>Maven能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven的九个核心概念入手， 看看Maven是如何实现自动化构建的</p>
<p>①POM    ②约定的目录结构    ③坐标    ④依赖管理    ⑤仓库管理    ⑥生命周期    ⑦插件和目标    ⑧继承    ⑨聚合</p>
<h3 id="安装-Maven-环境"><a href="#安装-Maven-环境" class="headerlink" title="安装 Maven 环境"></a>安装 Maven 环境</h3><p>地址：<a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a> 从中下载  .zip文件。 使用的 apache-maven-3.6.3-bin.zip</p>
<p>安装：</p>
<ol>
<li><p>确保安装了 java 环境：maven 本身就是 java 写的，所以要求必须安装 JDK。 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建 JAVA_HOME，它的值是jdk的安装目录。查看 java 环境变量：<code>echo %JAVA_HOME%</code></p>
</li>
<li><p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 </p>
<blockquote>
<p>目录的路径不要有中文， 不要有空格。</p>
</blockquote>
</li>
<li><p>配置 Maven 的环境变量：</p>
<p>MAVEN_HOME=d:/apache-maven-3.6.3 或者 M2_HOME=d:/apache-maven-3.6.3</p>
<p>path=%MAVEN_HOME%/bin; 或者 %M2_HOME%/bin;</p>
</li>
<li><p>验证是否安装成功：<code>mvn –v</code></p>
</li>
</ol>
<p>maven解压后的目录结构：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218182305972.png" style="zoom:80%;" />

<ul>
<li>bin：maven可执行命令</li>
<li>conf：maven工具自己的配置文件</li>
</ul>
<h2 id="Maven-的核心概念"><a href="#Maven-的核心概念" class="headerlink" title="Maven 的核心概念"></a>Maven 的核心概念</h2><h3 id="Maven-工程约定目录结构"><a href="#Maven-工程约定目录结构" class="headerlink" title="Maven 工程约定目录结构"></a>Maven 工程约定目录结构</h3><p>maven 中约定的目录结构：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hello		项目文件夹</span><br><span class="line">|---src</span><br><span class="line">|---|---main				主程序目录（完成项目功能的代码和配置文件）</span><br><span class="line">|---|---|---java			源代码（包和相关的类定义）</span><br><span class="line">|---|---|---resources		主程序的配置文件</span><br><span class="line">|---|---test				放置测试程序代码的（开发人员自己写的测试代码）</span><br><span class="line">|---|---|---java			测试代码的（junit）</span><br><span class="line">|---|---|---resources		测试程序需要的配置文件</span><br><span class="line">|---pom.xml					Maven 工程的核心配置文件</span><br></pre></td></tr></table></figure>

<p>一般情况下，我们习惯上采取的措施是：<strong>约定 &gt; 配置 &gt; 编码</strong></p>
<p>maven 的 pom.xml 记录的关于构建项目的各个方面的设置，maven 从 pom.xml 文件开始，按照助约定的工程目录编译，测试，打包，部署，发布项目。</p>
<h4 id="第一个-maven-工程"><a href="#第一个-maven-工程" class="headerlink" title="第一个 maven 工程"></a>第一个 maven 工程</h4><p>按照如下步骤，实现第一个 maven 项目，以 maven 推荐的约定方式创建目录，类文件。</p>
<ol>
<li><p>某个目录中创建文件夹 Hello</p>
</li>
<li><p>在 Hello 中创建子目录 src</p>
</li>
<li><p>拷贝 pom.xml 到 Hello 目录和 src 是同级放置的。</p>
</li>
<li><p>进入 src 目录，创建 main， test 目录</p>
</li>
<li><p>进入 main 目录，创建 java，resources 目录。</p>
</li>
<li><p>进入 java 目录，创建目录 com/feyl/</p>
</li>
<li><p>在 com/feyl/目录下创建 HelloMaven.java 文件，定义 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addNumber</span><span class="params">(<span class="keyword">int</span> n1,n2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">    System.out.prinltn(“Hello  Maven”); <span class="comment">//也可以调用 addNumber()方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入到 Hello 目录，执行 mvn compile</p>
</li>
<li><p>进入到 target/classes 目录，执行 java com.feyl.HelloMaven</p>
</li>
</ol>
<h3 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h3><p>即 Project Object Model 项目对象模型。Maven 把一个项目的结构和内容抽象成一个模型，在 xml 文件中进行声明，以方便进行构建和描述， pom.xml 是 Maven 的灵魂。所以，maven 环境搭建好之后，所有的学习和操作都是关于 pom.xml 的。</p>
<p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- project是根标签， 后面的是约束文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- pom模型的版本， 就是4.0.0 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">&lt;!-- 坐标 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.feyl.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>pom.xml 初识：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218102309198.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218102603084.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218102755092.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218103003790.png" style="zoom:80%;" />

<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h4 id="仓库的概念"><a href="#仓库的概念" class="headerlink" title="仓库的概念"></a>仓库的概念</h4><p>在Maven中，任何一个<strong>依赖</strong>、<strong>插件</strong>或者<strong>项目构建的输出</strong>，都可以称之为<strong>构件</strong>。Maven<strong>核心程序仅仅定义了自动化构建项目的生命周期</strong>，但具体的构建工作是由特定的构件完成的。而且为了<strong>提高构建的效率和构件复用</strong>，maven把所有的构件统一存储在某一个位置，这个位置就叫做<strong>仓库</strong>。</p>
<h4 id="仓库存什么？"><a href="#仓库存什么？" class="headerlink" title="仓库存什么？"></a>仓库存什么？</h4><p>仓库是存放东西的，Maven 仓库的是：</p>
<ol>
<li>Maven 的插件，插件也是一些 jar，这些 jar 可以完成一定的功能。</li>
<li>自己写的程序，可以打包为jar 。 存放到仓库。</li>
<li>第三方框架或工具的 jar 包。</li>
</ol>
<h4 id="仓库的类别"><a href="#仓库的类别" class="headerlink" title="仓库的类别"></a>仓库的类别</h4><p>根据仓库存储的位置，把仓库分为本地仓库和远程仓库。</p>
<p><strong>本地仓库</strong>，存在于当前电脑上，默认存放在 ~.m2\repository 中,为本机上 所有的Maven工程服务。你也可以通过Maven的配置文件 Maven_home/conf/settings.xml 中修改本地仓库所在的目录。 ~ 是用户的主目录，windows系统中是 c：/user/登录系统的用户名</p>
<blockquote>
<p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\conf\setting.xml）</p>
<p>步骤：</p>
<ol>
<li><p>创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p>
<p>例如： D:\MavenRepository</p>
</li>
<li><p>修改setting.xml文件，指定 D:\MavenRepository这个目录</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/MavenRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>远程仓库</strong>，分为为全世界范围内的开发人员提供服务的<strong>中央仓库</strong>、为全世界范围内某些特定的用户提供服务的中央仓库镜像、为本公司提供服务自己架设 的<strong>私服</strong>。中央仓库是maven默认的远程仓库，其地址是：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<ul>
<li>中央仓库（ftp服务器），包含了绝大多数流行的开源Java构件，以及源码、作者信息、 许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载得到。</li>
<li>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载， 缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法 从外部仓库下载到的构件上传到私服上。</li>
</ul>
<p>分类说明：</p>
<ol>
<li><p>本地仓库：本机当前电脑上的资源存储位置，为本机上所有 Maven工程提供服务</p>
</li>
<li><p>远程仓库：不在本机上， 通过网络才能使用。多电脑共享使用的。</p>
<p>中央仓库：通过Internet访问，为全世界所有 Maven工程服务。 最权威的。</p>
<p>中央仓库的<strong>镜像</strong>：架设在不同位置，欧洲，美洲，亚洲等每个洲都有若干的服务器，为中央仓库<strong>分担流量</strong>。减轻中央仓库的访问，下载的压力。所在洲的用户首先访问的是本洲的镜像服务器。</p>
<p>私服：在局域网环境中部署的服务器，为当前局域网范围内的所有 Maven工程服务。公司中常使用这种方式。</p>
</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218104656730.png" style="zoom:80%;" />

<h4 id="Maven-对仓库的使用"><a href="#Maven-对仓库的使用" class="headerlink" title="Maven 对仓库的使用"></a>Maven 对仓库的使用</h4><p>在 Maven 构建项目的过程中如果需要某些插件，首先会到 Maven 的本地仓库中查找，如果找到则可以直接使用；如果找不到，它会自动连接外网，到<a href="https://mvnrepository.com/">远程中央仓库</a>中查找；如果远程仓库中能找到，则先把所需要的插件下载到本地仓库，然后再使用，并且下次再用到相同的插件也可以直接使用本地仓库的；如果没有外网或者远程仓库中也找不到，则构建失败。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218184005992.png" style="zoom:80%;" />

<h3 id="Maven-的生命周期"><a href="#Maven-的生命周期" class="headerlink" title="Maven 的生命周期"></a>Maven 的生命周期</h3><p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署。</p>
<p>对项目的构建是建立在生命周期模型上的，它明确定义项目生命周期各个阶段，并且对于每一个阶段提供相对应的命令，对开发者而言仅仅需要掌握一小堆的命令就可以完成项目各个阶段的构建工作。 构建项目时按照生命周期顺序构建，每一个阶段都有特定的插件来完成。 不论现在要执行生命周期中的哪个阶段，都是从这个生命周期的最初阶段开始的。</p>
<p>对于我们程序员而言，无论我们要进行哪个阶段的构建，直接执行相应的命令即可，无需担心它前边阶段是否构建，Maven 都会自动构建。这也就是 Maven 这种自动化构建工具给我们带来的好处。</p>
<h3 id="Maven-的常用命令"><a href="#Maven-的常用命令" class="headerlink" title="Maven 的常用命令"></a>Maven 的常用命令</h3><p>Maven 对所有的功能都提供相对应的命令，要想知道 maven 都有哪些命令，那要看 maven 有哪些功能。一开始就跟大家说了，maven 三大功能：<strong>管理依赖</strong>、<strong>构建项目</strong>、<strong>管理项目信息</strong>。管理依赖，只需要声明就可以自动到仓库下载；管理项目信息其实就是生成一个站点文档，一个命令就可以解决，最后再说；那 maven 功能的主体其实就是项目构建。</p>
<p>Maven 提供一个项目构建的模型，把编译、测试、打包、部署等都对 应成一个个的生命周期阶段，并对每一个阶段提供相应的命令，程序员只需要 掌握一小堆命令，就可以完成项目的构建过程。</p>
<ol>
<li><p><code>mvn clean</code>：清理命令，会删除原来编译和测试的目录，即 target 目录，但是已经 install 到仓库里的包不会删除。</p>
</li>
<li><p><code>mvn compile</code>：编译主程序命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>
</li>
<li><p><code>mvn test-compile</code>：， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p>
<p>插件： maven-compiler-plugin 版本3.1。  编译代码的插件。</p>
<p>​            maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的文件拷贝target/classes目录中。</p>
</li>
<li><p><code>mvn test</code>：测试命令，作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求（会生成一个目录surefire-reports，保存测试结果）。</p>
<p>插件： maven-surefire-plugin 版本 2.12.4</p>
</li>
<li><p><code>mvn package</code>：打包主程序，会编译、编译测试、测试、并且按照 pom.xml 配置把项目中的资源class文件和配置文件都放到一个压缩文件中，默认压缩文件是jar类型的。 web应用是war类型。</p>
<p> 插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下。打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p>
<p>打包的文件名： <strong>artifactId-version.packaging</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.feyl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">打包的文件名：mall-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></li>
<li><p><code>mvn install</code>：安装主程序，把本工程打包，并且按照本工程的坐标保存到本地仓库中。</p>
<p>插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 </p>
<p>查看本地仓库中的jar文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.feyl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">groupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\feyl</span><br><span class="line">artifactId，独立的文件夹</span><br><span class="line">version，独立的文件夹</span><br></pre></td></tr></table></figure></li>
<li><p><code>mvn deploy</code>：部署主程序（会把本工程打包，按照本工程的坐标保存到本地库中，并且还会保存到私服仓库中。还会自动把项目部署到 web 容器中）</p>
<blockquote>
<p><strong>注意：执行以上命令必须在命令行进入 pom.xml 所在目录</strong></p>
</blockquote>
</li>
</ol>
<h4 id="练习-maven-命令"><a href="#练习-maven-命令" class="headerlink" title="练习 maven 命令"></a>练习 maven 命令</h4><p>以第一个 maven 项目为例，进入到 Hello 目录中执行 maven 各种命令</p>
<p>单元测试（junit）：</p>
<p>junit是一个单元测试的工具， 在java中经常使用。</p>
<p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p>
<p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p>
<p> 单元测试使用的建议：</p>
<p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p>
<p>​    2.测试类它的包名和要测试的类包名一样。</p>
<p>​    3.在类中定义方法，要测试代码。</p>
<p>​       方法的定义：public方法， </p>
<p>​                               没有返回值</p>
<p>​                               方法名称自定义（建议 Test+测试的方法名称）</p>
<p>​                               方法没有参数</p>
<p>使用单元测试：</p>
<ol>
<li><p>准备工作，pom.xml 添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 Hello/src/test/目录下创建 java ， resources 目录</p>
</li>
<li><p>在 Hello/src/test/java 目录下，创建 com/feyl/目录</p>
</li>
<li><p>在 com/feyl/ 目录中创建 MyTest.java 文件</p>
<p>导入类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line">定义方法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;执行 HelloMaven 类 addNumber()方法&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">20</span>;</span><br><span class="line"> 		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"> 		HelloMaven hello =<span class="keyword">new</span> HelloMaven();</span><br><span class="line"> 		res = hello.addNumber(n1,n2);</span><br><span class="line"> 		<span class="comment">// 期望值，实际值</span></span><br><span class="line"> 		Assert.assertEquals(<span class="number">30</span>,res);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行先执行 <code>mvn compile</code>，观察目录结构的变化，生成 target 目录</p>
</li>
<li><p>在执行 <code>mvn clean</code>， 观察 target 目录被清除</p>
</li>
<li><p>执行 <code>mvn compile</code></p>
</li>
<li><p>进入 target/classes 目录执行 <code>java com.feyl.HelloMaven</code></p>
</li>
<li><p>进入 Hello 目录，执行 <code>mvn test-compile</code> 生成 test-target 测试编译后的目录</p>
</li>
<li><p>进入 Hello 目录，执行 <code>mvn test</code> 执行 MyTest 类中方法，生成测试报告</p>
</li>
<li><p>进入目录 surefire-reports，查看测试报告</p>
</li>
<li><p>修改 MyTest.java，增加测试方法（在方法的上面加入@Test）</p>
<blockquote>
<p>在测试类中的方法，可以单独执行。 测试类也可以单独执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddNumber2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行 HelloMaven 类 addNumber()方法&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	HelloMaven hello =<span class="keyword">new</span> HelloMaven();</span><br><span class="line">	res = hello.addNumber(n1,n2);</span><br><span class="line">	<span class="comment">// 期望值，实际值</span></span><br><span class="line">	Assert.assertEquals(<span class="number">60</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入 Hello 目录，执行 <code>mvn test-compile</code></p>
</li>
<li><p>进入 Hello 目录，执行 <code>mvn test</code></p>
</li>
<li><p>修改 testAddNumber2()方法中 60 为 50</p>
</li>
<li><p>进入 Hello 目录，执行 <code>mvn package</code>，生成 xxx.jar 文件，这就是所说的打包</p>
</li>
<li><p>进入 Hello 目录，执行 <code>mvn install</code>，把 xxx.jar 文件安装到本地 maven 仓库，安装成功后查看仓库中的 jar 文件</p>
</li>
</ol>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件plugin 来执行完成的。插件就是jar，一些类。</p>
<p>官网插件说明：<a href="http://maven.apache.org/plugins/">http://maven.apache.org/plugins/</a></p>
<p>在项目根目录下执：<code>mvn clean install</code></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218112635865.png" style="zoom:80%;" />

<p>解释说明：</p>
<p><strong>clean 插件 maven-clean-plugin:2.5</strong>：clean 阶段是独立的一个阶段，功能就是清除工程目前下的 target 目录</p>
<p><strong>resources 插件 maven-resources-plugin:2.6</strong>：resource 插件的功能就是把项目需要的配置文件拷贝到指定的目录，默认是拷贝 src\main\resources 目录下的件到 classes 目录下</p>
<p><strong>compile 插件 maven-compiler-plugin</strong>：compile 插件执行时先调用 resouces 插件，功能就是把 src\main\java 源码编译成字节码生 成 class 文件，并把编译好的 class 文件输出到 target\classes 目录下</p>
<p><strong>test 测试插件</strong>：单元测试所用的 compile 和 resources 插件和主代码是相同的，但执行的目标不行，目标 testCompile 和 testResources 是把 src\test\java 下的代码编译成字节码输出到 target\test\classes，同时把 src\test\resources 下的配置文件拷贝到 target\test-classes</p>
<p><strong>package 打包插件 maven-jar-plugin</strong>：这个插件是把 class 文件、配置文件打成一个 jar(war 或其它格式)包</p>
<p><strong>deploy 发布插件 maven-install-plugin</strong>：发布插件的功能就是把构建好的 artifact 部署到本地仓库，还有一个 deploy 插件是将构建好的 artifact 部署到远程仓库</p>
<p><strong>常用插件</strong></p>
<p>插件可以在自己的项目中设置，最常使用的是 maven 编译插件。设置项目使用的 jdk 版本 时通过编译插件指定。pom.xml 文件中设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置构建项目相关的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 设置插件 --&gt;</span></span><br><span class="line">	 	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line"> 			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> 			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> 			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> 			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line"> 				<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> <span class="comment">&lt;!-- 指定编译代码的jdk版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span> <span class="comment">&lt;!-- 运行java程序使用的jdk版本--&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="坐标-gav"><a href="#坐标-gav" class="headerlink" title="坐标 (gav)"></a>坐标 (gav)</h3><p>Maven 把任何一个插件都作为仓库中的一个项目进行管理，用一组（三个）向量组成的坐标来表示。坐标在仓库中可以唯一定位一个 Maven 项目。 坐标概念来自数学。</p>
<ul>
<li><p>groupId：组织名，通常是公司或组织域名倒序+项目名</p>
<blockquote>
<p>组织名称，代码。 公司，团体或者单位的标识。</p>
</blockquote>
</li>
<li><p>artifactId：模块名，通常是工程名</p>
<blockquote>
<p>项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。</p>
</blockquote>
</li>
<li><p>version：版本号</p>
<blockquote>
<p>版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。<br>注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。 </p>
</blockquote>
</li>
</ul>
<p>需要特别指出的是，项目在仓库中的位置是由坐标来决定的：groupId、 artifactId 和 version 决定项目在仓库中的路径，artifactId 和 version 决定 jar 包的名称。</p>
<p>项目使用gav：</p>
<p>1.每个maven项目，都需要有一个自己的gav</p>
<p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p>
<p>搜索坐标的地址： <a href="https://mvnrepository.com/">Maven中央仓库</a></p>
<h3 id="依赖-dependency"><a href="#依赖-dependency" class="headerlink" title="依赖 (dependency)"></a>依赖 (dependency)</h3><p>依赖：项目中要使用的其他资源（jar）。  </p>
<p>一个 Maven 项目正常运行需要其它项目的支持，Maven 会根据坐标自动到本地仓库中进行查找。对于程序员自己的 Maven 项目需要进行安装，才能保存到仓库中。</p>
<p>不用 maven 的时候所有的 jar 都不是你的，需要去各个地方下载拷贝，用了 maven 所有的 jar 包都是你的，想要谁，叫谁的名字就行。maven 帮你下载。</p>
<p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用；需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p>
<p>pom.xml 加入依赖的方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- log4j 日志依赖 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- junit 单元测试依赖 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>maven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar。</p>
<h2 id="Maven-在-IDEA-中的应用"><a href="#Maven-在-IDEA-中的应用" class="headerlink" title="Maven 在 IDEA 中的应用"></a>Maven 在 IDEA 中的应用</h2><h3 id="IDEA-集成-Maven"><a href="#IDEA-集成-Maven" class="headerlink" title="IDEA 集成 Maven"></a>IDEA 集成 Maven</h3><p><strong>File -&gt; Settings</strong>：设置 maven 安装主目录、maven 的 settings.xml 文件和本地仓库所在位置。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218113933955.png" style="zoom: 75%;" />

<ul>
<li>Maven home path：maven的安装目录</li>
<li>User setting file：maven工具本身的配置文件位置，maven的安装目录\conf\setting.xml。</li>
<li>Local repository：IDEA 读取setting.xml文件的内容，获取本地仓库的位置。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218201506616.png" style="zoom:75%;" />

<ul>
<li>VM Options：maven创建项目时，会从网络中下载一个 <strong>archetype -catalog.xml</strong> 作为项目的模版文件，文件有8M左右。<br><code>archetypeCatalog=internal</code> 表示不用下载文件。加快创建maven项目的速度。</li>
<li>JRE：jdk信息。</li>
</ul>
<p><strong>File - Other Settings</strong>：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218201907294.png"></p>
<p>同上的设置</p>
<h3 id="IDEA-创建-Maven-版-java-工程"><a href="#IDEA-创建-Maven-版-java-工程" class="headerlink" title="IDEA 创建 Maven 版 java 工程"></a>IDEA 创建 Maven 版 java 工程</h3><h4 id="创建-maven-版-java-工程"><a href="#创建-maven-版-java-工程" class="headerlink" title="创建 maven 版 java 工程"></a>创建 maven 版 java 工程</h4><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218202309238.png" style="zoom:75%;" />

<p><strong>File -&gt; New -&gt; Module…</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218114445602.png" style="zoom:75%;" />

<p><strong>填写 maven 工程的名称、存储路径和坐标</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218114629382.png" style="zoom:75%;" />

<p><strong>pom.xml 加入依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>创建后视图</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218115325918.png" style="zoom:75%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218115752572.png" style="zoom:75%;" />

<p> <strong>创建测试类</strong>：输出一条语句，测试项目构建成功。</p>
<h3 id="IDEA-创建-Maven-版-web-工程"><a href="#IDEA-创建-Maven-版-web-工程" class="headerlink" title="IDEA 创建 Maven 版 web 工程"></a>IDEA 创建 Maven 版 web 工程</h3><p><strong>创建 Maven 版 web 工程</strong></p>
<p><strong>File –&gt; New –&gt; Module…</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218124525840.png" style="zoom:75%;" />

<p><strong>填写 maven 工程的名称、存储路径和坐标</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218114629382.png" style="zoom:75%;" />

<p><strong>填写（确定）module Maven的相关设置（Maven的安装主目录、配置文件位置、本地仓库地址）</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218124924006.png" style="zoom:75%;" />

<p>由于要运行 archetype 程序，所以这个过程需要几分钟的时间，当控 制台出现” BUILD SUCCESS”时，表示工程创建完成。</p>
<p><strong>创建后视图</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218125432359.png" style="zoom:75%;" />

<p>显然，按照 maven archetype 原型创建的 maven web 工程缺少 maven 项目的完整结构：src-main-java / resources，src-test-java/resources，所以需要我们手动添加文件目录</p>
<p><strong>创建缺省文件夹</strong>：</p>
<p>src-main-java / resources，src-test-java/resources</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218125814513.png" style="zoom:75%;" />

<p><strong>把文件夹标识为源码文件夹</strong>：</p>
<p><strong>File -&gt; Project Structure，选择 Modules</strong>：右边找到 java 这层机构， 在上面有个“Mask as”，点下 Sources，表示这里面是源代码类。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218130031015.png" style="zoom:75%;" />

<p><strong>pom.xml 添加依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>创建测试类</strong>：编写测试类 HelloWorld 和测试页面 index.jsp。</p>
<h3 id="IDEA-中导入-Maven-工程-module"><a href="#IDEA-中导入-Maven-工程-module" class="headerlink" title="IDEA 中导入 Maven 工程(module)"></a>IDEA 中导入 Maven 工程(module)</h3><p><strong>新建一个空的 project 作为工作空间</strong></p>
<p>在项目结构中导入或移除 module</p>
<p><strong>File -&gt; Project Structure…</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218131137204.png" style="zoom:75%;" />

<p><strong>选择要导入的 Module</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218133923713.png" style="zoom:75%;" />

<p><strong>选择导入方式</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218131905306.png" style="zoom:75%;" />

<p><strong>导入结果</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218132744358.png" style="zoom:75%;" />

<p> <strong>设置导入 module 所使用的 JDK</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218133024944.png" style="zoom:75%;" />

<p><strong>导入后项目结构</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218134228586.png" style="zoom:75%;" />

<p><strong>导入后视图</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218134747443.png" style="zoom:75%;" />



<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>依赖范围：使用scope表示依赖的范围。 </p>
<p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p>
<p>依赖范围scope ：</p>
<p>​     compile：默认， 参与构建项目的所有阶段</p>
<p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p>
<p>​    provided：提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的 jar包明显的是 servlet 和 jsp 依赖</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218134925870.png" style="zoom:80%;" />



<h2 id="Maven-常用设置"><a href="#Maven-常用设置" class="headerlink" title="Maven 常用设置"></a>Maven 常用设置</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量：在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 使用全局变量表示多个依赖使用的版本号。</p>
<p>在 Maven 的 pom.xml 文件中，用于定义全局变量，POM 中通过 <code>$&#123;property_name&#125;</code> 的形式引用变量的值。</p>
<p><strong>定义全局变量</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>引用全局变量</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>语法 ${变量名}</p>
</blockquote>
<p>Maven 系统采用的变量：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span> <span class="comment">&lt;!-- 源码编译 jdk 版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span> <span class="comment">&lt;!-- 运行代码的 jdk 版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span> <span class="comment">&lt;!-- 项目构建使用的编码，避免中文乱码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span> <span class="comment">&lt;!-- 生成报告的编码 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--自定义变量--&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="指定资源位置"><a href="#指定资源位置" class="headerlink" title="指定资源位置"></a>指定资源位置</h3><p>src/main/java 和 src/test/java 这两个目录中的所有 *.java 文件会分别在 comiple 和 test-comiple 阶段被编译，编译结果分别放到了 target/classes 和 targe/test-classes 目录中，但是这两个目录中的其他文件都会被忽略掉，如果需要把 src 目录下的文件包放到 target/classes 目录，作为输出的 jar 一部分。需要指定资源文件位置。以下内容放到标签中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span> <span class="comment">&lt;!-- 所在的目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span> <span class="comment">&lt;!-- 包括目录下的.properties, .xml 文件都会扫描到 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Maven-管理多模块应用"><a href="#Maven-管理多模块应用" class="headerlink" title="Maven 管理多模块应用"></a>Maven 管理多模块应用</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>commonModel：提供<strong>公共</strong>的<strong>基础服务</strong>，比如<strong>工具类</strong>、<strong>常量类等</strong>等；</p>
<p>bussinessModel：<strong>业务模块</strong>，是系统真正要实现的业务，<strong>依赖于 common 模块</strong>，比如订单管理、财务统计、会员管理等</p>
<p>application：<strong>可发布的 web 应用</strong>，由各个 bussinessModel 组成，最终满足项目整体需求；</p>
<p>第三方模块：包括<strong>各类框架</strong>，Spring、MyBatis、日志等。整个应用都是依赖它们完成开发的；</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218164231830.png" style="zoom:80%;" />

<h3 id="如何使用-Maven-管理以上的结构呢？"><a href="#如何使用-Maven-管理以上的结构呢？" class="headerlink" title="如何使用 Maven 管理以上的结构呢？"></a>如何使用 Maven 管理以上的结构呢？</h3><p>Maven 管理多模块应用的实现是互联网项目中多使用<strong>分布式开发</strong>，那么每个独立的服务都会使用独立的项目进行维护，那么这样就需要使用多模块应用管理，来实现项目的高度统一。</p>
<h4 id="第一种实现方式"><a href="#第一种实现方式" class="headerlink" title="第一种实现方式"></a>第一种实现方式</h4><p>项目名称：gmall</p>
<p>完成功能：使用 IntelliJ IDEA 实现 Maven 管理多模块的应用开发</p>
<h5 id="创建-Project-为-Empty-Project"><a href="#创建-Project-为-Empty-Project" class="headerlink" title="创建 Project 为 Empty Project"></a>创建 Project 为 Empty Project</h5><p>点击“Next”下一步</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218165145874.png" style="zoom:75%;" />

<p><strong>设置项目名称和项目存放位置</strong>：</p>
<p>为新创建的项目设置项目名称和项目位置，然后点击“Finish”</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218165258768.png" style="zoom:75%;" />

<ul>
<li>Project name：项目名称</li>
<li>Project location：项目存放位置</li>
</ul>
<p><strong>“文件夹不存在”提示框</strong>：</p>
<p>提示内容如下： 项目目录“E:\project\gmall”不存在。它将由 Intellij IDEA 创建。 点击“Create”</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218165410869.png" style="zoom:75%;" />

<p><strong>项目结构</strong>：</p>
<p>选择“Cencel”取消</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218165711426.png" style="zoom:50%;" />

<p>Maven 空项目创建成功，如下图</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218165735696.png" style="zoom:50%;" />

<h5 id="创建-Maven-父工程"><a href="#创建-Maven-父工程" class="headerlink" title="创建 Maven 父工程"></a>创建 Maven 父工程</h5><p>创建一个 Module，选择 Maven 工程</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218170004518.png" style="zoom:75%;" />

<p><strong>设置 Module 的 GAV 坐标，模块内容存放位置</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218170356420.png" style="zoom:75%;" />

<ul>
<li>GroupId：公司域名的倒序</li>
<li>ArtifactId：项目或模块名称</li>
<li>Version：项目或模块版本号</li>
<li>location：模块内容存放位置</li>
</ul>
<p><strong>配置导入设置</strong>：</p>
<p>Maven 项目被修改后，需要“手动更新”或“自动更新”，通常选择“Enable Auto-Import”</p>
<p><strong>设置父工程的 pom 文件</strong>：</p>
<p>父工程的 packaging 标签的文本内容必须设置为 pom。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.feyl.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>删除 src 目录</strong>：</p>
<p>父工程要求 src 目录必须删除掉。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218170812681.png" style="zoom:75%;" />

<h5 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h5><p>模块名称：gmall-product，是 gmall-parent 父工程的子模块</p>
<p><strong>创建 module 工程</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218170004518.png" style="zoom:75%;" />

<p><strong>设置 module 项目基础信息</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218171147915.png" style="zoom:75%;" />

<ul>
<li>Parent：选择模块的父工程</li>
<li>Name：module 名称</li>
<li>Location：module 存放的位置</li>
<li>GroupId：选择父工程后，默认继承父工程的</li>
<li>GroupId 值 ArtifactId：模块的项目名称</li>
<li>Version：选择父工程后，默认继承父工程的 Version 值</li>
</ul>
<p><strong>项目视图</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218171602247.png" style="zoom:75%;" />

<p><strong>子模块项目的 pom 文件</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.feyl.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../gmall-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-product<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>parent 标签：指向父工程</li>
<li>relativePath 标签：相对路径</li>
</ul>
<h5 id="设置父工程编译级别"><a href="#设置父工程编译级别" class="headerlink" title="设置父工程编译级别"></a>设置父工程编译级别</h5><p>执行效果： 项目中会统一使用 JDK 版本和编译级别，所以项目的编译级别必须一致，那么将编译插件添加到父工程，子模块依然会无条件去继承父工程的插件。</p>
<p><strong>指定编译级别前</strong>：</p>
<p>在 File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler 查看</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218171917571.png" style="zoom:75%;" />

<p><strong>在父工程的 build -&gt; plugins 标签中添加编译插件</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编译插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的版本 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 编译格式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定编译级别后：</p>
<p>在 File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler 再次查看</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218171917571.png" style="zoom:75%;" />

<h5 id="父工程添加依赖"><a href="#父工程添加依赖" class="headerlink" title="父工程添加依赖"></a>父工程添加依赖</h5><p>执行后效果： 在父工程dependencies标签中添加MySQL依赖，子模块会无条件继承父工程所有依赖。</p>
<p><strong>添加 MySQL 依赖前</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218172618207.png" style="zoom:80%;" />

<p>添加 MySQL 依赖（父工程 pom 文件）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加 MySQL 依赖后</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218173143316.png" style="zoom:80%;" />

<h5 id="父工程管理依赖版本号"><a href="#父工程管理依赖版本号" class="headerlink" title="父工程管理依赖版本号"></a>父工程管理依赖版本号</h5><p>以上写做法，子模块会无条件继承父工程的所有依赖，导致的问题是，本不需要的继承的依赖也会被继承，这就大大增加了项目模块最终打包的大小，也可能未上线埋下了隐患。 </p>
<p>也就是说，父工程管理的是所有项目模块的依赖，而不是某一个项目模块的依赖，所以<strong>某一个项目模块不需要继承父工程中的所有依赖</strong>，这就需要<strong>子项目模块向父工程声明需要的依赖即可</strong>（<strong>声明式依赖</strong>）。而此时，<strong>父工程实际只需要管理依赖的版本号即可</strong>。</p>
<p>实现方式如下：</p>
<p><strong>父工程添加 dependencyManagement 前</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218173143316.png" style="zoom:80%;" />

<p><strong>父工程添加 dependencyManagement 标签管理依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  管理依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>父工程添加 dependencyManagement 后</strong>：</p>
<p>子模块项目之前继承的依赖消失，由于父工程通过 dependencyManagement 标签管理依 赖，那么之前子模块无条件继承的依赖就全部消失。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218172618207.png" style="zoom:80%;" />

<p><strong>父工程添加 properties 管理版本号</strong>：</p>
<p>在 properties 标签中，可以自定义标签名称来管理依赖的版本号，通常自定义的标签名 称由“项目名称”+version 英文单词构成。被管理的依赖版本号由“<code>$&#123;算定标签名称&#125;</code>”来代 替。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  管理依赖的版本号  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  自定义标签  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector-java-version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">mysql-connector-java-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  管理依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>子模块声明式添加依赖</strong>：</p>
<p>由于父工程管理依赖的版本号，那么子模块要想继承依赖，只能通过声明式来添加依赖， 实际上，子模块中的依赖是继承父工程依赖的版本号；如果子模块已定义依赖版本号，那么 以子模块定义的版本号为准。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  实际上继承父工程依赖版本号  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218174450199.png" style="zoom:80%;" />

<h4 id="第二种实现方式"><a href="#第二种实现方式" class="headerlink" title="第二种实现方式"></a>第二种实现方式</h4><p>项目名称：gmall</p>
<p>完成功能：使用 IntelliJ IDEA 实现 Maven 管理多模块的应用开发</p>
<h5 id="创建-Maven-工程"><a href="#创建-Maven-工程" class="headerlink" title="创建 Maven 工程"></a>创建 Maven 工程</h5><p><strong>选择 Maven，点击“Next”下一步</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218170004518.png" style="zoom:75%;" />

<p><strong>设置设置项目名称和项目存放位置和坐标，点击“Finish”完成</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218175334479.png" style="zoom:75%;" />

<p><strong>配置导入设置</strong>：</p>
<p>Maven 项目被修改后，需要“手动更新”或“自动更新”，通常选择“Enable Auto-Import”</p>
<h5 id="将-maven-工程修改为父工程"><a href="#将-maven-工程修改为父工程" class="headerlink" title="将 maven 工程修改为父工程"></a>将 maven 工程修改为父工程</h5><p><strong>设置 packaging 标签的文本内容</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.feyl.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>删除 src 目录</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218175747808.png" style="zoom:75%;" />



<p><strong>父工程添加编译插件</strong>：同第一种实现方式</p>
<h5 id="创建子模块-1"><a href="#创建子模块-1" class="headerlink" title="创建子模块"></a>创建子模块</h5><p>模块名称：maven-child</p>
<p><strong>选择 New Module</strong></p>
<p><strong>选择 maven 项目</strong></p>
<p><strong>设置子模块名称及存放位置和坐标及父工程</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218180051699.png" style="zoom:75%;" />

<ul>
<li>Parent：选择模块的父工程</li>
<li>Name：子模块名称</li>
<li>location：模块内容存放位置</li>
<li>GroupId：公司域名的倒序</li>
<li>ArtifactId：项目或模块名称</li>
<li>Version：项目或模块版本号</li>
</ul>
<h5 id="项目视图"><a href="#项目视图" class="headerlink" title="项目视图"></a>项目视图</h5><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220218180450953.png" style="zoom:80%;" />

<p><strong>父工程 pom 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.feyl.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-child<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  管理依赖的版本号  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 插件的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 编译级别 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 编译格式 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>子工程 pom 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.feyl.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-child<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加依赖、父工程管理依赖版本号等操作</strong> 同第一种实现方式</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="http://www.imooc.com/wiki/mavenlesson/mavenintroduction.html">慕课教程 - Maven入门教程</a></li>
<li><a href="https://www.runoob.com/maven/maven-tutorial.html">菜鸟教程 - Maven 教程</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><strong>动力节点 Maven课程文档</strong></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
        <tag>项目构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC</title>
    <url>/post/eff096d5/</url>
    <content><![CDATA[<h2 id="Spring-IOC是什么？"><a href="#Spring-IOC是什么？" class="headerlink" title="Spring IOC是什么？"></a>Spring IOC是什么？</h2><p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而<strong>IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建</strong>；</p>
<ul>
<li><p><strong>谁控制谁？当然是IoC 容器控制了对象；</strong></p>
</li>
<li><p><strong>控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p>
<span id="more"></span></li>
<li><p><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；</p>
</li>
<li><p><strong>为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；</strong></p>
</li>
<li><p><strong>哪些方面反转了？依赖对象的获取被反转了。</strong></p>
</li>
</ul>
<p>传统程序设计，都是主动去创建相关对象然后再组合起来：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/261421378318292.jpg"></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/M4WDLSB3%5B__W1$PJZ1%60%7DXGF.png"></p>
<p><strong>Spring所倡导的开发方式</strong>：<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p>
<h2 id="IoC能做什么？"><a href="#IoC能做什么？" class="headerlink" title="IoC能做什么？"></a>IoC能做什么？</h2><p>​        <strong>IoC 不是一种技术，只是一种思想</strong>，一个重要的<strong>面向对象编程的法则</strong>，它能指导我们如何设计出<strong>松耦合</strong>、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>​        其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p>
<p>​        <strong>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p>
<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>　<strong>DI—Dependency Injection</strong>，即“依赖注入”：组件之间依赖关系由容器在<strong>运行期决定</strong>，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>DI是如何实现的呢？ Java 1.3之后一个重要特征是<strong>反射（reflection）</strong>，它允许程序<strong>在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的</strong>。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><strong>谁依赖于谁：</strong>当然是<strong>应用程序依赖于IoC容器</strong>；</li>
<li><strong>为什么需要依赖：</strong> <strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</li>
<li><strong>谁注入谁：</strong>很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</li>
<li><strong>注入了什么：</strong>就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</li>
</ul>
<p><strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“</strong> <strong>依赖注入”</strong> <strong>明确描述了“被注入对象依赖IoC</strong> <strong>容器配置依赖对象”。</strong></p>
<h2 id="对IoC-控制反转-和DI-依赖注入-的理解"><a href="#对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="对IoC(控制反转)和DI(依赖注入)的理解"></a>对IoC(控制反转)和DI(依赖注入)的理解</h2><p>​        在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像<code>new object()</code> 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p>
<p>　　所以<strong>控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方</strong>，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p>
<hr>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection </a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a> </p>
</li>
<li><p><a href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析</a></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><strong><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">谈谈对Spring IOC的理解</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>开发框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO</title>
    <url>/post/57ec66b6/</url>
    <content><![CDATA[<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用<strong>虚拟存储器</strong>，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<blockquote>
<p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
</blockquote>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127193145761.png" style="zoom:67%;" />

<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<blockquote>
<p>进程切换需要消耗一定的资源。</p>
</blockquote>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行<strong>阻塞原语(Block)<strong>，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个<strong>用于表述指向文件的引用的抽象化概念</strong>。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>更多内容详见：<a href="https://feyl.github.io/post/1e8930fb/">理解linux中的file descriptor(文件描述符)</a></p>
<h3 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h3><p>缓存 IO 又被称作<strong>标准 IO</strong>，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，<strong>操作系统会将 IO 的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p><strong>缓存 IO 的缺点：</strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 中文翻译为套接字，是计算机网络中进程间进行<strong>双向通信的端点的抽象</strong>。一个 Socket 代表了网络通信的一端，是由操作系统提供的进程间通信机制。</p>
<ul>
<li>在操作系统中，通常会为应用程序提供一组应用程序接口，称为 Socket 接口（Socket API）。应用程序可以通过 Socket 接口，来使用网络 Socket，以进行数据的传输。</li>
<li>一个 Socket 由IP地址和端口组成，即：Socket 地址 = IP地址 : 端口号。</li>
<li>在同一台计算机上，TCP 协议与 UDP 协议可以同时使用相同的端口（Port），而互不干扰。</li>
<li>要想实现网络通信，至少需要一对 Socket，其中一个运行在客户端，称之为 Client Socket；另一个运行在服务器端，称之为 Server Socket。</li>
<li>Socket 之间的连接过程可以分为三个步骤：（1）服务器监听；（2）客户端连接；（3）连接确认。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127181515932.png" style="zoom:80%;" />

<h4 id="Socket-缓冲区"><a href="#Socket-缓冲区" class="headerlink" title="Socket 缓冲区"></a>Socket 缓冲区</h4><p>每个 Socket 被创建后，都会在内核中分配两个缓冲区：输入缓冲区和输出缓冲区。</p>
<ul>
<li>通过 Socket 发送数据并不会立即向网络中传输数据，而是先将数据写入到输出缓冲区中，再由 TCP 协议将数据从输出缓冲区发送到目标主机。</li>
<li>通过 Socket 接收数据也是如此，也是从输入缓冲区中读取数据，而不是直接从网络中读取。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127181657439.png" style="zoom:80%;" />





<h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><p>操作系统的内核是操作系统的核心部分。 它负责<strong>系统的内存，硬件设备，文件系统以及应用程序的管理</strong>。</p>
<h3 id="操作系统的用户态与内核态"><a href="#操作系统的用户态与内核态" class="headerlink" title="操作系统的用户态与内核态"></a>操作系统的用户态与内核态</h3><p>unix与linux的体系架构：分为用户态与内核态。 用户态与内核态与内核态是操作系统对<strong>执行权限进行分级</strong>后的不同的<strong>运行模式</strong>。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126105736357.png"></p>
<h3 id="为什么要有用户态与内核态？"><a href="#为什么要有用户态与内核态？" class="headerlink" title="为什么要有用户态与内核态？"></a>为什么要有用户态与内核态？</h3><p>在cpu的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。 为了避免这种情况发生，cpu将指令划分为<strong>特权级（内核态）指令</strong>和<strong>非特权级（用户态）指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态（核心态，特权态）：<strong>内核态是操作系统内核运行的模式。</strong> 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态：<strong>用户态是用户应用程序运行的状态。</strong>应用程序必须依托于内核态运行，因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用：系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h3 id="用户态切换到内核态的几种方式"><a href="#用户态切换到内核态的几种方式" class="headerlink" title="用户态切换到内核态的几种方式"></a>用户态切换到内核态的几种方式</h3><ul>
<li>系统调用：系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li>异常：当cpu在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li>硬件设备的中断：当硬件设备完成用户请求后，会向cpu发出相应的中断信号， 这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。</li>
</ul>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>首先来解释同步和异步的概念，这两个概念与消息的通知机制有关。也就是同步与异步主要是从<strong>消息通知机制</strong>角度来说的。</p>
<h4 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h4><p><strong>同步</strong>就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，如果方法没有计算完，就不返回。</p>
</blockquote>
<p><strong>异步</strong>是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，但是由于方法没有返回结果，所以就需要被调用的这个方法来通知调用线程 1 - 100的结果，或者线程在调用方法的时候指定一个回调函数来告诉被调用的方法执行完后就执行回调函数。</p>
</blockquote>
<h4 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h4><p>异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>这里提到执行部件和调用者通过三种途径返回结果：<strong>状态、通知和回调</strong>。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。</p>
<ol>
<li>如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）；</li>
<li>如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</li>
</ol>
<h4 id="场景比喻"><a href="#场景比喻" class="headerlink" title="场景比喻"></a>场景比喻</h4><p>举个例子，比如我去银行办理业务，可能会有两种方式：</p>
<ol>
<li>选择排队等候；</li>
<li>另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</li>
</ol>
<p>第一种：前者（排队等候）就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</p>
<p>第二种：后者（等待别人通知）就是异步等待消息通知。在异步消息处理中，等待消息通知者（在这个例子中就是等待办理业务的人）往往注册一个回调机制，在所等待的事件被触发时由触发机制（在这里是柜台的人）通过某种机制（在这里是写在小纸条上的号码，喊号）找到等待该事件的人。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞这两个概念与程序（线程）<strong>等待消息通知（无所谓同步或者异步）时的状态</strong>有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<h4 id="概念描述-1"><a href="#概念描述-1" class="headerlink" title="概念描述"></a>概念描述</h4><p>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，如果该方法没有返回结果， 那么调用方法的线程就一直等待直到该方法执行完毕。</p>
</blockquote>
<p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p>
<p>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：</p>
<ol>
<li>如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做<strong>同步非阻塞</strong>；</li>
<li>如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做<strong>同步阻塞</strong>；</li>
</ol>
<p><strong>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞；</strong></p>
<p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回；</p>
<p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100的和，该方法立刻返回，如果方法有返回结果，调用者线程也无需一直等待该方法的结果，可以执行其他任务，但是在方法返回结果之前，<strong>线程仍然需要轮询的检查方法是否已经有结果。</strong></p>
</blockquote>
<p>虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</p>
<h4 id="场景比喻-1"><a href="#场景比喻-1" class="headerlink" title="场景比喻"></a>场景比喻</h4><p>继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p>
<p>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他（等待者）没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p>
<p>但是需要注意了，<strong>同步非阻塞形式实际上是效率低下的</strong>，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<strong>异步非阻塞形式却没有这样的问题</strong>，因为打电话是你（等待者）的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。</p>
<p><strong>结论：同步和异步、阻塞与非阻塞针均是对调用者的立场而言的。</strong></p>
<h3 id="同步-异步与阻塞-非阻塞"><a href="#同步-异步与阻塞-非阻塞" class="headerlink" title="同步/异步与阻塞/非阻塞"></a>同步/异步与阻塞/非阻塞</h3><ol>
<li><p><strong>同步阻塞形式</strong></p>
<p><strong>效率是最低的</strong>，拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
<p><strong>实际程序中：</strong>就是未对fd 设置O_NONBLOCK标志位的read/write 操作；</p>
</li>
<li><p><strong>异步阻塞形式</strong></p>
<p>如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p><strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p>
<p>比如<strong>select 函数</strong>，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处。</p>
</li>
<li><p><strong>同步非阻塞形式</strong></p>
<p>实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
<p>很多人会写<strong>阻塞的read/write 操作</strong>，但是别忘了可以<strong>对fd设置O_NONBLOCK 标志位</strong>，这样就可以将同步操作变成非阻塞的了。</p>
</li>
<li><p><strong>异步非阻塞形式</strong></p>
<p>效率更高，因为打电话是你（等待者）的事情，而通知你则是柜台（消息触发机制）的事情，<strong>程序没有在两种不同的操作中来回切换</strong>。</p>
<p>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下（注册一个回调函数），那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步非阻塞的方式了。</p>
<p>如果使用异步非阻塞的情况，比如<code>aio_*</code>组的操作，当发起一个<code>aio_read</code>操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</p>
<p>很多人会把同步和阻塞混淆，我想是因为<strong>很多时候同步操作会以阻塞的形式表现出来</strong>，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置<code>O_NONBLOCK</code>标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。</p>
<p>同样的，很多人也会把异步和非阻塞混淆，因为<strong>异步操作一般都不会在真正的IO操作处被阻塞</strong>，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p>
</li>
</ol>
<h4 id="小明的故事"><a href="#小明的故事" class="headerlink" title="小明的故事"></a>小明的故事</h4><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说明，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态</strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能够更好的促进大家的理解。</p>
<ol>
<li><strong>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；<br>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；<br>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</p>
</blockquote>
<ol>
<li><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；<br>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；<br>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>
</blockquote>
<p>也就是说，<strong>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p>
<p>所以，综上所述，<strong>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态</strong>。也就是说，<strong>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者</strong>，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁：</p>
<blockquote>
<p>在银行的例子中，这个桥梁就是小纸条上面的号码。<br>在小明的例子中，这个桥梁就是软件“叮”的声音。</p>
</blockquote>
<p><strong>最后，请大家注意理解“消息通知机制”和“等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</strong></p>
<h2 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h2><p>网络IO的本质是socket的读取，<strong>socket在linux系统被抽象为流</strong>，IO可以理解为对流的操作。刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>第一阶段：等待数据准备 (Waiting for the data to be ready)。</p>
<p>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</p>
<p>对于socket流而言：</p>
<p>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</p>
<p>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</p>
<blockquote>
<p>网络应用需要处理的无非就是两大类问题，<strong>网络IO</strong>，<strong>数据计算</strong>。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。</p>
</blockquote>
<h3 id="一次I-O操作经历了什么"><a href="#一次I-O操作经历了什么" class="headerlink" title="一次I/O操作经历了什么"></a>一次I/O操作经历了什么</h3><p>在正式开始之前，先对I/O流程有一个感性的认识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">//fd已经在构造FileInputStream创建</span></span><br><span class="line">  FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/file1.txt&quot;</span>); </span><br><span class="line">  FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/file2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">  in.read(buf);</span><br><span class="line">  out.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是Java中典型的BIO，读取一个文件的内容，输出到另一个文件中。那么这个过程会发生那些事呢？</p>
<p>一次IO的读操作分为等待就绪和IO操作两个阶段，<strong>等待就绪</strong>就是等待TCP RecvBuffer里面的数据就绪好，也就是发送方的数据全部发送到网卡里面来，<strong>IO操作</strong>就是CPU将数据从网卡拷贝到用户空间。请看下图</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126195327555.png" style="zoom: 67%;" />

<p>发生了什么呢？</p>
<ul>
<li><code>in.read(buf)</code>执行时，JVM向kernel发起system call <code>read()</code></li>
<li>操作系统发生上下文切换，由用户态(User mode)切换到内核态(Kernel mode)，把数据读取到Kernel space buffer</li>
<li>Kernel把数据从Kernel space复制到User space，同时由内核态转为用户态。</li>
<li>JVM继续执行<code>out.write(buf)</code>这行代码</li>
<li>再次发生上下文切换，把数据复制到Kernel space buffer中。kernel把数据写入文件。</li>
</ul>
<p>从上面可以看出一个I/O操作，<strong>通常</strong>而言会发生下面的事</p>
<ol>
<li>两次上下文切换(User mode 和 Kernel mode之间转换)</li>
<li>数据在Kernel space 和 User space之间复制</li>
</ol>
<h3 id="I-O模型种类"><a href="#I-O模型种类" class="headerlink" title="I/O模型种类"></a>I/O模型种类</h3><p>Linux下共有5种IO模型：</p>
<ol>
<li>阻塞IO（Blocking I/O）</li>
<li>非阻塞IO（Non-Blocking I/O）</li>
<li>IO多路复用（I/O Multiplexing (<code>select</code> 、<code>poll</code>、 <code>epoll</code>)）</li>
<li>信号驱动IO（Signal driven I/O (<code>SIGIO</code>)）</li>
<li>异步IO（Asynchronous I/O）</li>
</ol>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞IO是很常见的一种IO模型。 在这种模型中，<strong>用户态的应用程序会执行一个操作系统的调用， 检查内核的数据是否准备好。如果内核的数据已经准备好， 就把数据复制到用户应用进程。如果内核没有准备好数据， 那么用户应用进程（线程）就阻塞，直到内核准备好数据并把数据从 内核复制到用户应用进程，</strong> 最后应用程序再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126115842261.png"></p>
<p><strong>流程描述：</strong></p>
<p>当用户进程调用了<code>recv()/recvfrom()</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>Process –&gt; system call –&gt; kernel –&gt; hardware(hard disk)</p>
<p>上图是blocking I/O发起system call <code>recvfrom()</code>时，进程将一直阻塞等待另一端Socket的数据到来。在这种I/O模型下，我们不得不为每一个Socket都分配一个线程，这会造成很大的资源浪费。</p>
</blockquote>
<p><strong>阻塞IO是同步阻塞的：</strong></p>
<ol>
<li>阻塞IO的同步体现在：<strong>内核只有准备好数据并把数据复制到用户应用进程才会返回。</strong></li>
<li>阻塞IO的阻塞体现在：<strong>用户应用进程等待内核准备数据和把数据从用户态拷贝到内核态的这整个过程，用户应用进程都必须一直等待。</strong> 当然，如果是本地磁盘IO，内核准备数据的时间可能会很短。 但网络IO就不一样了，因为服务端不知道客户端何时发送数据，内核就仍需要等待socket数据，时间就可能会很长。</li>
</ol>
<p><strong>优缺点：</strong></p>
<p><strong>阻塞IO的优点是对于数据是能够保证无延时的，因为应用程序进程会一直阻塞直到IO完成。</strong> 但应用程序的阻塞就意味着应用程序进程无法执行其他任务， 这会大大降低程序性能。一个不太可行的办法是为每个客户端 socket 都分配一个线程， 这样就会提升server处理请求的能力。不过操作系统的线程资源是有限的， 如果请求过多，可能造成线程资源耗尽，系统卡死等后果。</p>
<h3 id="非阻塞IO（网络IO模型）"><a href="#非阻塞IO（网络IO模型）" class="headerlink" title="非阻塞IO（网络IO模型）"></a>非阻塞IO（网络IO模型）</h3><p>在非阻塞IO模型中，用户态的应用程序也会执行一个操作系统的调用， 检查内核的数据是否准备完成。<strong>如果内核没有准备好数据, 内核会立刻返回结果，用户应用进程不用一直阻塞等待内核准备数据， 而是可以执行其他任务，但仍需要不断的向内核发起系统调用，检测数据是否准备好， 这个过程就叫轮询。</strong>轮询直到内核准备好数据，然后内核把数据拷贝到用户应用进程， 再进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p>
<p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ’被‘ CPU光顾”。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126120717900.png"></p>
<p><strong>流程描述：</strong></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<p>同样发起system call <code>recvfrom</code>，凭什么在blocking I/O会阻塞，而在这里kernel的数据还没就绪就直接返回<code>EWOULDBLOCK</code>呢？我们看看<code>recvfrom</code>函数定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里能看到<code>recvfrom</code>有个参数叫flags，默认情况下阻塞。可以设置flag为非阻塞让kernel在数据未就绪时直接返回。详细见<a href="https://linux.die.net/man/2/recvfrom">recvfrom</a>。</p>
<p>非阻塞IO的非阻塞体现在：<strong>用户应用进程发起I/O操作时，不会因为数据还没就绪而阻塞（即不用阻塞在对内核的系统调用上）</strong></p>
<p><strong>优缺点：</strong></p>
<p>非阻塞IO的优点在于用户应用进程在轮询阶段可以执行其它任务。 但这也是它的缺点，轮询就代表着用户应用进程不是时刻都会发起系统调用。 <strong>可能数据准备好了，而用户应用进程可能等待其它任务执行完毕才会发起系统调用， 这就意味着数据可能会被延时获取，导致整体数据吞吐量的降低。</strong></p>
<h3 id="IO多路复用（网络IO模型）"><a href="#IO多路复用（网络IO模型）" class="headerlink" title="IO多路复用（网络IO模型）"></a>IO多路复用（网络IO模型）</h3><p>由于同步非阻塞方式需要<strong>不断主动轮询</strong>，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果<strong>轮询不是进程的用户态</strong>，而是有人帮忙就好了。这就是所谓的 “<strong>IO 多路复用</strong>”。</p>
<p>上面介绍的I/O模型都是<strong>直接发起I/O操作</strong>，而I/O Multiplexing首先向kernel发起system call，传入file descriptor和感兴趣的事件（readable、writable等）<strong>让kernel监测</strong>，当其中一个或多个fd数据就绪，就会返回结果。程序再发起真正的I/O操作<code>recvfrom</code>读取数据。</p>
<p>在linux中，有3种system call可以让内核监测file descriptors，分别是select、poll、epoll。</p>
<p>select调用是<strong>内核级别</strong>的，select轮询相对非阻塞的轮询的区别在于前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行<code>recvform</code>系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的<strong>select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理</strong>。如何知道有一部分数据到达了呢？监视的事情交给了内核，<strong>内核负责数据到达的处理</strong>。也可以理解为”非阻塞”吧。</p>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻<strong>塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</strong>。而且可以<strong>同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时</strong>（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>
<p>对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，<strong>多个IO之间的顺序变得不确定了</strong>，当然也可以针对不同的编号。</p>
<p>在IO多路复用模型中，<strong>用户应用进程会调用操作系统的select/poll/epoll函数，它会使内核同步的轮询指定的socket（在NIO中，socket就是注册到Selector上的SocketChannel，可以允许多个）直至监听的socket有数据可读或可写，select/poll/epoll函数才会返回，用户应用进程也会阻塞的等待 select/poll/epoll函数返回。</strong> 当 select/poll/epoll函数返回后，即某个socket有事件发生了，用户应用进程就会发起系统调用，处理事件，将socket数据复制到用户进程内，然后进行数据处理。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126122722800.png"></p>
<blockquote>
<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call（select 和 recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，<strong>用select的优势在于它可以同时处理多个connection</strong>。</p>
</blockquote>
<p><strong>流程描述：</strong></p>
<p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。<strong>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的process其实是一直被block的。只不过<strong>process是被select这个函数block，而不是被socket IO给block</strong>。所以<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong></p>
<p><strong>IO多路复用模型是同步阻塞的：</strong></p>
<ol>
<li>IO多路复用模型的同步体现在：<strong>select函数只有监听到某个socket有事件才会返回</strong>。</li>
<li>IO多路复用模型的阻塞体现在：<strong>用户应用进程会阻塞在对select函数上的调用上</strong>。</li>
</ol>
<blockquote>
<p>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，<strong>用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞</strong>。所以，把IO多路复用归为同步阻塞模式。</p>
</blockquote>
<p><strong>IO多路复用的优点在于内核可以处理多个socket， 相当于一个用户进程（线程）就可以处理多个socket连接。</strong> 这样不仅降低了系统的开销，并且对于需要高并发的应用是非常有利的。 而非阻塞IO和阻塞IO的一个用户应用进程只能处理一个socket， 要想处理多socket，只能新开进程或线程，但这样很消耗系统资源。</p>
<p><strong>PS：在IO多路复用模型中, socket一般应该为非阻塞的， 这就是Java中NIO被称为非阻塞IO的原因。 但实际上NIO属于IO多路复用，它是同步阻塞的IO。 具体原因见 <a href="https://www.zhihu.com/question/37271342">知乎讨论</a></strong></p>
<p>目前支持I/O多路复用的系统调用有 <code>select</code>，<code>pselect</code>，<code>poll</code>，<code>epoll</code>，I/O多路复用就是<strong>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。但<code>select</code>，<code>pselect</code>，<code>poll</code>，<code>epoll</code>本质上都是<strong>同步I/O</strong>，因为他们都需要在<strong>读写事件就绪后自己负责进行读写</strong>，也就是说这个<strong>读写过程是阻塞的</strong>，而<strong>异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</strong>。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><strong>基本原理：</strong></p>
<p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p><strong>函数定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">  fd_set *exceptfds, struct timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select函数可以传入3个fd_set，分别对应了不同事件的file descriptor。返回值是一个int值，代表了就绪的fd数量，这个数量是3个fd_set就绪fd数量总和。</p>
<p>当程序发起system call select时流程如下</p>
<ol>
<li>程序阻塞等待kernel返回</li>
<li>kernel发现有fd就绪，返回数量</li>
<li>程序轮询3个fd_set寻找就绪的fd</li>
<li>发起真正的I/O操作(read、recvfrom等)</li>
</ol>
<p><strong>优点:</strong></p>
<ol>
<li>select目前几乎在所有的平台上支持（良好跨平台支持）</li>
<li>一次让kernel监测多个fd</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li><p>最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<blockquote>
<p>一般来说这个数目和系统内存关系很大，具体数目可以<code>cat/proc/sys/fs/file-max</code>察看。32位机默认是1024个。64位机默认是2048。</p>
</blockquote>
</li>
<li><p>kernel返回后，对socket进行扫描时是线性扫描，需要轮询所有fd找出就绪的fd，随着fd数量增加，性能会逐渐下降</p>
<blockquote>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<strong>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</strong>，这正是epoll与kqueue做的。</p>
</blockquote>
</li>
<li><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>
</li>
</ol>
<p>更多的介绍请点击<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec3.html">select函数</a>查看。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>基本原理：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>函数定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pollfd结构体如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">  <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数fds是一个结构体数组（基于链表来存储），因此poll<strong>不受限FD_SETSIZE的值</strong>（没有最大连接数的限制）。</p>
<p>缺点：</p>
<ol>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
<li>只有linux支持poll。</li>
</ol>
<p><strong>注意：</strong></p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>select和poll都是等待内核返回后轮询集合寻找就绪的fd，有没有一种机制，当某个fd就绪，kernel直接返回就绪的fd呢？这就是epoll。</p>
<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，<strong>没有描述符限制</strong>。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个<strong>事件表</strong>中，这样在用户空间和内核空间的copy只需一次。</p>
<p><strong>基本原理：</strong></p>
<p>epoll支持<strong>水平触发</strong>和<strong>边缘触发</strong>，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<blockquote>
<p>epoll是一种<strong>I/O事件通知机制</strong>，linux kernel 2.5.44开始提供这个功能，用于取代select和poll。</p>
</blockquote>
<p>epoll内部结构用<strong>红黑树</strong>实现，用于监听程序注册的fd。和epoll相关的函数共有3个，分别如下</p>
<ul>
<li><code>epoll_create1</code>：创建一个epoll实例并返回它的fd</li>
<li><code>epoll_ctl</code>：操作epoll实例，可往里面新增、删除fd</li>
<li><code>epoll_wait</code>：等待epoll实例中有fd就绪，且返回就绪的fd</li>
</ul>
<h5 id="epoll-create1"><a href="#epoll-create1" class="headerlink" title="epoll_create1"></a>epoll_create1</h5><p>创建一个epoll实例并返回它的file descriptor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>        *ptr;</span><br><span class="line">  <span class="keyword">int</span>          fd;</span><br><span class="line">  <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">  <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>epoll_ctl</code>用来操作epoll实例监听的fd，可以往epoll实例中新增、删除。参数解释如下：</p>
<ul>
<li><code>epdf</code>：即<code>epoll_create1</code>返回的fd</li>
<li>op是operation的缩写，可为EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL</li>
<li>fd即要监控的fd</li>
<li>event即要注册的事件集合（可读、可写之类的）</li>
</ul>
<h5 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用epoll_wait函数会阻塞，直到epoll实例监控的fd中有一个或多个fd就绪，或timeout。就绪的fd会被kernel添加到events数组中。</p>
<ul>
<li><code>epfd</code>：即<code>epoll_create1</code>返回的fd</li>
<li><code>events</code>：<code>events</code>数组，就绪的fd将会放在这里</li>
<li>最大的事件数量</li>
<li>超时时间</li>
</ul>
<p>epoll是一种性能很高的同步I/O方案。现在linux中的高性能网络框架（tomcat、netty等）都有epoll的实现。缺点是只有linux支持epoll，BSD内核的kqueue类似于epoll。</p>
<p>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p><strong>注意：</strong></p>
<p>如果没有大量的<code>idle-connection</code>或者<code>dead-connection</code>，epoll的效率并不会比select/poll高很多，但是当遇到大量的<code>idle-connection</code>，就会发现epoll的效率大大高于select/poll。</p>
<h4 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h4><table>
<thead>
<tr>
<th>函数</th>
<th>支持一个进程所能打开的最大连接数</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>单个进程所能打开的最大连接数有 FD_ SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32* 32，同理64位机器上 FD_ SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td>
</tr>
<tr>
<td>poll</td>
<td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>FD剧增后带来的IO效率问题</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th><strong>消息传递方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody></table>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p>
<ol>
<li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li>
</ol>
<p><strong>epoll的优点：</strong></p>
<ol>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递；即epoll使用<code>mmap</code>减少复制开销。</li>
</ol>
<p><strong>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p>
<ul>
<li>LT模式（水平触发）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式（边缘触发）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到 <code>EAGAIN</code> 错误。</li>
</ul>
<p><strong>LT模式</strong></p>
<p>LT（level triggered）是<strong>缺省工作方式</strong>，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p><strong>ET模式</strong></p>
<p>ET（edge-triggered）是<strong>高速工作方式</strong>，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="多路复用的适用场景"><a href="#多路复用的适用场景" class="headerlink" title="多路复用的适用场景"></a>多路复用的适用场景</h4><p>在I/O编程过程中，<strong>当需要同时处理多个客户端接入请求时</strong>，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是<strong>系统开销小</strong>，系统<strong>不需要创建新的额外进程或者线程</strong>，也<strong>不需要维护</strong>这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p>
<ul>
<li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>
</li>
<li><p>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p>
</li>
<li><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>
<blockquote>
<p>一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>
</blockquote>
</li>
<li><p>服务器需要同时处理多种网络协议的套接字。</p>
<blockquote>
<p>例如：一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>
</blockquote>
</li>
<li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>
</li>
</ul>
<p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong>他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询</strong>，两个阶段过程：</p>
<blockquote>
<p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p>
<p>第二个阶段都是阻塞的。</p>
</blockquote>
<p><strong>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。</strong></p>
<p><strong>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式</strong>。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种<strong>高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</strong></p>
<h3 id="信号驱动IO（网络IO模型）"><a href="#信号驱动IO（网络IO模型）" class="headerlink" title="信号驱动IO（网络IO模型）"></a>信号驱动IO（网络IO模型）</h3><p>在信号驱动IO模型中，<strong>用户应用进程发起sigaction系统调用，内核收到并立即返回。 用户应用进程可以继续执行其他任务，不会阻塞。当内核准备好数据后向用户应用进程 发送SIGIO信号，应用进程收到信号后，发起系统调用，将数据从内核拷贝到用户进程，</strong> 然后进行数据处理。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126174228791.png"></p>
<p>个人感觉在内核收到系统调用就立刻返回这一点很像异步IO的方式了，不过与异步IO仍有很大差别。</p>
<p>Singal-Driven I/O模型有点复杂，且存在一些限制。有兴趣请点击<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch25lev1sec2.html#ch25lev1sec2">Signal-Driven I/O for Sockets</a>查看。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>在异步IO模型中，<strong>用户进程发起aio_read系统调用，无论内核的数据是否准备好，都会立即返回。用户应用进程不会阻塞，可以继续执行其他任务。当内核准备好socket数据，会直接把数据复制到用户应用进程。最后内核会通知用户应用进程IO完成。IO两个阶段，进程都是非阻塞的</strong></p>
<blockquote>
<p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。</p>
</blockquote>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126174546502.png"></p>
<blockquote>
<p>请留意图片细节，程序不需要再次发起读取数据的system call，因为kernel会把数据复制到user space再通知进程处理，整个过程不存在任何阻塞。</p>
</blockquote>
<p>流程描述：</p>
<p>用户进程发起<code>aio_read</code>操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它收到一个<code>asynchronous read</code>之后，首先它会立刻返回，所以不会对用户进程产生任何<code>block</code>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p>
<p><strong>异步IO的异步体现在：内核不用等待数据准备好就立刻返回， 所以内核肯定需要在IO完成后通知用户应用进程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb *aiocbp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aiocb</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">  <span class="comment">/* The order of these fields is implementation-dependent */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>             aio_fildes;     <span class="comment">/* File descriptor */</span></span><br><span class="line">  <span class="keyword">off_t</span>           aio_offset;     <span class="comment">/* File offset */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">void</span>  *aio_buf;        <span class="comment">/* Location of buffer */</span></span><br><span class="line">  <span class="keyword">size_t</span>          aio_nbytes;     <span class="comment">/* Length of transfer */</span></span><br><span class="line">  <span class="keyword">int</span>             aio_reqprio;    <span class="comment">/* Request priority */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>   <span class="comment">/* Notification method */</span></span><br><span class="line">  <span class="keyword">int</span>             aio_lio_opcode; <span class="comment">/* Operation to be performed;</span></span><br><span class="line"><span class="comment">                                       lio_listio() only */</span></span><br><span class="line">  <span class="comment">/* Various implementation-internal fields not shown */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<p><strong>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务</strong>。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<strong>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</strong>。</p>
<p>如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。</p>
<p>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
<p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此<strong>通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制</strong>。</p>
<p><strong>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p>
<p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机：</p>
<ul>
<li>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</li>
<li>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</li>
<li>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。</li>
</ul>
<p>IO多路复用除了需要阻塞之外，select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。</p>
<h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h3><h4 id="blocking和non-blocking区别"><a href="#blocking和non-blocking区别" class="headerlink" title="blocking和non-blocking区别"></a>blocking和non-blocking区别</h4><p>阻塞I/O发起真正的 I/O操作时（如read、recvfrom等）将会阻塞等待kernel数据就绪。非阻塞I/O在kernel还准备数据的情况下会立刻返回并且会不断发起system call，直到kernel数据就绪。</p>
<h4 id="synchronous-IO和asynchronous-IO区别"><a href="#synchronous-IO和asynchronous-IO区别" class="headerlink" title="synchronous IO和asynchronous IO区别"></a>synchronous IO和asynchronous IO区别</h4><p>POSIX对这两个术语定义如下：</p>
<ul>
<li>同步I/O操作将会造成请求进程阻塞，直到I/O操作完成</li>
<li>异步I/O操作不会造成进程阻塞</li>
</ul>
<p>根据上面的定义我们可以看出，前面4种I/O模型都是同步I/O，因为它们的I/O操作(<code>recvfrom</code>)都会造成进程阻塞。只有最后一个I/O模型匹配异步I/O的定义。</p>
<blockquote>
<p>POSIX defines these two terms as follows:</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>Using these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.</p>
</blockquote>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h4 id="I-O-Multiplexing是非阻塞I-O吗？"><a href="#I-O-Multiplexing是非阻塞I-O吗？" class="headerlink" title="I/O Multiplexing是非阻塞I/O吗？"></a>I/O Multiplexing是非阻塞I/O吗？</h4><p>很多人会混淆两者的关系，很显然，不是！</p>
<p>不管是select、poll、epoll都会导致进程阻塞。发起真正的IO操作时(比如recvfrom)，进程也会阻塞。</p>
<p>I/O Multiplexing优点在于一次性可以监控大量的file descriptors。</p>
<p><strong>特别注意：select、poll、epoll并不是I/O操作，read、recvfrom这些才是。</strong></p>
<h4 id="5种IO模型的比较"><a href="#5种IO模型的比较" class="headerlink" title="5种IO模型的比较"></a>5种IO模型的比较</h4><p>从上述五种 IO 模型可以看出，应用进程对内核发起 IO 系统调用后，内核会经过两个阶段来完成数据的传输：</p>
<ul>
<li>第一阶段：等待数据。即应用进程发起 IO 系统调用后，会一直等待数据；当有数据传入服务器，会将数据放入内核空间，此时数据准备好。</li>
<li>第二阶段：将数据从内核空间复制到用户空间，并返回给应用程序成功标识。</li>
</ul>
<p><strong>各个IO Model的比较如图所示：</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127180434891.png" style="zoom: 80%;" />

<blockquote>
<p>前四种模型的第二阶段是相同的，都是处于阻塞状态，其主要区别在第一阶段。而异步 IO 模型则不同，应用进程在这两个阶段是完全不阻塞的。</p>
</blockquote>
<p>通过上面的图片，可以发现<code>non-blocking IO</code>和<code>asynchronous IO</code>的区别还是很明显的。在<code>non-blocking IO</code>中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而<code>asynchronous IO</code>则完全不同。它就像是用户进程将整个IO操作交给了它人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<table>
<thead>
<tr>
<th>IO 模型</th>
<th>第一阶段</th>
<th>第二阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞式IO</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>非阻塞式IO</td>
<td>非阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>IO多路程复用</td>
<td>阻塞（Select）</td>
<td>阻塞</td>
</tr>
<tr>
<td>信号驱动式IO</td>
<td>异步</td>
<td>阻塞</td>
</tr>
<tr>
<td>异步IO</td>
<td>异步</td>
<td>异步</td>
</tr>
</tbody></table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://qsjzwithguang19forever.gitee.io/framework-learning/gitbook_doc/jdk-jvm-juc/Linux_IO.html">framework-learning-Linux IO</a></strong></p>
</li>
<li><p><strong><a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型 </a></strong></p>
</li>
<li><p><strong><a href="https://segmentfault.com/a/1190000039898780">浅聊Linux的五种IO模型</a></strong></p>
</li>
<li><p><strong><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a></strong></p>
</li>
<li><p><strong><a href="https://zhuanlan.zhihu.com/p/371508875">聊聊同步、异步、阻塞与非阻塞</a></strong></p>
</li>
<li><p><strong><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Xftp</title>
    <url>/post/78f1820d/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Xftp</strong>是一个基于 MS windows 平台的SFTP、FTP 文件传输软件。使用Xftp，MS windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。Xftp能同时适应初级用户和高级用户的需要。它采用了标准的Windows风格的向导，它简单的界面能与其他 Windows应用程序紧密地协同工作，此外它还为高级用户提供了众多功能特性。</p>
<span id="more"></span>
<p><a href="https://www.netsarang.com/en/xftp-download/">官网下载地址</a></p>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol>
<li><p>下载Xftp并安装后出现如下界面</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213215552716.png"></p>
</li>
<li><p><strong>点击文件 -&gt; 新建</strong> 或者 如下图所示的<strong>图标</strong></p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213220445527.png"></p>
</li>
<li><p>输入相关信息</p>
<p>说明： 为了创建一个新的会话交换文件，应该输入会话名称、主机IP地址、选择适当的协议、输入远程服务器使用的端口号、用户帐户和密码。</p>
<ul>
<li>名称：随便填写即可</li>
<li>主机：填写Linux的IP地址</li>
<li>协议：选择SFTP</li>
<li>方法：password，输入与Linux相同的用户名与密码</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213215759908.png" style="zoom:80%;" /></li>
<li><p>第一次进入后出现SSH安全警告弹框，可以选择“一次性接受”或者“接受并保存”；若之前选择过“接受并保存”选项则直接出现会话选择框提供用户选择之前创建的会话。点击连接即可。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213215957097.png" style="zoom:80%;" />

<p>成功创建会话后界面如下所示</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213220134528.png"></p>
</li>
<li><p>此时就可以使用Xftp工具来完成windows系统和linux系统的文件传输了。可以从本地文件夹窗口选择要转移的文件或直接将其拖拽到主窗口。 可以使用超过两个窗格。每个窗格都可能包含多个选项卡，因此多个会话可以在单个Xftp窗口打开，方便多任务同时处理。</p>
<blockquote>
<p>备注：Linux的<strong>IP</strong>地址的<strong>查询方法</strong>为在Linux终端输入 <code>ifconfig</code> 命令并回车即可。</p>
</blockquote>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213220257354.png" style="zoom:80%;" /></li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://www.jianshu.com/p/6fa90b84c4b7">Xftp使用方法</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Xftp</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 TCP 建立连接需要三次握手？</title>
    <url>/post/fca3bfb7/</url>
    <content><![CDATA[<p>TCP 协议是我们几乎每天都会接触到的网络协议，绝大多数网络连接的建立都是基于 TCP 协议的，学过计算机网络或者对 TCP 协议稍有了解的人都知道 —— 使用 TCP 协议建立连接需要经过三次握手（three-way handshake）。</p>
<p>如果让我们简单说说 TCP 建立连接的过程，相信很多准备过面试的人都会非常了解，但是一旦想要深究『为什么 TCP 建立连接需要三次握手？』，作者相信大多数人都没有办法回答这个问题或者会给出错误的答案，这篇文章就会讨论究竟为什么我们需要三次握手才能建立 TCP 连接？</p>
<p>需要注意的是我们会将重点放到为什么需要 TCP 建立连接需要<strong>『三次握手』</strong>，而不仅仅是为什么需要<strong>『三次』</strong>握手。</p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在具体分析今天的问题之前，我们首先可以了解一下最常见的错误类比，这个对 TCP 连接过程的错误比喻误导了很多人，作者在比较长的一段时间内也认为它能够很好地描述 TCP 建立连接为什么需要三次握手：</p>
<ol>
<li>你听得到吗？</li>
<li>我能听到，你听得到？</li>
<li>我也能听到；</li>
</ol>
<p>这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；<strong>类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用</strong>，我们在文章的后面会介绍为什么这里的类比有问题，各位读者也可以带着疑问来阅读剩下的内容。</p>
<p>很多人尝试回答或者思考这个问题的时候其实关注点都放在了三次握手中的<strong>三次</strong>上面，这确实很重要，但是如果重新审视这个问题，我们对于『什么是连接』真的清楚？只有知道<strong>连接的定义</strong>，我们才能去尝试回答为什么 TCP 建立连接需要三次握手。</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 <strong>Socket</strong>、<strong>序列号</strong>以及<strong>窗口大小</strong>叫做连接。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220318082544988.png" style="zoom:80%;" />

<p>所以，建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，<strong>连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收</strong>。</p>
<p>到这里，我们将原有的问题转换成了『为什么需要通过三次握手才可以初始化 Sockets、窗口大小和初始序列号？』，那么接下来我们就开始对这个细化的问题进行分析并寻找解释。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li>通过三次握手才能阻止重复历史连接的初始化；</li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；</li>
</ul>
<p>这几个论点中的第一个是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因，我们在这里对它们的讨论只是为了让整个视角更加丰富，通过多方面理解这一有趣的设计决策。</p>
<h3 id="历史连接"><a href="#历史连接" class="headerlink" title="历史连接"></a>历史连接</h3><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 其实就指出了 TCP 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
</blockquote>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220318093537699.png" style="zoom:80%;" />

<p>想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p>
<p>所以，TCP 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>
<ul>
<li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li>
</ul>
<p><strong>使用三次握手和</strong> <code>RST</code> <strong>控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的</strong>，这也是 TCP 使用三次握手建立连接的最主要原因。</p>
<h3 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h3><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220318094537677.png" style="zoom:80%;" />

<p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 TCP 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h3 id="通信次数"><a href="#通信次数" class="headerlink" title="通信次数"></a>通信次数</h3><p>当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以<strong>使用更多的通信次数交换相同的信息</strong>，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220318095628938.png" style="zoom:80%;" />

<p>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是<strong>用更少的通信次数（理论上的边界）完成信息的交换</strong>，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在这篇文章中讨论了为什么 TCP 建立连接需要经过三次握手，在具体分析这个问题之前，我们首先重新思考了 TCP 连接究竟是什么，<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a> 对 TCP 连接有着非常清楚的定义 —— 用于保证可靠性和流控制机制的数据，包括 Socket、序列号以及窗口大小。</p>
<p>TCP 建立连接时通过三次握手可以有效地<strong>避免历史错误连接的建立</strong>，<strong>减少通信双方不必要的资源消耗</strong>，<strong>三次握手能够帮助通信双方获取初始化序列号</strong>，它们能够<strong>保证数据包传输的不重不丢</strong>，还能<strong>保证它们的传输顺序</strong>，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 <code>ACK</code> 和 <code>SYN</code> 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<p>我们重新回到在文章开头提的问题，为什么使用类比解释 TCP 使用三次握手是错误的？这主要还是因为，这个类比没有解释清楚核心问题 —— 避免历史上的重复连接。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细想一下下面的问题：</p>
<ul>
<li>除了使用序列号是否还有其他方式保证消息的不重不丢？</li>
<li>UDP 协议有连接的概念么，它能保证数据传输的可靠么？</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a></li>
<li><a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way">Why do we need a 3-way handshake? Why not just 2-way?</a></li>
</ul>
<p>文章转载来源：</p>
<ul>
<li><strong><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>为什么这么设计</tag>
      </tags>
  </entry>
  <entry>
    <title>curl</title>
    <url>/post/3e01b4d/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>cURL</strong>是一个开源项目，主要的产品是curl（<strong>命令行工具</strong>）和libcurl（C语言的API库），两者功能均是：基于网络协议，对指定URL进行网络传输（发出网络请求）。curl可以得到和提取数据，显示在”标准输出”（stdout）上面。</p>
<p>cURL涉及是任何网络协议传输，不涉及对具体数据的具体处理。（如：html的渲染等）</p>
<p>curl 支持多种协议，下面举例讲解如何将它用于网站开发。</p>
<span id="more"></span>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h3><p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址<a href="http://www.mi.com为例（选择该网址，主要因为它的网页代码较短）：">www.mi.com为例（选择该网址，主要因为它的网页代码较短）：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl www.mi.com</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Moved Permanently<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The document has moved <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.sina.com.cn/&quot;</span>&gt;</span>here<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="服务器的回应保存成文件"><a href="#服务器的回应保存成文件" class="headerlink" title="服务器的回应保存成文件"></a>服务器的回应保存成文件</h3><p><code>-o</code>参数将服务器的回应保存成文件，等同于<code>wget</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o [文件名] www.mi.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o example.html https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令将 <code>www.example.com </code>保存成 <code>example.html</code>。</p>
<p><code>-O</code>参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://www.example.com/foo/bar.html</span><br></pre></td></tr></table></figure>

<p>上面命令将服务器回应保存成文件，文件名为<code>bar.html</code>。</p>
<h3 id="自动跳转（重定向）"><a href="#自动跳转（重定向）" class="headerlink" title="自动跳转（重定向）"></a>自动跳转（重定向）</h3><p><code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L www.sina.com</span><br></pre></td></tr></table></figure>

<p>键入上面的命令，结果就自动跳转为<a href="http://www.sina.com.cn./">www.sina.com.cn。</a></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L -d <span class="string">&#x27;tweet=hi&#x27;</span> https://api.twitter.com/tweet</span><br></pre></td></tr></table></figure>



<h3 id="显示头信息"><a href="#显示头信息" class="headerlink" title="显示头信息"></a>显示头信息</h3><p><code>-i </code>参数可以<strong>显示http response的头信息，连同网页代码一起</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -i www.mi.com</span><br></pre></td></tr></table></figure>

<p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">TP/1.1 302 Moved Temporarily</span><br><span class="line">Server: kngx/1.10.2</span><br><span class="line">Date: Fri, 04 Feb 2022 09:49:31 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 160</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://www.mi.com/</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">x-link-via: zzct010:80;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>kngx/1.10.2<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>-I</code> 参数则是<strong>只显示http response的头信息</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令输出服务器对 HEAD 请求的回应。</p>
<p><code>--head</code>参数等同于<code>-I</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --head https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="显示通信过程"><a href="#显示通信过程" class="headerlink" title="显示通信过程"></a>显示通信过程</h3><p><code>-v </code>参数可以<strong>显示一次http通信的整个过程</strong>（用于调试），包括端口连接和http request头信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v https://www.example.com</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v www.mi.com</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  Trying 240e:93c:210:3::6:80...</span><br><span class="line">* Connected to www.mi.com (240e:93c:210:3::6) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: www.mi.com</span><br><span class="line">&gt; User-Agent: curl/7.74.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP/1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: kngx/1.10.2</span><br><span class="line">&lt; Date: Fri, 04 Feb 2022 09:52:02 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 160</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: https://www.mi.com/</span><br><span class="line">&lt; Cache-Control: max-age=0</span><br><span class="line">&lt; x-link-via: zzct010:80;</span><br><span class="line">&lt;</span><br><span class="line">&#123; [160 bytes data]</span><br><span class="line">100   160  100   160    0     0   4444      0 --:--:-- --:--:-- --:--:--  4444<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>kngx/1.10.2<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">* Connection #0 to host www.mi.com left intact</span><br></pre></td></tr></table></figure>

<p>如果你觉得上面的信息还不够，那么下面的命令<strong>可以查看更详细的通信过程</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace output.txt www.mi.com</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace-ascii output.txt www.mi.com</span><br></pre></td></tr></table></figure>

<p>运行后，请打开 output.txt文件查看。</p>
<p><code>--trace</code>参数也可以用于调试，还会输出原始的二进制数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace - https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="发送表单信息"><a href="#发送表单信息" class="headerlink" title="发送表单信息"></a>发送表单信息</h3><p><strong>发送表单信息有GET和POST两种方法</strong>。GET方法相对简单，只要把数据附在网址后面就行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure>

<p><code>-G</code>参数用来构造 URL 的查询字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -G -d <span class="string">&#x27;q=kitties&#x27;</span> -d <span class="string">&#x27;count=20&#x27;</span> https://google.com/search</span><br></pre></td></tr></table></figure>

<p>上面命令会发出一个 GET 请求，实际请求的 URL 为<code>https://google.com/search?q=kitties&amp;count=20</code>。如果省略<code>--G</code>，会发出一个 POST 请求。</p>
<p>如果数据需要 URL 编码，可以结合<code>--data--urlencode</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -G --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>



<h4 id="发送-POST-请求的数据体"><a href="#发送-POST-请求的数据体" class="headerlink" title="发送 POST 请求的数据体"></a>发送 POST 请求的数据体</h4><p>POST方法必须把数据和网址分开，curl就要用到 <code>--data</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST --data <span class="string">&quot;data=xxx&quot;</span> example.com/form.cgi</span><br></pre></td></tr></table></figure>



<p><code>-d</code>参数用于发送 POST 请求的数据体。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d<span class="string">&#x27;login=emma＆password=123&#x27;</span>-X POST https://google.com/login</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;login=emma&#x27;</span> -d <span class="string">&#x27;password=123&#x27;</span> -X POST  https://google.com/login</span><br></pre></td></tr></table></figure>

<p>使用 <code>-d</code> 参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p>
<p><code>-d</code> 参数可以读取本地文本文件的数据，向服务器发送。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;@data.txt&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p>
<p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p>
<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST--data-urlencode <span class="string">&quot;date=April 1&quot;</span> example.com/form.cgi</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p>
<h3 id="HTTP-请求的代理"><a href="#HTTP-请求的代理" class="headerlink" title="HTTP 请求的代理"></a>HTTP 请求的代理</h3><p><code>-x</code>参数指定 HTTP 请求的代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令指定 HTTP 请求通过<code>myproxy.com:8080</code>的 socks5 代理发出。</p>
<p>如果没有指定代理协议，默认为 HTTP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x james:cats@myproxy.com:8080 https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令中，请求的代理使用 HTTP 协议。</p>
<h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p><code>-X</code>参数指定 HTTP 请求的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令对<code>https://www.example.com</code>发出 POST 请求。</p>
<p><strong>curl默认的HTTP动词是GET</strong>，<strong>使用</strong> <code>-X</code> <strong>参数可以支持其他动词</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST www.example.com</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>假定文件上传的表单是下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&#x27;multipart/form-data&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;upload.cgi&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">press</span> <span class="attr">value</span>=<span class="string">&quot;OK&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以用curl这样上传文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure>



<p><code>-F</code>参数用来向服务器上传二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p>
<p><code>-F</code>参数可以指定 MIME 类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png;type=image/png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令指定 MIME 类型为<code>image/png</code>，否则 curl 会把 MIME 类型设为<code>application/octet-stream</code>。</p>
<p><code>-F</code>参数也可以指定文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png;filename=me.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令中，原始文件名为<code>photo.png</code>，但是服务器接收到的文件名为<code>me.png</code>。</p>
<h3 id="Referer字段"><a href="#Referer字段" class="headerlink" title="Referer字段"></a>Referer字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure>

<p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -e <span class="string">&#x27;https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>Referer</code>标头设为<code>https://google.com?q=example</code>。</p>
<p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Referer: https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="User-Agent字段"><a href="#User-Agent字段" class="headerlink" title="User Agent字段"></a>User Agent字段</h3><p>这个字段是用来表示<strong>客户端的设备信息</strong>。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p>
<p>iPhone4的User Agent是</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4<span class="built_in">_</span>0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure>

<p>curl可以这样模拟：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --user-agent <span class="string">&quot;[User Agent]&quot;</span> [URL]</span><br></pre></td></tr></table></figure>



<p><code>-A</code>参数指定客户端的用户代理标头，即<code>User-Agent</code>。curl 的默认用户代理字符串是<code>curl/[version]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>User-Agent</code>改成 Chrome 浏览器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A <span class="string">&#x27;&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令会移除<code>User-Agent</code>标头。</p>
<p>也可以通过<code>-H</code>参数直接指定标头，更改<code>User-Agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;User-Agent: php/1.0&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>



<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>使用 <code>--cookie</code> 参数，可以让curl发送cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --cookie <span class="string">&quot;name=xxx&quot;</span> www.example.com</span><br></pre></td></tr></table></figure>

<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -c cookies http://example.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -c cookies.txt https://www.google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件<code>cookies.txt</code>。</p>
<p><code>-b</code>参数用来向服务器发送 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b cookies http://example.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">&#x27;foo=bar&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令会生成一个标头<code>Cookie: foo=bar</code>，向服务器发送一个名为<code>foo</code>、值为<code>bar</code>的 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">&#x27;foo1=bar;foo2=bar2&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令发送两个 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b cookies.txt https://www.google.com</span><br></pre></td></tr></table></figure>

<p>上面命令读取本地文件<code>cookies.txt</code>，里面是服务器设置的 Cookie（参见<code>-c</code>参数），将其发送到服务器。</p>
<h3 id="增加头信息"><a href="#增加头信息" class="headerlink" title="增加头信息"></a>增加头信息</h3><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --header <span class="string">&quot;Content-Type:application/json&quot;</span> http://example.com</span><br></pre></td></tr></table></figure>



<p><code>-H</code>参数添加 HTTP 请求的标头。</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令添加 HTTP 标头<code>Accept-Language: en-US</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> -H <span class="string">&#x27;Secret-Message: xyzzy&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令添加两个 HTTP 标头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令添加 HTTP 请求的标头是<code>Content-Type: application/json</code>，然后用<code>-d</code>参数发送 JSON 数据。</p>
<h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>有些网域需要HTTP认证，这时curl需要用到 <code>--user</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --user name:password example.com</span><br></pre></td></tr></table></figure>



<h3 id="跳过-SSL-检测"><a href="#跳过-SSL-检测" class="headerlink" title="跳过 SSL 检测"></a>跳过 SSL 检测</h3><p><code>-k</code>参数指定跳过 SSL 检测。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令不会检查服务器的 SSL 证书是否正确。</p>
<h3 id="限制-HTTP-请求和回应的带宽"><a href="#限制-HTTP-请求和回应的带宽" class="headerlink" title="限制 HTTP 请求和回应的带宽"></a>限制 HTTP 请求和回应的带宽</h3><p><code>--limit-rate</code>用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --limit-rate 200k https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将带宽限制在每秒 200K 字节。</p>
<h3 id="错误信息的输出"><a href="#错误信息的输出" class="headerlink" title="错误信息的输出"></a>错误信息的输出</h3><p><code>-s</code> 参数将不输出错误和进度信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p>
<p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o /dev/null https://google.com</span><br></pre></td></tr></table></figure>



<p><code>-S</code>参数指定只输出错误信息，通常与<code>-s</code>一起使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -S -o /dev/null https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令没有任何输出，除非发生错误。</p>
<h3 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h3><p><code>-u</code> 参数用来设置服务器认证的用户名和密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;bob:12345&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令设置用户名为<code>bob</code>，密码为<code>12345</code>，然后将其转为 HTTP 标头<code>Authorization: Basic Ym9iOjEyMzQ1</code>。</p>
<p>curl 能够识别 URL 里面的用户名和密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://bob:12345@google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;bob&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</p>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><p>​        curl命令作用 curl命令是一个功能强大的网络工具，它能够通过http、ftp等方式下载文件，也能够上传文件，同时支持HTTPS等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。其实curl远不止前面所说的那些功能，大家可以通过man curl阅读手册页获取更多的信息。类似的工具还有wget。curl命令使用了libcurl库来实现，libcurl库常用在C程序中用来处理HTTP请求，curlpp是libcurl的一个C++封装，这几个东西可以用在抓取网页、网络监控等方面的开发，而curl命令可以帮助来解决开发过程中遇到的问题。</p>
<p>常用参数 curl命令参数很多，这里只列出我曾经用过、特别是在shell脚本中经常用到过的那些。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-a/--append 上传文件时，附加到目标文件</span><br><span class="line"></span><br><span class="line">-A:随意指定自己这次访问所宣称的自己的浏览器信息</span><br><span class="line"></span><br><span class="line">-b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置，使用option来把上次的cookie信息追加到http request里面去。</span><br><span class="line"></span><br><span class="line">-c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中</span><br><span class="line"></span><br><span class="line">-C/--continue-at &lt;offset&gt;  断点续转</span><br><span class="line"></span><br><span class="line">-d/--data &lt;data&gt;   HTTP POST方式传送数据</span><br><span class="line"></span><br><span class="line">    --data-ascii &lt;data&gt;	以ascii的方式post数据</span><br><span class="line">     --data-binary &lt;data&gt;	以二进制的方式post数据</span><br><span class="line">     --negotiate	使用HTTP身份验证</span><br><span class="line">     --digest	使用数字身份验证</span><br><span class="line">     --disable-eprt	禁止使用EPRT或LPRT</span><br><span class="line">     --disable-epsv	禁止使用EPSV</span><br><span class="line">-D/--dump-header &lt;file&gt; 把header信息写入到该文件中</span><br><span class="line"></span><br><span class="line">     --egd-file &lt;file&gt;  为随机数据(SSL)设置EGD socket路径</span><br><span class="line"></span><br><span class="line">     --tcp-nodelay     使用TCP<span class="built_in">_</span>NODELAY选项</span><br><span class="line"></span><br><span class="line">-e/--referer &lt;URL&gt;  指定引用地址</span><br><span class="line"></span><br><span class="line">-F/--form &lt;name=content&gt;   模拟http表单提交数据</span><br><span class="line"></span><br><span class="line">     --form-string &lt;name=string&gt; 模拟http表单提交数据</span><br><span class="line"></span><br><span class="line">-G/--get    以get的方式来发送数据</span><br><span class="line"></span><br><span class="line">-H/--header &lt;header&gt; 指定请求头参数</span><br><span class="line"></span><br><span class="line">    --ignore-content-length  忽略的HTTP头信息的长度</span><br><span class="line"></span><br><span class="line">-i/--include     输出时包括protocol头信息</span><br><span class="line"></span><br><span class="line">-I/--head 仅返回头部信息，使用HEAD请求</span><br><span class="line"></span><br><span class="line">-k/--insecure  允许不使用证书到SSL站点</span><br><span class="line"></span><br><span class="line">-K/--config    指定的配置文件读取</span><br><span class="line"></span><br><span class="line">-l/--list-only   列出ftp目录下的文件名称</span><br><span class="line"></span><br><span class="line">    --limit-rate &lt;rate&gt; 设置传输速度</span><br><span class="line"></span><br><span class="line">     --local-port&lt;NUM&gt;  强制使用本地端口号</span><br><span class="line"></span><br><span class="line">-m/--max-time &lt;seconds&gt; 指定处理的最大时长</span><br><span class="line"></span><br><span class="line">     --max-redirs &lt;num&gt;    设置最大读取的目录数</span><br><span class="line"></span><br><span class="line">     --max-filesize &lt;bytes&gt;  设置最大下载的文件总量</span><br><span class="line"></span><br><span class="line">-o/--output &lt;file&gt;   指定输出文件名称</span><br><span class="line"></span><br><span class="line">-O/--remote-name  把输出写到该文件中，保留远程文件的文件名</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">-v/--verbose  小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</span><br><span class="line"></span><br><span class="line">-s/--slient 减少输出的信息，比如进度</span><br><span class="line"></span><br><span class="line">--connect-timeout &lt;seconds&gt; 指定尝试连接的最大时长</span><br><span class="line"></span><br><span class="line">-x/--proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">-u/--user &lt;user[:password]&gt;设置服务器的用户和密码</span><br><span class="line"></span><br><span class="line">-r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line"></span><br><span class="line">   --range-file 读取（SSL）的随机文件</span><br><span class="line"></span><br><span class="line">-R/--remote-time   在本地生成文件时，保留远程文件时间</span><br><span class="line"></span><br><span class="line">    --retry &lt;num&gt;   指定重试次数</span><br><span class="line"></span><br><span class="line">    --retry-delay &lt;seconds&gt;   传输出现问题时，设置重试间隔时间</span><br><span class="line"></span><br><span class="line">    --retry-max-time &lt;seconds&gt;  传输出现问题时，设置最大重试时间</span><br><span class="line"></span><br><span class="line">-s/--silent  静默模式。不输出任何东西</span><br><span class="line"></span><br><span class="line">-S/--show-error  显示错误</span><br><span class="line"></span><br><span class="line">    --socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口</span><br><span class="line"></span><br><span class="line">    --socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口</span><br><span class="line"></span><br><span class="line">    --stderr &lt;file&gt;</span><br><span class="line"></span><br><span class="line">-x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理</span><br><span class="line"></span><br><span class="line">-X/--request &lt;command&gt; 指定什么命令。curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。</span><br><span class="line"></span><br><span class="line">-T/--upload-file &lt;file&gt; 指定上传文件路径</span><br></pre></td></tr></table></figure>


<p>更多内容查看：</p>
<ul>
<li><strong><a href="https://curl.se/docs/manpage.html">curl 用户手册</a></strong></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://www.ruanyifeng.com/blog/2011/09/curl.html">curl网站开发指南</a></strong></p>
</li>
<li><p><strong><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a></strong></p>
</li>
<li><p><strong><a href="https://handerfly.github.io/linux/2019/05/26/curl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">curl命令详解</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>命令行工具</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell</title>
    <url>/post/d2af6ed9/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Xshell</strong>是<a href="https://zh.wikipedia.org/w/index.php?title=Netsarang_Computer&action=edit&redlink=1">Netsarang Computer</a>推出的<a href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell</a>、<a href="https://zh.wikipedia.org/wiki/Telnet">Telnet</a>和<a href="https://zh.wikipedia.org/w/index.php?title=Rlogin&action=edit&redlink=1">Rlogin</a><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF">虚拟终端</a>。Xshell可以为每个<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F">主机</a>创建单独的<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">会话</a>，用户可以通过标签查看每个会话，方便同时操作和管理与主机的会话。</p>
<span id="more"></span>
<blockquote>
<p>Xshell 7（win系统）是一个用于MS Windows平台的强大的SSH、TELNET和RLOGIN终端仿真软件。它使得用户能轻松和安全地从Windows PC上访问UNIX/Linux主机。简单地说，X shell就是一个<strong>终端模拟软件</strong>，就是模拟服务器所在的linux，在Xshell中可以输入命令，就像在服务器的linux中输入命令一样，从而实现远程控制服务器。</p>
</blockquote>
<p><a href="https://www.netsarang.com/en/xshell-download/">官网下载地址</a></p>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol>
<li><p>下载Xftp并安装后出现如下界面</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213221603368.png"></p>
</li>
<li><p><strong>点击文件 -&gt; 新建</strong> 或者 如下图所示的<strong>图标</strong></p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213221708340.png"></p>
</li>
<li><p>输入相关信息</p>
<ul>
<li>名称：随便填写即可</li>
<li>主机：服务器的IP地址</li>
<li>端口号：就是你空间的端口号ssh port，一般VPS服务器的端口是22</li>
</ul>
<p>其他都默认不填，填好后点击左侧的用户身份验证</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213221954187.png" style="zoom: 75%;" /></li>
<li><p>在用户身份验证这一块填写你的服务器的用户名和密码。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213222425089.png" style="zoom:75%;" /></li>
<li><p>第一次进入时出现SSH安全警告弹框，可以选择“一次性接受”或者“接受并保存”；点击接受并保存，出现如下界面则表示连接成功。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213222627909.png"></p>
</li>
</ol>
<blockquote>
<p>备注：Linux的<strong>IP</strong>地址的<strong>查询方法</strong>为在Linux终端输入 <code>ifconfig</code> 命令并回车即可。</p>
</blockquote>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220213220257354.png" style="zoom:80%;" />



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><strong><a href="https://cloud.tencent.com/developer/article/1822579">Xshell怎么用？详细的Xshell使用教程</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/post/2633a26/</url>
    <content><![CDATA[<h2 id="常用的位操作"><a href="#常用的位操作" class="headerlink" title="常用的位操作"></a>常用的位操作</h2><ol>
<li><p><strong>利用或操作 <code>|</code> 和空格将英文字符转换为小写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;b&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">(<span class="string">&#x27;B&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p><strong>利用异或操作 <code>^</code> 和空格进行英文字符大小写互换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">(<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。</p>
</li>
<li><p><strong>判断两个数是否异号</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = -<span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">bool f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">2</span>;</span><br><span class="line">bool f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。</p>
</li>
<li><p><strong>不用临时变量交换两个数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"><span class="comment">// 现在 a = 2, b = 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>加一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">n = -~n;</span><br><span class="line"><span class="comment">// 现在 n = 2</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>减一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">n = ~-n;</span><br><span class="line"><span class="comment">// 现在 n = 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。</p>
</blockquote>
</li>
</ol>
<p>详细理解参见 <a href="https://labuladong.gitee.io/algo/4/30/116/">常用的位操作</a> 评论区</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/post/91a7e4d1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过同向移动（<strong>快慢指针</strong>）或相向移动（<strong>对撞指针</strong>）来维护、统计信息，从而达到相应的目的。</p>
<p>双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决一些特定问题，和其他算法结合也能发挥多样的用处。</p>
<span id="more"></span>


<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p><strong>对撞指针</strong>是指在有序数组中，将指向最左侧的索引定义为**左指针(left)<strong>，最右侧的定义为</strong>右指针(right)**，然后从两头向中间进行数组遍历。</p>
<blockquote>
<p>对撞指针适用于<strong>有序数组</strong>，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。</p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></td>
<td><a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/">画解算法：15. 三数之和</a><br/><a href="https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/">官方题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></td>
<td><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">下一个排列算法详解：思路+推导+步骤，看不懂算我输！</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></td>
<td><a href="https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/">颜色分类</a><br/><a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/">快速排序的子过程 partition（重点在设计循环不变量）</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></td>
<td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/si-lu-qing-xi-ming-liao-kan-bu-dong-bu-cun-zai-de-/">思路清晰明了，看不懂？？不存在的！！</a><br/><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/">官方题解</a></td>
</tr>
</tbody></table>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>快慢指针</strong>也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为<strong>快指针(fast)</strong> 和**慢指针(slow)**，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 <code>fast</code> 每次增长两个，<code>slow</code> 每次增长一个。</p>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
<th>技巧</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/">160. 相交链表（双指针，清晰图解）</a><br/><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">官方题解</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></td>
<td><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/">Sort List （归并排序链表）</a><br/><a href="https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/">官方题解</a></td>
<td>链表等长拆分、归并排序</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当遇到有序数组时，应该优先想到<strong>双指针</strong>来解决问题，因两个指针的同时遍历会减少空间复杂度和时间复杂度。</p>
<p><strong>对撞指针</strong>主要解决数组（或者字符串）中的问题，比如二分查找；<strong>快慢指针</strong>主要解决链表中的问题，比如典型的判定链表中是否包含环。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/post/9947c71c/</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以在一个升序数组中查找一个数为例。</p>
<p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p>
<span id="more"></span>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>时间复杂度</strong></p>
<ul>
<li>二分查找的最优时间复杂度为 O(1)。</li>
<li>二分查找的平均时间复杂度和最坏时间复杂度均为 O(logn)。因为在二分搜索过程中，算法每次都把查询的区间减半，所以对于一个长度为 的数组，至多会进行 O(logn)次查找。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<ul>
<li>迭代版本的二分查找的空间复杂度为 O(1)。</li>
<li>递归（无尾调用消除）版本的二分查找的空间复杂度为 O(logn)。</li>
</ul>
<h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了“二分答案”。</p>
<h3 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h3><p>最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。深入细节，比如不等号是否应该带等号，<code>mid</code> 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p>另外声明一下，计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p>
<h4 id="寻找一个数（基本的二分搜索）"><a href="#寻找一个数（基本的二分搜索）" class="headerlink" title="寻找一个数（基本的二分搜索）"></a>寻找一个数（基本的二分搜索）</h4><p>搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;？</strong></p>
<p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p>
<p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid; </span><br></pre></td></tr></table></figure>

<p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</strong></p>
<p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p>
<p>刚才明确了<strong>「搜索区间」</strong>这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p>
<p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？<strong>因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除</strong>。</p>
<p><strong>3、此算法有什么缺陷？</strong></p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见，<strong>你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p>
<p>后续的算法就来讨论这两种二分查找的算法。</p>
<h4 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h4><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 中是 <code>&lt;</code> 而不是 <code>&lt;=</code>?</strong></p>
<p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p>
<p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p>
<blockquote>
<p>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：<strong>刚才的 <code>right</code> 不是 <code>nums.length - 1</code> 吗，为啥这里非要写成 <code>nums.length</code> 使得「搜索区间」变成左闭右开呢</strong>？</p>
</blockquote>
<p>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。</p>
<p><strong>2、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p>
<p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220225215952439.png" style="zoom: 45%;" />

<p>对于这个数组，算法会返回索引 1。</p>
<p>这个索引 1 的含义可以解读为「<code>nums</code> 中小于 2 的元素有 1 个」。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<blockquote>
<p>PS：对于 <code>target</code> 不存在 <code>nums</code> 中的情况，函数的返回值还可以有多种理解方式，详见 <a href="https://labuladong.github.io/algo/2/21/66/">随机权重算法</a> 中对二分搜索的运用。</p>
</blockquote>
<p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样？</strong></p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p>
<p><strong>4、为什么该算法能够搜索左侧边界</strong>？</p>
<p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure>

<p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p><strong>5、为什么返回 <code>left</code> 而不是 <code>right</code>？</strong></p>
<p>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p>
<p><strong>6、能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了</strong>。</p>
<p>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：</p>
<p>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="comment">// 收缩右侧边界</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220225221026390.png" style="zoom:45%;" />

<p>因此，最后返回结果的代码应该检查越界情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>

<p>至此，整个算法就写完了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p>
<h4 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h4><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么这个算法能够找到右侧边界？</strong></p>
<p>答：类似地，关键点还是这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p>
<p><strong>2、为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对</strong>。</p>
<p>答：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p>
<p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226112725552.png" style="zoom:45%;" />

<p>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p>
<p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，同左侧边界搜索，就不再赘述。</p>
<p><strong>3、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</strong></p>
<p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 <code>[0, nums.length]</code>，所以可以添加两行代码，正确地返回 -1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? (left-<span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。</strong></p>
<p>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界的情况，见下图</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>target</code> 比所有元素都小时，<code>right</code> 会被减到 -1，所以需要在最后防止越界：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226142140238.png" style="zoom:45%;" />

<p>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p>
<h4 id="逻辑统一"><a href="#逻辑统一" class="headerlink" title="逻辑统一"></a>逻辑统一</h4><p>接下来梳理一下这些细节差异的因果逻辑：</p>
<p><strong>第一个，最基本的二分查找算法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure>

<p><strong>第二个，寻找左侧边界的二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>

<p><strong>第三个，寻找右侧边界的二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure>

<p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，<strong>我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过本文，你学会了：</p>
<p>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p>
<p>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p>
<p>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一。</p>
<p>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code> 条件处的代码和返回的逻辑即可，<strong>推荐拿小本本记下，作为二分搜索模板</strong>。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></td>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/duo-si-lu-wan-quan-gong-lue-bi-xu-miao-dong-by-swe/">多思路完全攻略，🤷‍♀️必须秒懂！</a><br/><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/">极简 Solution</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></td>
<td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-so-9hcx/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-4/">详细通俗的思路分析，多解法</a></td>
</tr>
</tbody></table>
<h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>三分法可以用来查找凸函数的最大（小）值。</p>
<ul>
<li>如果 <code>lmid</code> 和 <code>rmid</code> 在最大（小）值的同一侧：由于单调性，一定是二者中较大（小）的那个离最值近一些，较远的那个点对应的区间不可能包含最值，所以可以舍弃。</li>
<li>如果在两侧：由于最值在二者中间，我们舍弃两侧的一个区间后，也不会影响最值，所以可以舍弃。</li>
</ul>
<p><strong>二分法</strong>最基本的应用是求一个<strong>单调函数</strong>的<strong>零点</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226160426232.png" style="zoom: 65%;" />

<p><strong>三分法</strong>是二分法的变种，他最基本的用途是求<strong>单峰函数</strong>的<strong>极值点</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226160507296.png" style="zoom:65%;" />

<p>从数学的角度来说，求极值点，先<strong>求导</strong>再<strong>二分</strong>不就好了吗？然而，实际中我们遇到的函数，求导可能很困难，所以会用上三分法。而三分法的原理非常简单，以求极大值为例，每次对一个区间 <code>[l,r] </code>求三等分点 <code>lsec</code> 和 <code>rsec</code>：</p>
<ul>
<li><p>如果 <code>f(lsec) &lt; f(rsec)</code> ，说明极大值一定在 <code>[lsec,r]</code> 内取到，因为如果在 <code>[0,lsec)</code> 内，那 <code>rsec</code> 一定处于单调下降的区间内，它的函数值不可能大于 <code>lsec</code> 的函数值。 于是我们令 <code>l=lsec</code> 并继续。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226160605736.png" style="zoom:65%;" /></li>
<li><p>如果<code>f(lsec) &gt; f(rsec)</code>，同理，极大值一定在<code>[l,rsec]</code>内取到，令<code>r=rsec</code>并继续。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220226160712468.png" style="zoom:65%;" /></li>
</ul>
<p>这样进行下去，直到<code>l</code>和<code>r</code>的差距小于设定的<code>eps</code>为止。如果求的是极小值而非极大值，只需把上面条件判断处的大于、小于互换。</p>
<p>按照上面的算法，我们每次减少三分之一的长度。但其实还可以优化，即每次在中点附近取点，那么每次可以减少约二分之一的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> fl = f(mid - eps), fr = f(mid + eps);</span><br><span class="line">    <span class="keyword">if</span> (fl &lt; fr)</span><br><span class="line">        l = mid; <span class="comment">// 这里不写成mid - eps，防止死循环；可能会错过极值，但在误差范围以内所以没关系</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的三分，其实和普通的二分很像了。</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a></td>
<td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/solution/gong-shui-san-xie-er-fen-san-fen-cha-zhi-5gfv/">【宫水三叶】二分 &amp; 三分极值问题</a></td>
</tr>
</tbody></table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://labuladong.gitee.io/algo/2/21/61/">我写了首诗，让你闭着眼睛也能写对二分搜索</a></strong></p>
</li>
<li><p><strong><a href="https://zhuanlan.zhihu.com/p/337752413">算法学习笔记(62): 三分法</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串反转</title>
    <url>/post/8de7ec78/</url>
    <content><![CDATA[<p><strong>1、用stringBuffer或者stringBuilder自带的reverse方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、将字符串拆分为char数组后使用 <a href="https://feyl.github.io/post/2633a26/">不用临时变量交换两个数技巧</a> 依次顺序交换前后两个字符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = charArray.length - <span class="number">1</span>; l &lt; r; l++, r--) &#123;</span><br><span class="line">        charArray[l] ^= charArray[r];<span class="comment">//采用异或</span></span><br><span class="line">        charArray[r] ^= charArray[l];</span><br><span class="line">        charArray[l] ^= charArray[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>3、stringBuffer倒序拼接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sb.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、利用栈的先进后出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    Stack stk = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        stk.push(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">        sb.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、切割递归反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(s.substring(<span class="number">1</span>)) + s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、二分递归反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    String l = s.substring(<span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">    String r = s.substring(n / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> reverse(r) + reverse(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/post/f92eff5d/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯算法</a> 实际上一个<strong>类似枚举的搜索尝试过程</strong>，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“<strong>通用解题方法</strong>”的美称。</p>
<span id="more"></span>
<h3 id="与穷举的联系"><a href="#与穷举的联系" class="headerlink" title="与穷举的联系"></a>与穷举的联系</h3><p>回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。</p>
<p>回溯法的特点是<strong>深度优先遍历</strong>，也就是该问题的遍历顺序是1-&gt;2-&gt;3，然后从子节点3返回，从子节点2返回，再到1-&gt;3-&gt;2，以此类推。</p>
<p>状态的返回只有当前的节点不再满足问题的条件或者我们已经找到了问题的一个解时，才会返回，否则会以深度优先一直在<strong>解空间树</strong>内遍历下去。</p>
<p>当然，对于某些问题如果其解空间过大，即使用回溯法进行计算也有很高的时间复杂度，因为回溯法会尝试解空间树中所有的分支。</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>所以根据这类问题，有一些优化剪枝策略以及启发式搜索策略。</p>
<p><strong>优化剪枝策略</strong>：判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</p>
<p><strong>启发式搜索策略</strong>：给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</p>
<h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>回溯算法也叫<strong>试探法</strong>，它是一种系统地搜索问题的解的方法。</p>
<p>用回溯算法解决问题的一般步骤：</p>
<ol>
<li><strong>针对</strong>所给<strong>问题</strong>，<strong>定义问题的解空间</strong>，它至少包含问题的一个（最优）解。</li>
<li><strong>确定</strong>易于搜索的<strong>解空间结构</strong>，使得能用回溯法方便地搜索整个解空间 。</li>
<li><strong>以深度优先的方式搜索解空间</strong>，并且在<strong>搜索过程中</strong>用<strong>剪枝</strong>函数避免无效搜索。</li>
</ol>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。<br><strong>回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</strong></p>
<p>回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的的搜索算法。</p>
<p>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。<br>算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。<br>如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。<br>否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。<br>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</p>
<p>这种以<strong>深度优先</strong>的方式<strong>系统地搜索</strong>问题的解的算法称为回溯法，它适用于解一些<strong>组合数较大的问题</strong>。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td>
<td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">通俗易懂+动画演示 17. 电话号码的字母组合</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td>
<td><a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">回溯算法 + 剪枝（回溯经典例题详解）</a><br/><a href="https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-feyl-lj9e/">回溯 + 剪枝</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></td>
<td><a href="https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/">回溯算法（Java）</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></td>
<td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/">回溯算法、优化（使用动态规划预处理数组）</a></td>
</tr>
</tbody></table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-backtracking">五大基本算法之回溯算法 backtracking</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集</title>
    <url>/post/6b44eb7a/</url>
    <content><![CDATA[<h2 id="何为字符集？"><a href="#何为字符集？" class="headerlink" title="何为字符集？"></a>何为字符集？</h2><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>
<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>
<p>我们要将这些字符和二级制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。</p>
<p>将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>
<span id="more"></span>


<h2 id="有哪些常见的字符集？"><a href="#有哪些常见的字符集？" class="headerlink" title="有哪些常见的字符集？"></a>有哪些常见的字符集？</h2><p>常见的字符集有 ASCII、GB2312、GBK、UTF-8……。</p>
<p>不同的字符集的主要区别在于：</p>
<ul>
<li>可以表示的字符范围</li>
<li>编码方式</li>
</ul>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>
<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>
<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 <strong>128（2^7）</strong>个字符。</p>
<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 <strong>256（2^8）</strong>个字符。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" alt="ASCII字符编码"></p>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>
<p><strong>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</strong></p>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>
<blockquote>
<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>
</blockquote>
<h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>
<h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>
<h3 id="Unicode-amp-UTF-8编码"><a href="#Unicode-amp-UTF-8编码" class="headerlink" title="Unicode &amp; UTF-8编码"></a>Unicode &amp; UTF-8编码</h3><p>为了更加适合本国语言，诞生了很多种字符集。</p>
<p>不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>
<p>就比如说使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>
<p>可以通过这个网站在线进行编码和解码：<a href="https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan">https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</a></p>
<p>乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>
<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>
<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>
<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>
<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>
<p>UTF-8 使用 <strong>1</strong> 到 <strong>4</strong> 个字节为每个字符编码， UTF-16 使用 <strong>2</strong> 或 <strong>4</strong> 个字节为每个字符编码，UTF-32 <strong>固定位 4</strong> 个字节为每个字符编码。</p>
<p><strong>UTF-8 可以根据不同的符号自动选择编码的长短</strong>，像<strong>英文字符只需要 1 个字节</strong>就够了，这一点 ASCII 字符集一样 。因此，<strong>对于英语字符，UTF-8 编码和 ASCII 码是相同的</strong>。</p>
<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>
<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220121232511210.png"></p>
<h2 id="MySQL-字符集"><a href="#MySQL-字符集" class="headerlink" title="MySQL 字符集"></a>MySQL 字符集</h2><p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5… 可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220121232441500.png"></p>
<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>
<p>不过，这里有一个小坑。</p>
<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>
<ul>
<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>
<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>
</ul>
<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：<br>        MySQL字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4，其中 utf8 是一个字最多占据3字节空间的编码实现；而 utf8mb4 则是一个字最多占据4字节空间的编码实现，也就是 UTF-8 的完整实现。这是由于 MySQL 在 4.1 版本开始支持 UTF-8 编码（当时参考 UTF-8草案版本为 RFC 2279）时，为2003年，并且在同年 9 月限制了其实现的 UTF-8 编码的空间占用最多为 3 字节，而 UTF-8 正式形成标准化文档(RFC 3629)是其之后。限制 UTF-8 编码实现的编码空间占用一般被认为是考虑到数据库文件设计的兼容性和读取最优化，但实际上并没有达到目的，而且在 UTF-8 编码开始出现需要存入非基本多文种平面的 Unicode 字符（例如 emoj 字符）时导致无法存入（由于 3 字节的实现只能存入基本多文种平面内的字符）。直到 2010 年在 5.5 版本推出 utf8mb4 来代替，utf8 重命名为 utf8mb3 并调整 utf8 为 utf8mb3 的别名，并不建议使用旧 utf8 编码，以此修正遗留问题。</p>
<p>因此，如果你需要存储 <code>emoji</code> 类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为 <code>utf8mb4</code>  而不是 <code>utf8</code>  ，要不然存储的时候就会报错了。</p>
<p>演示一下吧！（环境：MySQL 5.7+）</p>
<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">66</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`, `name`, `phone`, `password`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">&#x27;A00003&#x27;</span>, <span class="string">&#x27;guide哥😘😘😘&#x27;</span>, <span class="string">&#x27;181631312312&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Incorrect string value: &#x27;\xF0\x9F\x98\x98\xF0\x9F...&#x27; for column &#x27;name&#x27; at row 1</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://javaguide.cn/database/character-set.html">字符集</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/post/c517589e/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>（Union-Find）算法，主要是解决图论中「动态连通性」问题的。</p>
<span id="more"></span>
<h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308201546816.png" style="zoom: 50%;" />

<p>现在我们的 Union-Find 算法主要需要实现这两个 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<p>1、自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</p>
<p>2、对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</p>
<p>3、传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</p>
<p>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用 <code>connected</code> 都会返回 false，连通分量为 10 个。</p>
<p>如果现在调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p>
<p>再调用 <code>union(1, 2)</code>，这时 0,1,2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 true，连通分量变为 8 个。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308202001991.png" style="zoom:50%;" />

<p>判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p>
<p>这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于 <code>union</code> 和 <code>connected</code> 函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p>
<p>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308202256112.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308202948679.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// parent[rootQ] = rootP 也一样</span></span><br><span class="line">    count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样，如果节点 <code>p</code> 和 <code>q</code> 连通的话，它们一定拥有相同的根节点</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308203121661.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！</p>
<p>那么这个算法的复杂度是多少呢？我们发现，主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。</p>
<p><code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308203229510.png" style="zoom:50%;" />

<p>所以说上面这种解法，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 <code>union</code> 和 <code>connected</code> 的调用非常频繁，每次调用需要线性时间完全不可忍受。</p>
<p><strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？只需要略施小计即可。</p>
<h2 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h2><p>我们要知道哪种情况下可能出现不平衡现象，关键在于 <code>union</code> 过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// parent[rootQ] = rootP 也可以</span></span><br><span class="line">    count--;</span><br></pre></td></tr></table></figure>

<p>我们一开始就是简单粗暴的把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308203354782.png" style="zoom:50%;" />

<p>长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的那棵树，总共有 <code>5</code> 个节点。这样我们可以修改一下 <code>union</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。</p>
<p>此时，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p>
<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220308203547566.png" style="zoom:50%;" />

<p>这样 <code>find</code> 就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 O(1)。</p>
<p>要做到这一点，非常简单，只需要在 <code>find</code> 中加一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        <span class="comment">// 进行路径压缩</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：</p>
<img src="https://labuladong.github.io/algo/images/unionfind/9.gif" style="zoom: 50%;" />

<p>可见，调用 <code>find</code> 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（<code>union</code> 的时候树高可能达到 3），树高为常数，那么所有方法的复杂度也就都是 O(1)。</p>
<blockquote>
<p>PS：读者可能会问，这个 GIF 图的 <code>find</code> 过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次 <code>find</code> 都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p>
</blockquote>
<p><strong>当然，如果路径压缩技巧将树高保持为常数了，那么 <code>size</code> 数组的平衡化优化就不是特别必要了</strong>。</p>
<p>你一般看到的 Union Find 算法应该是使用路径压缩的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点 x 的连通分量根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 进行路径压缩</span></span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 O(1)。</p>
<p>到这里，相信你已经掌握了 Union-Find 算法的核心逻辑，总结一下我们优化算法的过程：</p>
<p>1、用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。</p>
<p>2、用 <code>size</code> 数组记录着每棵树的重量，目的是让 <code>union</code> 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。</p>
<p>3、在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 <code>size</code> 数组的平衡优化。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></td>
<td><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">官方题解</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/solution/by-feyl-gshx/">200. 岛屿数量</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手</a></td>
<td><a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6/">【宫水三叶の相信科学系列】为什么交换任意一个都是对的？两种 100% 的解法：并查集 &amp; 贪心</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td>
<td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">【宫水三叶】一题双解：「Kruskal &amp; 并查集」&amp;「二分 &amp; BFS」解法</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a></td>
<td><a href="https://leetcode-cn.com/problems/number-of-enclaves/solution/gong-shui-san-xie-bing-cha-ji-dfs-yun-yo-oyh1/">【宫水三叶】一题双解 :「并查集 + DFS」&amp;「多源 BFS」</a></td>
</tr>
</tbody></table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://labuladong.gitee.io/algo/2/20/39/">并查集（UNION-FIND）算法详解</a></strong></p>
</li>
<li><p><strong><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud</title>
    <url>/post/750d7523/</url>
    <content><![CDATA[<h2 id="微服务架构理论入门"><a href="#微服务架构理论入门" class="headerlink" title="微服务架构理论入门"></a>微服务架构理论入门</h2><p><strong>什么是微服务？</strong></p>
<blockquote>
<p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.    ——James Lewis and Martin Fowler (2014)</p>
</blockquote>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务</a>是一种架构风格</li>
<li>一个应用拆分为一组小型服务</li>
<li>每个服务运行在自己的进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级HTTP交互</li>
<li>服务围绕业务功能拆分</li>
<li>可以由全自动部署机制独立部署</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术<span id="more"></span></li>
<li><em>分布式微服务架构-落地维度</em>*</li>
</ul>
<p>满足哪些维度？支撑起这些维度的具体技术？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219205711379.png" style="zoom: 75%;" />

<ul>
<li>服务注册与发现</li>
<li>服务调用</li>
<li>服务降级</li>
<li>服务熔断</li>
<li>负载均衡</li>
<li>服务消息队列</li>
<li>服务网关</li>
<li>配置中心管理</li>
<li>自动化构建部署</li>
<li>服务监控</li>
<li>全链路追踪</li>
<li>服务定时任务</li>
<li>调度操作</li>
</ul>
<p><strong>Spring Cloud简介</strong></p>
<p>是什么？符合微服务技术维度</p>
<p><strong>SpringCloud=分布式微服务架构的站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</strong></p>
<p>SpringCloud这个大集合里有多少种技术?</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219210326155.png" style="zoom:80%;" />

<p><strong>“微”力十足，互联网大厂微服务架构案例</strong></p>
<p>京东：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219210449512.png" style="zoom:80%;" />

<p>阿里：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219210554616.png" style="zoom:80%;" />

<p>京东物流：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219210729775.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219210840131.png" style="zoom:80%;" />

<p><strong>Spring Cloud技术栈</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219211454201.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219211539602.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219211703640.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220215035410.png" style="zoom:80%;" />

<h2 id="Boot和Cloud版本选型"><a href="#Boot和Cloud版本选型" class="headerlink" title="Boot和Cloud版本选型"></a>Boot和Cloud版本选型</h2><p>Spring Boot 2.X 版</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/releases/">源码地址</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/wiki/spring-Boot-2.0-Release-Notes">Spring Boot 2 的新特性</a></li>
<li>通过上面官网发现，Boot官方<strong>强烈建议</strong>你升级到2.X以上版本</li>
</ul>
<p>Spring Cloud H版</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-cloud">源码地址</a></li>
<li><a href="https://spring.io/projects/spring-cloud">官网</a></li>
</ul>
<blockquote>
<p>SpringCloud 命名规则：</p>
<p>SpringCloud的版本关系<br>Spring Cloud采用了英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代版本<br>SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。例如Angel是第一个版本，Brixton是第二个版本。<br>当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。</p>
</blockquote>
<p>Spring Boot 与 Spring Cloud 兼容性查看</p>
<ul>
<li><a href="https://spring.io/projects/spring-cloud#adding-spring-cloud-to-an-existing-spring-boot-application">文档</a></li>
<li><a href="https://start.spring.io/actuator/info">JSON接口</a></li>
</ul>
<p>接下来开发用到的组件版本</p>
<ul>
<li>Cloud - Hoxton.SR1</li>
<li>Boot - 2.2.2.RELEASE</li>
<li>Cloud Alibaba - 2.1.0.RELEASE</li>
<li>Java - Java 8</li>
<li>Maven - 3.5及以上</li>
<li>MySQL - 5.7及以上</li>
</ul>
<h2 id="Cloud组件停更说明"><a href="#Cloud组件停更说明" class="headerlink" title="Cloud组件停更说明"></a>Cloud组件停更说明</h2><p>停更引发的“升级惨案”</p>
<ul>
<li>停更不停用</li>
<li>被动修复bugs</li>
<li>不再接受合并请求</li>
<li>不再发布新版本</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219211808880.png" style="zoom:80%;" />

<p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">Spring Cloud官方文档</a></p>
<p><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">Spring Cloud中文文档</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">Spring Boot官方文档</a></p>
<h2 id="微服务架构编码构建"><a href="#微服务架构编码构建" class="headerlink" title="微服务架构编码构建"></a>微服务架构编码构建</h2><h3 id="父工程Project空间新建"><a href="#父工程Project空间新建" class="headerlink" title="父工程Project空间新建"></a>父工程Project空间新建</h3><p>约定 &gt; 配置 &gt; 编码</p>
<p>创建微服务cloud整体聚合父工程Project，有8个关键步骤：</p>
<ol>
<li>New Project - maven工程 - create from archetype: maven-archetype-site</li>
<li>聚合总父工程名字</li>
<li>Maven选版本</li>
<li>工程名字</li>
<li>字符编码 - Settings - File encoding</li>
<li>注解生效激活 - Settings - Annotation Processors - Enable annotation processing</li>
<li>Java编译版本 - Java Compiler - Module - Target bytecode version (8)</li>
<li>File Type过滤 - Settings - Editor - File Types - .gitignore</li>
</ol>
<blockquote>
<p>archetype 英 [ˈɑːkitaɪp] 美 [ˈɑːrkitaɪp]<br>n. 典型</p>
<p>site 英 [saɪt] 美 [saɪt]<br>n. (建筑物、城镇等的)地点，位置，建筑工地;现场;发生地;场所;网站;站点<br>v. 使坐落在;为…选址</p>
</blockquote>
<h3 id="父工程pom文件"><a href="#父工程pom文件" class="headerlink" title="父工程pom文件"></a>父工程pom文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span><span class="comment">&lt;!-- 这里添加，注意不是jar或war --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 统一管理jar包版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 子模块继承之后，提供作用：</span></span><br><span class="line"><span class="comment">		锁定版本+子modlue不用写groupId和version --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复习DependencyManagement和Dependencies"><a href="#复习DependencyManagement和Dependencies" class="headerlink" title="复习DependencyManagement和Dependencies"></a>复习DependencyManagement和Dependencies</h3><p>Maven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。</p>
<p>通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元素。</p>
<p>使用pom.xml中的dependencyManagement元素能让所有在子项目中引用个依赖而不用显式的列出版本量。</p>
<p>Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysq1<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在子项目里就可以添加<code>mysql-connector</code>时可以不指定版本号，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysq1<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改；另外如果某个子项目需要另外的一个版本，只需要声明version就可。</p>
<ul>
<li>dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</li>
<li>如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。</li>
<li>如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</li>
</ul>
<p>IDEA右侧旁的Maven插件有<code>Toggle &#39; Skip Tests&#39; Mode</code>按钮，这样maven可以跳过单元测试</p>
<p>父工程创建完成执行 <code>mvn : install</code> 将父工程发布到仓库方便子工程继承。</p>
<h3 id="支付模块构建"><a href="#支付模块构建" class="headerlink" title="支付模块构建"></a>支付模块构建</h3><p>创建微服务模块套路：</p>
<ol>
<li>建Module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219213252161.png" style="zoom:80%;" />

<p>创建cloud-provider-payment8001微服务提供者支付Module模块：</p>
<ol>
<li><p>建名为cloud-provider-payment8001的Maven工程</p>
</li>
<li><p>改POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>            <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>             <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/my?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.lun.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain001</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `payment`(</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">    `serial` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br></pre></td></tr></table></figure>

<p>Entities：</p>
<p>实体类Payment：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON封装体CommonResult：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DAO：</p>
<p>接口PaymentDao：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="comment">//@Repository不用Spring的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis映射文件PaymentMapper.xml，路径：resources/mapper/PaymentMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lun.springcloud.dao.PaymentDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Payment&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into payment(serial)  values(#&#123;serial&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lun.springcloud.entities.Payment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">property</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getPaymentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from payment where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Service：</p>
<p>接口PaymentService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.dao.PaymentDao;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentDao paymentDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;*****插入结果：&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;插入数据库成功,serverPort: &quot;</span>+serverPort,result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;插入数据库失败&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        Payment payment = paymentService.getPaymentById(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(payment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;查询成功,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;没有对应记录,查询ID: &quot;</span>+id,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ul>
<li>浏览器 - <a href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a></li>
<li>Postman - <a href="http://localhost:8001/payment/create?serial=lun2">http://localhost:8001/payment/create?serial=lun2</a></li>
</ul>
</li>
<li><p>小总结</p>
<p>创建微服务模块套路：</p>
<ol>
<li>建Module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类</li>
</ol>
</li>
</ol>
<h3 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h3><p><strong>开发时使用，生产环境关闭</strong></p>
<ol>
<li><p><strong>Adding devtools to your project</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Adding plugin to your pom.xml</strong></p>
<p>下段配置复制到聚合父类总工程的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	&lt;finalName&gt;你的工程名&lt;/finalName&gt;（单一工程时添加）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Enabling automatic build</strong></p>
<p>File -&gt; Settings(New Project Settings -&gt; Settings for New Projects) -&gt; Complier</p>
<p>下面项勾选</p>
<ul>
<li>Automatically show first error in editor</li>
<li>Display notification on build completion</li>
<li>Build project automatically</li>
<li>Compile independent modules in parallel</li>
</ul>
</li>
<li><p><strong>Update the value of</strong></p>
<p>键入Ctrl + Shift + Alt + / ，打开Registry，勾选：</p>
<ul>
<li>compiler.automake.allow.when.app.running</li>
<li>actionSystem.assertFocusAccessFromEdt</li>
</ul>
</li>
<li><p>重启<strong>IDEA</strong></p>
</li>
</ol>
<h3 id="消费者订单模块"><a href="#消费者订单模块" class="headerlink" title="消费者订单模块"></a>消费者订单模块</h3><ol>
<li><p>建Module</p>
<p>创建名为cloud-consumer-order80的maven工程。</p>
</li>
<li><p>改POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>写YML</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">80</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>运行cloud-consumer-order80与cloud-provider-payment8001两工程</p>
<ul>
<li>浏览器 - <a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></li>
</ul>
<p><strong>RestTemplate</strong></p>
<p>RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集</p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">官网地址</a></p>
<p>使用：</p>
<ul>
<li>使用restTemplate访问restful接口非常的简单粗暴无脑。</li>
<li><code>(url, requestMap, ResponseBean.class)</code>这三个参数分别代表。</li>
<li>REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</li>
</ul>
</li>
</ol>
<p>浏览器 - <a href="http://localhost/consumer/payment/create?serial=lun3">http://localhost/consumer/payment/create?serial=lun3</a></p>
<p>虽然，返回成功，但是观测数据库中，并没有创建serial为lun3的行。</p>
<p>解决之道：在loud-provider-payment8001工程的PaymentController中添加@RequestBody注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span><span class="comment">/*添加到这里*/</span> Payment payment)</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口（这个用来显示哪些Spring Boot工程运行，停止等信息。我idea 2020.1版本在名为Services窗口就可以显示哪些Spring Boot工程运行，停止等信息出来，所以这仅作记录参考）。</p>
<p><strong>开启Run DashBoard</strong></p>
<ol>
<li><p>打开工程路径下的.idea文件夹的workspace.xml</p>
</li>
<li><p>在<code>&lt;component name=&quot;RunDashboard&quot;&gt;</code>中修改或添加以下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于idea版本差异，可能需要关闭重启。</p>
</li>
</ol>
<h3 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h3><p>观察cloud-consumer-order80与cloud-provider-payment8001两工程有重复代码（entities包下的实体），重构。</p>
<ol>
<li><p>新建 - cloud-api-commons</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>entities</p>
<p>将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下。</p>
</li>
<li><p>maven clean、install cloud-api-commons工程，以供给cloud-consumer-order80与cloud-provider-payment8001两工程调用。</p>
</li>
<li><p>订单80和支付8001分别改造</p>
<ul>
<li><p>将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除</p>
</li>
<li><p>引入cloud-api-commons依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>什么是服务治理？</strong></p>
<p>Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理</p>
<p>在传统的RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，<strong>管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册</strong>。</p>
<p><strong>什么是服务注册与发现？</strong></p>
<p>Eureka采用了CS的设计架构，Eureka Sever作为<strong>服务注册功能的服务器</strong>，它是<strong>服务注册中心</strong>。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持<strong>心跳连接</strong>。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p>
<p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者/服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何RPC远程框架中，都会有一个注册中心存放服务地址相关信息（接口地址）</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220219222802417.png" style="zoom:80%;" />

<p><strong>Eureka包含两个组件：Eureka Server和Eureka Client</strong></p>
<p>Eureka Server提供服务注册服务</p>
<p>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的<strong>服务注册表</strong>中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p>
<p>EurekaClient通过注册中心进行访问</p>
<p>它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的<strong>负载均衡器</strong>。在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）。</p>
<h3 id="单机Eureka构建步骤"><a href="#单机Eureka构建步骤" class="headerlink" title="单机Eureka构建步骤"></a>单机Eureka构建步骤</h3><h4 id="EurekaServer服务端安装"><a href="#EurekaServer服务端安装" class="headerlink" title="EurekaServer服务端安装"></a>EurekaServer服务端安装</h4><p>IDEA生成eurekaServer端服务注册中心，类似物业公司</p>
<ol>
<li><p>创建名为cloud-eureka-server7001的Maven工程</p>
</li>
<li><p>修改pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka新旧版本 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以前的老版本（2018）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 现在新版本（2020.2）--&gt;</span><span class="comment">&lt;!-- 我们使用最新的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试运行<code>EurekaMain7001</code>，浏览器输入<code>http://localhost:7001/</code>回车，会查看到Spring Eureka服务主页。</p>
</li>
</ol>
<h4 id="支付微服务8001入驻进EurekaServer"><a href="#支付微服务8001入驻进EurekaServer" class="headerlink" title="支付微服务8001入驻进EurekaServer"></a>支付微服务8001入驻进EurekaServer</h4><p>EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。</p>
<ol>
<li><p>修改cloud-provider-payment8001</p>
</li>
<li><p>改POM</p>
<p>添加spring-cloud-starter-netflix-eureka-client依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进Eurekaserver默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//&lt;-----添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ul>
<li><p>启动cloud-provider-payment8001和cloud-eureka-server7001工程。</p>
</li>
<li><p>浏览器输入 - <a href="http://localhost:7001/">http://localhost:7001/</a> 主页内的Instances currently registered with Eureka会显示cloud-provider-payment8001的配置文件application.yml设置的应用名cloud-payment-service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220144608443.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>自我保护机制</p>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。</p>
</li>
</ol>
<h4 id="订单微服务80入驻进EurekaServer"><a href="#订单微服务80入驻进EurekaServer" class="headerlink" title="订单微服务80入驻进EurekaServer"></a>订单微服务80入驻进EurekaServer</h4><p>EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学。</p>
<ol>
<li><p>cloud-consumer-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进Eurekaserver默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//&lt;--- 添加该标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>启动cloud-provider-payment8001、cloud-eureka-server7001和cloud-consumer-order80这三工程。<br>浏览器输入 <a href="http://localhost:7001/">http://localhost:7001</a> , 在主页的Instances currently registered with Eureka将会看到cloud-provider-payment8001、cloud-consumer-order80两个工程名。</p>
</li>
</ol>
<p>注意，<strong>application.yml配置中层次缩进和空格，两者不能少</strong>，否则，会抛出异常 <code>Failed to bind properties under &#39;eureka.client.service-url&#39; to java.util.Map &lt;java.lang.String, java.lang.String&gt;</code> 。</p>
<h3 id="Eureka集群原理说明"><a href="#Eureka集群原理说明" class="headerlink" title="Eureka集群原理说明"></a>Eureka集群原理说明</h3><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220104248783.png" style="zoom:90%;" />

<p>服务注册：将服务信息注册进注册中心</p>
<p>服务发现：从注册中心上获取服务信息</p>
<p>实质：存key服务命取value用地址</p>
<ol>
<li>先启动eureka注主册中心</li>
<li>启动服务提供者payment支付服务</li>
<li>支付服务启动后会把自身信息（比服务地址以别名方式注朋进eureka）</li>
<li>消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址</li>
<li>消去者导调用地址后，底屋实际是利用HttpClient技术实现远程调用</li>
<li>消费者获得服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新—次服务调用地址</li>
</ol>
<p>问题：<strong>微服务RPC远程服务调用最核心的是什么？</strong></p>
<p>高可用，试想你的注册中心只有一个，万一它出故障了，会导致整个为服务环境不可用。</p>
<p>解决办法：搭建Eureka注册中心集群，实现负载均衡 + 故障容错。</p>
<p><strong>互相注册，相互守望</strong>。</p>
<h3 id="Eureka集群环境构建"><a href="#Eureka集群环境构建" class="headerlink" title="Eureka集群环境构建"></a>Eureka集群环境构建</h3><p>创建cloud-eureka-server7002工程，过程参考 EurekaServer服务端安装</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220105136278.png"></p>
<ol>
<li><p>找到C:\Windows\System32\drivers\etc路径下的hosts文件，修改映射配置添加进hosts文件</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">127.0.0.1 eureka7001.com</span><br><span class="line">127.0.0.1 eureka7002.com</span><br></pre></td></tr></table></figure></li>
<li><p>修改cloud-eureka-server7001配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#集群指向其它eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line">    <span class="comment">#单机就是7001自己</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改cloud-eureka-server7002配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#集群指向其它eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line">    <span class="comment">#单机就是7002自己</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>实践的时候，遇到异常情况：在开启cloud-eureka-server7002时，开启失败，说7002端口被占用，然后在cmd中输入 <code>netstat -ano | find &quot;7002&quot;</code>，查不到任何东西。</p>
<p>重启电脑，问题解决。</p>
<h4 id="订单支付两微服务注册进Eureka集群"><a href="#订单支付两微服务注册进Eureka集群" class="headerlink" title="订单支付两微服务注册进Eureka集群"></a>订单支付两微服务注册进Eureka集群</h4><ol>
<li><p>将支付服务8001微服务，订单服务80微服务发布到上面2台Eureka集群配置中</p>
<p>将它们的配置文件的eureka.client.service-url.defaultZone进行修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进Eurekaserver默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ol>
<li>先要启动EurekaServer，7001/7002服务</li>
<li>再要启动服务提供者provider，8001</li>
<li>再要启动消费者，80</li>
<li>浏览器输入 - <a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></li>
</ol>
</li>
</ol>
<h4 id="支付微服务集群配置"><a href="#支付微服务集群配置" class="headerlink" title="支付微服务集群配置"></a>支付微服务集群配置</h4><p><strong>支付服务提供者8001集群环境构建</strong></p>
<p>参考cloud-provicer-payment8001</p>
<ol>
<li><p>新建cloud-provider-payment8002</p>
</li>
<li><p>改POM</p>
</li>
<li><p>写YML - 端口8002</p>
</li>
<li><p>主启动</p>
</li>
<li><p>业务类</p>
</li>
<li><p>修改8001/8002的Controller，添加serverPort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;<span class="comment">//添加serverPort</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;*****插入结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;插入数据库成功,serverPort: &quot;</span>+serverPort<span class="comment">/*添加到此处*/</span>, result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;插入数据库失败&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>负载均衡</strong></p>
<p>cloud-consumer-order80订单服务访问地址不能写死</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span><span class="comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContextBean - 提前说一下Ribbon的负载均衡功能</p>
<p><strong>测试</strong></p>
<ol>
<li>先要启动EurekaServer，7001/7002服务</li>
<li>再要启动服务提供者provider，8001/8002服务</li>
<li>浏览器输入 - <a href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></li>
<li>结果：负载均衡效果达到，8001/8002端口交替出现</li>
<li>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。</li>
</ol>
<p><strong>相互注册，相互守望</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220110326854.png" style="zoom:80%;" />

<h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><p>当前问题：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220110758515.png"></p>
<p>主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）</p>
<p>修改cloud-provider-payment8001，cloud-provider-payment8002</p>
<p>修改部分 - YML - eureka.instance.instance-id</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span> <span class="comment">#添加此处</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span> <span class="comment">#添加此处</span></span><br></pre></td></tr></table></figure>

<p>修改之后</p>
<p>eureka主页将显示payment8001，payment8002代替原来显示的IP地址。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220110901274.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220110936673.png" style="zoom:80%;" />

<p>访问信息有IP信息提示，（就是将鼠标指针移至payment8001，payment8002名下，会有IP地址提示）</p>
<p>修改部分 - YML - eureka.instance.prefer-ip-address</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span> </span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#添加此处</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#添加此处</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220111037544.png" style="zoom:80%;" />

<h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</p>
<ol>
<li><p>修改cloud-provider-payment8001的Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span> (String element : services) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****element: &quot;</span>+element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            log.info(instance.getServiceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+<span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>8001主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain001</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自测</p>
<p>先要启动EurekaServer</p>
<p>再启动8001主启动类，需要稍等一会儿</p>
<p>浏览器输入<a href="http://localhost:8001/payment/discovery">http://localhost:8001/payment/discovery</a></p>
<p>浏览器输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;services&quot;</span>:[<span class="string">&quot;cloud-payment-service&quot;</span>],<span class="attr">&quot;order&quot;</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*****element: cloud-payment-service</span><br><span class="line">CLOUD-PAYMENT-SERVICE	192.168.199.218	8001	http://192.168.199.218:8001</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Eureka自我保护"><a href="#Eureka自我保护" class="headerlink" title="Eureka自我保护"></a>Eureka自我保护</h3><h4 id="Eureka自我保护理论知识"><a href="#Eureka自我保护理论知识" class="headerlink" title="Eureka自我保护理论知识"></a>Eureka自我保护理论知识</h4><p><strong>概述</strong></p>
<p><strong>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护</strong>。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p>
<p>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：</p>
<blockquote>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE</p>
</blockquote>
<p><strong>导致原因</strong></p>
<p>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。</p>
<p>属于CAP里面的AP分支。</p>
<p><strong>为什么会产生Eureka自我保护机制？</strong></p>
<p>为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</p>
<p><strong>什么是自我保护模式？</strong></p>
<p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生（延时、卡顿、拥挤）时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220112323035.png"></p>
<p>自我保护机制∶默认情况下EurekaClient定时向EurekaServer端发送心跳包</p>
<p>如果Eureka在server端在一定时间内（默认90秒）没有收到EurekaClient发送心跳包，便会直接从服务注册列表中剔除该服务，但是在短时间（90秒中）内丢失了大量的服务实例心跳，这时候Eurekaserver会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通但是EurekaClient为出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的）。</p>
<p>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。</p>
<p>它的设计哲学就是<strong>宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例</strong>。</p>
<p>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p>
<h4 id="怎么禁止自我保护"><a href="#怎么禁止自我保护" class="headerlink" title="怎么禁止自我保护"></a>怎么禁止自我保护</h4><ol>
<li><p>在eurekaServer端7001处设置关闭自我保护机制</p>
<p>出厂默认，自我保护机制是开启的</p>
<p>使用 <code>eureka.server.enable-self-preservation = false </code> 可以禁用自我保护模式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#关闭自我保护机制，保证不可用服务被及时踢除</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>关闭效果：</p>
<p>spring-eureka主页会显示出一句：</p>
<blockquote>
<p><strong>THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</strong></p>
</blockquote>
</li>
<li><p>生产者客户端eureakeClient端8001</p>
<ul>
<li><code>eureka.instance.lease-renewal-interval-in-seconds=30</code></li>
<li><code>eureka.instance.lease-expiration-duration-in-seconds=90</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#心跳检测与续约时间</span></span><br><span class="line">    <span class="comment">#开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span></span><br><span class="line">    <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>7001和8001都配置完成</p>
<p>先启动7001再启动8001</p>
<p>结果：先关闭8001，马上被删除了</p>
</li>
</ol>
<h3 id="Eureka停更说明"><a href="#Eureka停更说明" class="headerlink" title="Eureka停更说明"></a>Eureka停更说明</h3><p><a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p>
<blockquote>
<p>Eureka 2.0 (Discontinued)</p>
<p>The existing open source work on eureka 2.0 is discontinued. The code base and artifacts that were released as part of the existing repository of work on the 2.x branch is considered use at your own risk.</p>
<p>Eureka 1.x is a core part of Netflix’s service discovery system and is still an active project.</p>
</blockquote>
<p>我们用ZooKeeper代替Eureka功能。</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="支付服务注册进zookeeper"><a href="#支付服务注册进zookeeper" class="headerlink" title="支付服务注册进zookeeper"></a>支付服务注册进zookeeper</h3><p><strong>注册中心Zookeeper</strong></p>
<p>zookeeper是一个<strong>分布式协调工具</strong>，可以实现注册中心功能</p>
<p>关闭Linux服务器防火墙后，启动zookeeper服务器</p>
<p>用到的Linux命令行：</p>
<ul>
<li><code>systemctl stop firewalld</code> 关闭防火墙</li>
<li><code>systemctl status firewalld</code> 查看防火墙状态</li>
<li><code>ipconfig</code> 查看IP地址</li>
<li><code>ping</code> 查验结果</li>
</ul>
<p>zookeeper服务器取代Eureka服务器，zookeeper作为服务注册中心</p>
<p>视频里是用虚拟机CentOS开启ZooKeeper，我打算在本机启动ZooKeeper，具体操作参考<a href="https://blog.csdn.net/u011863024/article/details/107434932">ZooKeeper学习笔记</a>。</p>
<p><strong>服务提供者</strong></p>
<ol>
<li><p>新建名为cloud-provider-payment8004的Maven工程</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--先排除自带的zookeeper3.5.3 防止与3.4.9起冲突--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#8004表示注册到zookeeper服务器的支付服务提供者端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务别名----注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2181</span> <span class="comment"># 192.168.111.144:2181 #</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8004</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8004.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentzk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper: &quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动8004注册进zookeeper（要先启动zookeeper的server）</p>
<p>验证测试：</p>
<ol>
<li><p>浏览器 - <a href="http://localhost:8004/payment/zk">http://localhost:8004/payment/zk</a></p>
</li>
<li><p>接着用zookeeper客户端操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[services, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /services/cloud-provider-payment</span><br><span class="line">[a4567f50-6ad9-47a3-9fbb-7391f41a9f3d]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] get /services/cloud-provider-payment/a4567f50-6ad9-47a3-9fbb-7391f41a9f3d</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;cloud-provider-payment&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d&quot;</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;192.168.199.218&quot;</span>,<span class="string">&quot;port&quot;</span>:8004,<span class="string">&quot;ss</span></span><br><span class="line"><span class="string">lPort&quot;</span>:null,<span class="string">&quot;payload&quot;</span>:&#123;<span class="string">&quot;@class&quot;</span>:<span class="string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;application-1&quot;</span>,<span class="string">&quot;</span></span><br><span class="line"><span class="string">name&quot;</span>:<span class="string">&quot;cloud-provider-payment&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;registrationTimeUTC&quot;</span>:1612811116918,<span class="string">&quot;serviceType&quot;</span>:<span class="string">&quot;DYNAMIC&quot;</span>,<span class="string">&quot;uriSpec&quot;</span>:&#123;<span class="string">&quot;pa</span></span><br><span class="line"><span class="string">rts&quot;</span>:[&#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;scheme&quot;</span>,<span class="string">&quot;variable&quot;</span>:<span class="literal">true</span>&#125;,&#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;://&quot;</span>,<span class="string">&quot;variable&quot;</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;address&quot;</span>,<span class="string">&quot;variable&quot;</span>:<span class="literal">true</span>&#125;,&#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;</span></span><br><span class="line"><span class="string">:&quot;</span>,<span class="string">&quot;variable&quot;</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;port&quot;</span>,<span class="string">&quot;variable&quot;</span>:<span class="literal">true</span>&#125;]&#125;&#125;</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3]</span><br></pre></td></tr></table></figure>

<p>json格式化 <code>get /services/cloud-provider-payment/a4567f50-6ad9-47a3-9fbb-7391f41a9f3d</code> 的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cloud-provider-payment&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;192.168.199.218&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">8004</span>, </span><br><span class="line">    <span class="attr">&quot;sslPort&quot;</span>: <span class="literal">null</span>, </span><br><span class="line">    <span class="attr">&quot;payload&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@class&quot;</span>: <span class="string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;application-1&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cloud-provider-payment&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;metadata&quot;</span>: &#123; &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">&quot;registrationTimeUTC&quot;</span>: <span class="number">1612811116918</span>, </span><br><span class="line">    <span class="attr">&quot;serviceType&quot;</span>: <span class="string">&quot;DYNAMIC&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;uriSpec&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;parts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;scheme&quot;</span>, </span><br><span class="line">                <span class="attr">&quot;variable&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;://&quot;</span>, </span><br><span class="line">                <span class="attr">&quot;variable&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;address&quot;</span>, </span><br><span class="line">                <span class="attr">&quot;variable&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;:&quot;</span>, </span><br><span class="line">                <span class="attr">&quot;variable&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;port&quot;</span>, </span><br><span class="line">                <span class="attr">&quot;variable&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="临时还是持久节点"><a href="#临时还是持久节点" class="headerlink" title="临时还是持久节点"></a>临时还是持久节点</h3><p>ZooKeeper的服务节点是<strong>临时节点</strong>，没有Eureka那含情脉脉。</p>
<blockquote>
<p>永久节点：不会因为会话结束或者超时而消失；</p>
<p>临时节点：如果会话结束或者超时就会消失；</p>
</blockquote>
<h3 id="订单服务注册进zookeeper"><a href="#订单服务注册进zookeeper" class="headerlink" title="订单服务注册进zookeeper"></a>订单服务注册进zookeeper</h3><ol>
<li><p>新建cloud-consumerzk-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumerzk-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--先排除自带的zookeeper--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加zookeeper3.4.9版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务别名----注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2181</span> <span class="comment"># 192.168.111.144:2181 #</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderZKMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/zk&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>验证测试</p>
<p>运行ZooKeeper服务端，cloud-consumerzk-order80，cloud-provider-payment8004。</p>
<p>打开ZooKeeper客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[services, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /services</span><br><span class="line">[cloud-consumer-order, cloud-provider-payment]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2]</span><br></pre></td></tr></table></figure>

<p>访问测试地址 - <a href="http://localhost/consumer/payment/zk">http://localhost/consumer/payment/zk</a></p>
</li>
</ol>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://www.consul.io/">Consul官网</a></p>
<p><a href="https://www.consul.io/downloads">Consul下载地址</a></p>
<blockquote>
<p>What is Consul?</p>
<p>Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality. Each of these features can be used individually as needed, or they can be used together to build a full service mesh. Consul requires a data plane and supports both a proxy and native integration model. Consul ships with a simple built-in proxy so that everything works out of the box, but also supports 3rd party proxy integrations such as Envoy. link</p>
<p>Consul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有<strong>服务发现</strong>、<strong>配置</strong>和<strong>分段</strong>功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如Envoy。</p>
</blockquote>
<blockquote>
<p>consul<br>英 [ˈkɒnsl] 美 [ˈkɑːnsl]<br>n. 领事</p>
</blockquote>
<p>Consul是一套开源的<strong>分布式服务发现和配置管理系统</strong>，由HashiCorp 公司用Go语言开发。</p>
<p>提供了微服务系统中的<strong>服务治理</strong>、<strong>配置中心</strong>、<strong>控制总线</strong>等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。</p>
<p>它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。</p>
<blockquote>
<p>The key features of Consul are:</p>
<ul>
<li><strong>Service Discovery</strong>: Clients of Consul can register a service, such as <code>api</code> or <code>mysql</code>, and other clients can use Consul to discover providers of a given service. Using either DNS or HTTP, applications can easily find the services they depend upon.</li>
<li><strong>Health Checking</strong>: Consul clients can provide any number of health checks, either associated with a given service (“is the webserver returning 200 OK”), or with the local node (“is memory utilization below 90%”). This information can be used by an operator to monitor cluster health, and it is used by the service discovery components to route traffic away from unhealthy hosts.</li>
<li><strong>KV Store</strong>: Applications can make use of Consul’s hierarchical key/value store for any number of purposes, including dynamic configuration, feature flagging, coordination, leader election, and more. The simple HTTP API makes it easy to use.</li>
<li><strong>Secure Service Communication</strong>: Consul can generate and distribute TLS certificates for services to establish mutual TLS connections. <a href="https://www.consul.io/docs/connect/intentions">Intentions</a> can be used to define which services are allowed to communicate. Service segmentation can be easily managed with intentions that can be changed in real time instead of using complex network topologies and static firewall rules.</li>
<li><strong>Multi Datacenter</strong>: Consul supports multiple datacenters out of the box. This means users of Consul do not have to worry about building additional layers of abstraction to grow to multiple regions.</li>
</ul>
<p><a href="https://www.consul.io/docs/intro#what-is-consul">link</a></p>
</blockquote>
<p>能干嘛？</p>
<ul>
<li>服务发现 - 提供HTTP和DNS两种发现方式。</li>
<li>健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化</li>
<li>KV存储 - Key、Value的存储方式</li>
<li>多数据中心 - Consul支持多数据中心</li>
<li>可视化Web界面</li>
</ul>
<p><a href="https://www.springcloud.cc/spring-cloud-consul.html">怎么使用？</a></p>
<h3 id="安装并运行Consul"><a href="#安装并运行Consul" class="headerlink" title="安装并运行Consul"></a>安装并运行Consul</h3><p><a href="https://learn.hashicorp.com/consul/getting-started/install.html">官网安装说明</a></p>
<p>windows版解压缩后，得consul.exe，打开cmd</p>
<ul>
<li><p>查看版本<code>consul -v</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Consul&gt;consul -v</span><br><span class="line">Consul v1.9.3</span><br><span class="line">Revision f55da9306</span><br><span class="line">Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)</span><br></pre></td></tr></table></figure></li>
<li><p>开发模式启动<code>consul agent -dev</code>：</p>
</li>
</ul>
<p>浏览器输入 - <a href="http://localhost:8500/">http://localhost:8500/</a> - 打开Consul控制页。</p>
<h3 id="服务提供者注册进Consul"><a href="#服务提供者注册进Consul" class="headerlink" title="服务提供者注册进Consul"></a>服务提供者注册进Consul</h3><ol>
<li><p>新建Module支付服务provider8006</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-providerconsul-payment8006<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日常通用jar包配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">###consul服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line"><span class="comment">####consul注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#hostname: 127.0.0.1</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8006</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentMain8006.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentConsul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with consul: &quot;</span>+serverPort+<span class="string">&quot;\t   &quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>验证测试</p>
<ul>
<li><a href="http://localhost:8006/payment/consul">http://localhost:8006/payment/consul</a></li>
<li><a href="http://localhost:8500/">http://localhost:8500</a> - 会显示provider8006</li>
</ul>
</li>
</ol>
<h3 id="服务消费者注册进Consul"><a href="#服务消费者注册进Consul" class="headerlink" title="服务消费者注册进Consul"></a>服务消费者注册进Consul</h3><ol>
<li><p>新建Module消费服务order80 - cloud-consumerconsul-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumerconsul-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日常通用jar包配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">###consul服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-order</span></span><br><span class="line"><span class="comment">####consul注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#hostname: 127.0.0.1</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsulMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(OrderConsulMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsulController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://consul-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/consul&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>验证测试</p>
<p>运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80</p>
<p><a href="http://localhost:8500/">http://localhost:8500/</a> 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。</p>
<p>访问测试地址 - <a href="http://localhost/consumer/payment/consul">http://localhost/consumer/payment/consul</a></p>
</li>
</ol>
<h2 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h2><table>
<thead>
<tr>
<th>组件名</th>
<th>语言CAP</th>
<th>服务健康检查</th>
<th>对外暴露接口</th>
<th>Spring Cloud集成</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Java</td>
<td>AP</td>
<td>可配支持</td>
<td>HTTP</td>
</tr>
<tr>
<td>Consul</td>
<td>Go</td>
<td>CP</td>
<td>支持</td>
<td>HTTP/DNS</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Java</td>
<td>CP</td>
<td>支持客户端</td>
<td>已集成</td>
</tr>
</tbody></table>
<p>CAP：</p>
<ul>
<li>C：Consistency (强一致性)</li>
<li>A：Availability (可用性)</li>
<li>P：Partition tolerance （分区容错性)</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220133441048.png" style="zoom:80%;" />

<p><strong>最多只能同时较好的满足两个</strong>。</p>
<p>CAP理论的核心是：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</strong>。</p>
<p>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：</p>
<ul>
<li>CA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p>AP架构（Eureka）</p>
<p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p>
<p>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220133728006.png" style="zoom:80%;" />

<p>CP架构（ZooKeeper/Consul）</p>
<p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。</p>
<p>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220134120613.png" style="zoom:80%;" />

<p>CP 与 AP 对立同一的矛盾关系。</p>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><h3 id="入门介绍"><a href="#入门介绍" class="headerlink" title="入门介绍"></a>入门介绍</h3><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。</p>
<p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件<strong>负载均衡算法</strong>和<strong>服务调用</strong>。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。</p>
<p>简单的说，就是在配置文件中列出<strong>Load Balancer</strong>（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p>
<blockquote>
<p>ribbon<br>英 [ˈrɪbən] 美 [ˈrɪbən]<br>n. (用于捆绑或装饰的)带子;丝带;带状物;狭长的东西;绶带;勋带</p>
</blockquote>
<p><a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">Github - Ribbon</a></p>
<p>Ribbon目前也进入维护模式。</p>
<p>Ribbon未来可能被Spring Cloud LoadBalacer替代。</p>
<p>LB负载均衡(Load Balance)是什么？</p>
<p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。</p>
<p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p>
<p><strong>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</strong></p>
<p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到 JVM本地，从而在本地实现RPC远程服务调用技术。</p>
<p><strong>集中式LB</strong></p>
<p>即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方；</p>
<p><strong>进程内LB</strong></p>
<p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>
<p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<p><strong>一句话</strong></p>
<p>负载均衡 + RestTemplate调用</p>
<h3 id="Ribbon的负载均衡和Rest调用"><a href="#Ribbon的负载均衡和Rest调用" class="headerlink" title="Ribbon的负载均衡和Rest调用"></a>Ribbon的负载均衡和Rest调用</h3><p><strong>架构说明</strong></p>
<p>总结：Ribbon其实就是一个<strong>负载均衡的客户端</strong>组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220135225545.png" style="zoom: 80%;" />

<p>Ribbon在工作时分成两步：</p>
<ul>
<li>先选择EurekaServer，它优先选择在同一个区域内负载较少的server。</li>
<li>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</li>
</ul>
<p>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。</p>
<p>POM</p>
<p>先前工程项目没有引入spring-cloud-starter-ribbon也可以使用ribbon。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是因为spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用。</p>
<p><strong>二说RestTemplate的使用</strong></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate Java Doc</a></p>
<p><strong>getForObject() / getForEntity() - GET请求方法</strong></p>
<ul>
<li><code>getForObject()</code>：返回对象为响应体中数据转化成的对象，基本上可以理解为 Json。</li>
<li><code>getForEntity()</code>：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(entity.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">        <span class="keyword">return</span> entity.getBody();<span class="comment">//getForObject()</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postForObject() / postForEntity() - POST请求方法</strong></p>
<h3 id="Ribbon默认自带的负载规则"><a href="#Ribbon默认自带的负载规则" class="headerlink" title="Ribbon默认自带的负载规则"></a>Ribbon默认自带的负载规则</h3><p>lRule：根据特定算法中从服务列表中选取一个要访问的服务</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220140015504.png" style="zoom:80%;" />

<ul>
<li><code>RoundRobinRule</code> 轮询</li>
<li><code>RandomRule</code> 随机</li>
<li><code>RetryRule</code> 先按照 <code>RoundRobinRule </code>的策略获取服务,如果获取服务失败则在指定时间内进行重试，获取可用的服务</li>
<li><code>WeightedResponseTimeRule</code> 对 <code>RoundRobinRule</code> 的扩展，响应速度越快的实例选择权重越大，越容易被选择</li>
<li><code>BestAvailableRule</code> 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li><code>AvailabilityFilteringRule</code> 先过滤掉故障实例，再选择并发较小的实例</li>
<li><code>ZoneAvoidanceRule</code> 默认规则，复合判断server所在区域的性能和server的可用性选择服务器</li>
</ul>
<h3 id="Ribbon负载规则替换"><a href="#Ribbon负载规则替换" class="headerlink" title="Ribbon负载规则替换"></a>Ribbon负载规则替换</h3><ol>
<li><p>修改cloud-consumer-order80</p>
<blockquote>
<p>注意配置细节</p>
<p>官方文档明确给出了警告：这个自定义配置类不能放在 <code>@ComponentScan</code> 所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。</p>
<p>（<strong>也就是说不要将Ribbon配置类与主启动类同包</strong>）</p>
</blockquote>
</li>
<li><p>新建package - com.lun.myrule</p>
</li>
<li><p>在com.lun.myrule下新建MySelfRule规则类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类添加 <code>@RibbonClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.myrule.MySelfRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//添加到此处</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>开启cloud-eureka-server7001，cloud-consumer-order80，cloud-provider-payment8001，cloud-provider-payment8002</p>
<p>浏览器-输入<a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p>
<p>返回结果中的serverPort在8001与8002两种间反复横跳。</p>
</li>
</ol>
<h3 id="Ribbon默认负载轮询算法原理"><a href="#Ribbon默认负载轮询算法原理" class="headerlink" title="Ribbon默认负载轮询算法原理"></a>Ribbon默认负载轮询算法原理</h3><p><strong>默认负载轮训算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始</strong>。</p>
<p><code>List&lt;Servicelnstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);</code></p>
<p>如：</p>
<ul>
<li>List [0] instances = 127.0.0.1:8002</li>
<li>List [1] instances = 127.0.0.1:8001</li>
</ul>
<p>8001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理：</p>
<ul>
<li>当总请求数为1时：1%2=1对应下标位置为1，则获得服务地址为127.0.0.1:8001</li>
<li>当总请求数位2时：2%2=0对应下标位置为0，则获得服务地址为127.0.0.1:8002</li>
<li>当总请求数位3时：3%2=1对应下标位置为1，则获得服务地址为127.0.0.1:8001</li>
<li>当总请求数位4时：4%2=0对应下标位置为0，则获得服务地址为127.0.0.1:8002</li>
<li>如此类推…</li>
</ul>
<h3 id="RoundRobinRule源码分析"><a href="#RoundRobinRule源码分析" class="headerlink" title="RoundRobinRule源码分析"></a>RoundRobinRule源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRule</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * choose one alive server from lb.allServers or</span></span><br><span class="line"><span class="comment">     * lb.upServers according to key</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @return choosen Server object. NULL is returned if none</span></span><br><span class="line"><span class="comment">     *  server is available </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The most well known and basic load balancing strategy, i.e. Round Robin Rule.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nikos Michalakis &lt;nikos@netflix.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> AVAILABLE_ONLY_SERVERS = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ALL_SERVERS = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(RoundRobinRule.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextServerCyclicCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Server server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">            <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">            <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">            server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* Transient. */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Next.</span></span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                    + lb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">            <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;<span class="comment">//求余法</span></span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ribbon之手写轮询算法"><a href="#Ribbon之手写轮询算法" class="headerlink" title="Ribbon之手写轮询算法"></a>Ribbon之手写轮询算法</h3><p>自己试着写一个类似RoundRobinRule的本地负载均衡器。</p>
<ul>
<li><p>7001/7002集群启动</p>
</li>
<li><p>8001/8002微服务改造- controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@GetMapping(value = &quot;/payment/lb&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPaymentLB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;<span class="comment">//返回服务接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>80订单微服务改造</p>
<ol>
<li><p><strong>ApplicationContextConfig去掉注解</strong> <code>@LoadBalanced</code>，<strong>OrderMain80去掉注解</strong> <code>@RibbonClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建LoadBalancer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="function">ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyLB</p>
<p>实现LoadBalancer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//需要跟主启动类同包，或者在其子孙包下。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLB</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = <span class="keyword">this</span>.atomicInteger.get();</span><br><span class="line">            next = current &gt;= <span class="number">2147483647</span> ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.atomicInteger.compareAndSet(current,next));</span><br><span class="line">        System.out.println(<span class="string">&quot;*****第几次访问，次数next: &quot;</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getAndIncrement() % serviceInstances.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>OrderController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.lb.LoadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/lb&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPaymentLB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instances == <span class="keyword">null</span> || instances.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServiceInstance serviceInstance = loadBalancer.instances(instances);</span><br><span class="line">        URI uri = serviceInstance.getUri();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(uri+<span class="string">&quot;/payment/lb&quot;</span>,String.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试 不停地刷新<a href="http://localhost/consumer/payment/lb%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B08001/8002%E4%BA%A4%E6%9B%BF%E5%87%BA%E7%8E%B0%E3%80%82">http://localhost/consumer/payment/lb，可以看到8001/8002交替出现。</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">官方文档</a></p>
<p><a href="https://github.com/spring-cloud/spring-cloud-openfeign">Github地址</a></p>
<blockquote>
<p><a href="https://github.com/OpenFeign/feign">Feign</a> is a declarative web service client. It makes writing web service clients easier. To use Feign create an interface and annotate it. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders. Spring Cloud adds support for Spring MVC annotations and for using the same <code>HttpMessageConverters</code> used by default in Spring Web. Spring Cloud integrates Ribbon and Eureka, as well as Spring Cloud LoadBalancer to provide a load-balanced http client when using Feign.  <a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-feign">link</a></p>
<p>Feign是一个<strong>声明式WebService客户端</strong>。使用Feign能让编写Web Service客户端更加简单。它的<strong>使用方法是定义一个服务接口然后在上面添加注解</strong>。Feign也<strong>支持可拔插式的编码器和解码器</strong>。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以<strong>与Eureka和Ribbon组合使用以支持负载均衡</strong>。</p>
</blockquote>
<p><strong>Feign能干什么</strong></p>
<p>Feign旨在使编写 Java Http客户端变得更容易。</p>
<p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个<strong>微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。<strong>在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可），即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量</strong>。</p>
<p><strong>Feign集成了Ribbon</strong></p>
<p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，<strong>通过Feign只需要定义服务绑定接口且以声明式的方法</strong>，优雅而简单的实现了服务调用。</p>
<p><strong>Feign和OpenFeign两者区别</strong></p>
<p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。<strong>Feign的使用方式</strong>是：<strong>使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如 <code>@RequesMapping</code> 等等。OpenFeign的 <code>@Feignclient</code> 可以解析SpringMVC的 <code>@RequestMapping</code> 注解下的接口，并<strong>通过动态代理的方式产生实现类</strong>，<strong>实现类中做负载均衡并调用其他服务</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>feign<br>英 [feɪn] 美 [feɪn]<br>v. 假装，装作，佯装(有某种感觉或生病、疲倦等)</p>
</blockquote>
<h3 id="OpenFeign服务调用"><a href="#OpenFeign服务调用" class="headerlink" title="OpenFeign服务调用"></a>OpenFeign服务调用</h3><p>接口+注解：微服务调用接口 + <code>@FeignClient</code></p>
<ol>
<li><p>新建cloud-consumer-feign-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-feign-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般基础通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>业务逻辑接口 + <code>@FeignClient</code> 配置调用provider服务</p>
<p>新建PaymentFeignService接口并新增注解 <code>@FeignClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制层Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentFeignService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>先启动2个eureka集群7001/7002</p>
<p>再启动2个微服务8001/8002</p>
<p>启动OpenFeign</p>
<p><a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p>
<p>Feign自带负载均衡配置项</p>
</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220174948224.png" style="zoom:80%;" />

<h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p><strong>超时设置，故意设置超时演示出错情况</strong></p>
<ol>
<li><p>服务提供方8001/8002故意写暂停程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理正确，但是需要耗费3秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务消费方80添加超时方法PaymentFeignService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务消费方80添加超时方法OrderFeignController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// OpenFeign客户端一般默认等待1秒钟</span></span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.paymentFeignTimeout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>多次刷新<a href="http://localhost/consumer/payment/feign/timeout">http://localhost/consumer/payment/feign/timeout</a></p>
<p>将会跳出错误Spring Boot默认错误页面，主要<strong>异常</strong>：<strong>feign.RetryableException:Read timed out executing GET <a href="http://cloud-payment-servce/payment/feign/timeout">http://CLOUD-PAYMENT-SERVCE/payment/feign/timeout</a></strong>。</p>
<p>OpenFeign默认等待1秒钟，超过后报错</p>
<p>YML文件里需要开启OpenFeign客户端超时控制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="OpenFeign日志增强"><a href="#OpenFeign日志增强" class="headerlink" title="OpenFeign日志增强"></a>OpenFeign日志增强</h3><p><strong>日志打印功能</strong></p>
<p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign 中 Http请求的细节。</p>
<p>说白了就是对Feign接口的调用情况进行监控和输出</p>
<p><strong>日志级别</strong></p>
<ul>
<li><code>NONE</code>：默认的，不显示任何日志；</li>
<li><code>BASIC</code>：仅记录请求方法、URL、响应状态码及执行时间；</li>
<li><code>HEADERS</code>：除了BASIC中定义的信息之外，还有请求和响应的头信息；</li>
<li><code>FULL</code>：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ul>
<p><strong>配置日志bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>YML文件里需要开启日志的Feign客户端</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.lun.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p><strong>后台日志查看</strong></p>
<p>得到更多日志信息。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220183948687.png" style="zoom:80%;" />



<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p><strong>概述</strong></p>
<p><strong>分布式系统面临的问题</strong></p>
<p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220191830325.png" style="zoom: 80%;" />

<p><strong>服务雪崩</strong></p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“<strong>雪崩效应</strong>”。<br>对于高流量的应用来说，单一的<strong>后避依赖</strong>可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的<strong>延迟增加</strong>，<strong>备份队列</strong>，<strong>线程和其他系统资源紧张</strong>，导致整个系统发生更多的<strong>级联故障</strong>。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<p>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生<strong>级联故障</strong>，或者叫<strong>雪崩</strong>。</p>
<p><strong>Hystrix是什么</strong></p>
<p>Hystrix是一个用于<strong>处理分布式系统的延迟和容错的开源库</strong>，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够<strong>保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</p>
<p>“<strong>断路器</strong>”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的<strong>故障监控</strong>（类似熔断保险丝)，<strong>向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就<strong>保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩</strong>。</p>
<blockquote>
<p>hystrix<br>n. 豪猪属;猬草属;豪猪;豪猪亚属</p>
</blockquote>
<h3 id="Hystrix停更进维"><a href="#Hystrix停更进维" class="headerlink" title="Hystrix停更进维"></a>Hystrix停更进维</h3><p><strong>能干嘛？</strong></p>
<ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>接近实时的监控</li>
<li>…</li>
</ul>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">官网资料</a></p>
<p><strong>Hystrix官宣，停更进维</strong></p>
<p><a href="https://github.com/Netflix/Hystrix">link</a></p>
<ul>
<li>被动修bugs</li>
<li>不再接受合并请求</li>
<li>不再发布新版本</li>
</ul>
<h3 id="Hystrix的服务降级熔断限流概念初讲"><a href="#Hystrix的服务降级熔断限流概念初讲" class="headerlink" title="Hystrix的服务降级熔断限流概念初讲"></a>Hystrix的服务降级熔断限流概念初讲</h3><p><strong>服务降级</strong></p>
<p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback</p>
<p><strong>哪些情况会触发降级？</strong></p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
<p><strong>服务熔断</strong></p>
<p><strong>类比保险丝</strong>达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</p>
<p>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</p>
<p><strong>服务限流</strong></p>
<p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。</p>
<h3 id="Hystrix支付微服务构建"><a href="#Hystrix支付微服务构建" class="headerlink" title="Hystrix支付微服务构建"></a>Hystrix支付微服务构建</h3><p>将cloud-eureka-server7001改配置成单机版</p>
<ol>
<li><p>新建cloud-provider-hygtrix-payment8001</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-hystrix-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_OK,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>+<span class="string">&quot;  耗时(秒): 3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_OK(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>正常测试</p>
<p>启动eureka7001</p>
<p>启动cloud-provider-hystrix-payment8001</p>
<p>访问</p>
<ul>
<li>success的方法 - <a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></li>
<li>每次调用耗费5秒钟 - <a href="http://localhost:8001/payment/hystrix/timeout/1">http://localhost:8001/payment/hystrix/timeout/1</a></li>
</ul>
<p>上述module均OK</p>
<p>以上述为根基平台，从正确 -&gt; 错误 -&gt; 降级熔断 -&gt; 恢复。</p>
</li>
</ol>
<h3 id="JMeter高并发压测后卡顿"><a href="#JMeter高并发压测后卡顿" class="headerlink" title="JMeter高并发压测后卡顿"></a>JMeter高并发压测后卡顿</h3><p><strong>上述在非高并发情形下，还能勉强满足</strong></p>
<p><strong>Jmeter压测测试</strong></p>
<p><a href="https://jmeter.apache.org/index.html">JMeter官网</a></p>
<blockquote>
<p>The Apache JMeter™ application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.</p>
</blockquote>
<p>开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220212409485.png" style="zoom:80%;" />

<ol>
<li>测试计划中右键添加 -&gt; 线程 -&gt; 线程组（线程组202102，线程数：200，线程数：100，其他参数默认）</li>
<li>刚刚新建线程组202102，右键它 -&gt; 添加 -&gt; 取样器 -&gt; Http请求 -&gt; 基本 输入<a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></li>
<li>点击绿色三角形图标启动。</li>
</ol>
<p>看演示结果：拖慢，原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</p>
<p><strong>Jmeter压测结论</strong></p>
<p>上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。</p>
<h3 id="订单微服务调用支付服务出现卡顿"><a href="#订单微服务调用支付服务出现卡顿" class="headerlink" title="订单微服务调用支付服务出现卡顿"></a>订单微服务调用支付服务出现卡顿</h3><p><strong>看热闹不嫌弃事大，80新建加入</strong></p>
<ol>
<li><p>新建 - cloud-consumer-feign-hystrix-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-feign-hystrix-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般基础通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">//@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot; /*,fallback = PaymentFallbackService.class*/)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystirxController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ul>
<li><p>正常测试：<a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></p>
</li>
<li><p>高并发测试：</p>
<p>2W个线程压8001</p>
<p>消费端80微服务再去访问正常的Ok微服务8001地址</p>
<p><a href="http://localhost/consumer/payment/hystrix/ok/32">http://localhost/consumer/payment/hystrix/ok/32</a></p>
<p>消费者80被拖慢</p>
<p>原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。</p>
<p>正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。</p>
</li>
</ul>
</li>
</ol>
<h3 id="降级容错解决的维度要求"><a href="#降级容错解决的维度要求" class="headerlink" title="降级容错解决的维度要求"></a>降级容错解决的维度要求</h3><p>超时导致服务器变慢（转圈） - 超时不再等待</p>
<p>出错（宕机或程序运行出错） - 出错要有兜底</p>
<p>解决：</p>
<ul>
<li>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。</li>
<li>对方服务(8001)宕机了，调用者(80)不能一直卡死等待，必须有服务降级。</li>
<li>对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级。</li>
</ul>
<h3 id="Hystrix之服务降级支付侧fallback"><a href="#Hystrix之服务降级支付侧fallback" class="headerlink" title="Hystrix之服务降级支付侧fallback"></a>Hystrix之服务降级支付侧fallback</h3><p>降级配置 - <code>@HystrixCommand</code></p>
<p>8001先从自身找问题</p>
<p><strong>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback</strong>。</p>
<p><strong>8001fallback</strong></p>
<p>业务类启用 - <code>@HystrixCommand</code> 报异常后如何处理</p>
<p>—旦调用服务方法失败并抛出了错误信息后，会自动调用 <code>@HystrixCommand</code> 标注好的fallbackMethod调用类中的指定方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;/*指定善后方法名*/,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>+<span class="string">&quot;  耗时(秒): &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来善后的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  8001系统繁忙或者运行报错，请稍后再试,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面故意制造两种异常：</p>
<ol>
<li>int age = 10/0，计算异常</li>
<li>我们能接受3秒钟，它运行5秒钟，超时异常。</li>
</ol>
<p>当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler</p>
<p><strong>主启动类激活</strong></p>
<p>添加新注解 <code>@EnableCircuitBreaker</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span><span class="comment">//添加到此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix之服务降级订单侧fallback"><a href="#Hystrix之服务降级订单侧fallback" class="headerlink" title="Hystrix之服务降级订单侧fallback"></a>Hystrix之服务降级订单侧fallback</h3><p>80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护</p>
<p>题外话，切记 - 我们自己配置过的热部署方式对java代码的改动明显</p>
<p>但对 <code>@HystrixCommand</code> 内属性的修改建议重启微服务</p>
<p><strong>YML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>主启动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span><span class="comment">//添加到此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>业务类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystirxController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//善后方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix之全局服务降级DefaultProperties"><a href="#Hystrix之全局服务降级DefaultProperties" class="headerlink" title="Hystrix之全局服务降级DefaultProperties"></a>Hystrix之全局服务降级DefaultProperties</h3><p>目前问题1 每个业务方法对应一个兜底的方法，代码膨胀</p>
<p>解决方法</p>
<p>1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明</p>
<p>1:N除了个别重要核心业务有专属，其它普通的可以通过 <code>@DefaultProperties(defaultFallback = “”)</code> 统一跳转到统一处理结果页面</p>
<p>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span> <span class="comment">//没有特别指明就用统一的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystirxController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="comment">//            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span><span class="comment">//用全局的fallback方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是全局fallback方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix之通配服务降级FeignFallback"><a href="#Hystrix之通配服务降级FeignFallback" class="headerlink" title="Hystrix之通配服务降级FeignFallback"></a>Hystrix之通配服务降级FeignFallback</h3><p><strong>目前问题2</strong> 统一和自定义的分开，代码混乱</p>
<p><strong>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</strong></p>
<p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为 Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</p>
<p><strong>未来我们要面对的异常</strong></p>
<ul>
<li>运行</li>
<li>超时</li>
<li>宕机</li>
</ul>
<p>修改cloud-consumer-feign-hystrix-order80</p>
<p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类(AaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理。</p>
<ol>
<li><p>PaymentFallbackService类实现PaymentHystrixService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>PaymentHystrixService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot; ,//</span></span><br><span class="line"><span class="meta">             fallback = PaymentFallbackService.class)</span><span class="comment">//指定PaymentFallbackService类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>单个eureka先启动7001</p>
<p>PaymentHystrixMain8001启动</p>
<p>正常访问测试 - <a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></p>
<p>故意关闭微服务8001</p>
<p>客户端自己调用提示 - 此时服务端provider已经宕机了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p>
</li>
</ol>
<h3 id="Hystrix之服务熔断理论"><a href="#Hystrix之服务熔断理论" class="headerlink" title="Hystrix之服务熔断理论"></a>Hystrix之服务熔断理论</h3><p>断路器，相当于保险丝。</p>
<p><strong>熔断机制概述</strong></p>
<p>熔断机制是<strong>应对雪崩效应</strong>的一种<strong>微服务链路保护机制</strong>。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会<strong>监控微服务间调用的状况</strong>，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是 <code>@HystrixCommand</code>。</p>
<p><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220231506085.png" style="zoom:80%;" />

<h3 id="Hystrix之服务熔断案例"><a href="#Hystrix之服务熔断案例" class="headerlink" title="Hystrix之服务熔断案例"></a>Hystrix之服务熔断案例</h3><p><a href="https://hutool.cn/">Hutool国产工具类</a></p>
<p>修改cloud-provider-hystrix-payment8001</p>
<ol>
<li><p>Service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.IdUtil;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span></span>&#123;    </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=====服务熔断</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String serialNumber = IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> +id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The precise way that the circuit opening and closing occurs is as follows:</p>
<ol>
<li>Assuming the volume across a circuit meets a certain threshold : <code>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</code></li>
<li>And assuming that the error percentage, as defined above exceeds the error percentage defined in : <code>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</code></li>
<li>Then the circuit-breaker transitions from CLOSED to OPEN.</li>
<li>While it is open, it short-circuits all requests made against that circuit-breaker.</li>
<li>After some amount of time (<code>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</code>), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.</li>
</ol>
<p><a href="https://github.com/Netflix/Hystrix/issues/674">link</a></p>
</blockquote>
</li>
<li><p>HystrixCommandProperties配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.hystrix;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommandProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HystrixCommandProperties.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* defaults */</span></span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_metricsRollingStatisticalWindow = <span class="number">10000</span>;<span class="comment">// default =&gt; statisticalWindow: 10000 = 10 seconds (and default of 10 buckets so each bucket is 1 second)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_metricsRollingStatisticalWindowBuckets = <span class="number">10</span>;<span class="comment">// default =&gt; statisticalWindowBuckets: 10 = 10 buckets in a 10 second window so each bucket is 1 second</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_circuitBreakerRequestVolumeThreshold = <span class="number">20</span>;<span class="comment">// default =&gt; statisticalWindowVolumeThreshold: 20 requests in 10 seconds must occur before statistics matter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_circuitBreakerSleepWindowInMilliseconds = <span class="number">5000</span>;<span class="comment">// default =&gt; sleepWindow: 5000 = 5 seconds that we will sleep before trying again after tripping the circuit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_circuitBreakerErrorThresholdPercentage = <span class="number">50</span>;<span class="comment">// default =&gt; errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent then we will trip the circuit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean default_circuitBreakerForceOpen = <span class="keyword">false</span>;<span class="comment">// default =&gt; forceCircuitOpen = false (we want to allow traffic)</span></span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean default_circuitBreakerForceClosed = <span class="keyword">false</span>;<span class="comment">// default =&gt; ignoreErrors = false </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer default_executionTimeoutInMilliseconds = <span class="number">1000</span>; <span class="comment">// default =&gt; executionTimeoutInMilliseconds: 1000 = 1 second</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean default_executionTimeoutEnabled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//====服务熔断</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        String result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>自测cloud-provider-hystrix-payment8001</p>
<p>正确 - <a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></p>
<p>错误 - <a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></p>
<p>多次错误，再来次正确，但错误得显示</p>
<p>重点测试 - 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行</p>
</li>
</ol>
<h3 id="Hystrix之服务熔断总结"><a href="#Hystrix之服务熔断总结" class="headerlink" title="Hystrix之服务熔断总结"></a>Hystrix之服务熔断总结</h3><p><strong>大神结论</strong>：<a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a></p>
<p><strong>熔断类型</strong></p>
<ul>
<li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。</li>
<li>熔断关闭：熔断关闭不会对服务进行熔断。</li>
<li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。</li>
</ul>
<p><strong>官网断路器流程图</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220232718427.png" style="zoom:75%;" />

<p><strong>官网步骤</strong></p>
<blockquote>
<p>The precise way that the circuit opening and closing occurs is as follows:</p>
<ol>
<li>Assuming the volume across a circuit meets a certain threshold : <code>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</code></li>
<li>And assuming that the error percentage, as defined above exceeds the error percentage defined in : <code>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</code></li>
<li>Then the circuit-breaker transitions from CLOSED to OPEN.</li>
<li>While it is open, it short-circuits all requests made against that circuit-breaker.</li>
<li>After some amount of time (<code>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</code>), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.</li>
</ol>
<p><a href="https://github.com/Netflix/Hystrix/issues/674">link</a></p>
</blockquote>
<p><strong>断路器在什么情况下开始起作用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到断路器的三个重要参数：</p>
<ol>
<li><strong>快照时间窗</strong>：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li><strong>请求总数阀值</strong>：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次7，即使所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li><strong>错误百分比阀值</strong>：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li>
</ol>
<p><strong>断路器开启或者关闭的条件</strong></p>
<p>到达以下阀值，断路器将会开启：</p>
<ul>
<li>当满足一定的阀值的时候（默认10秒内超过20个请求次数）</li>
<li>当失败率达到一定的时候（默认10秒内超过50%的请求失败）</li>
</ul>
<p>当开启的时候，所有请求都不会进行转发</p>
<p>一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。</p>
<p><strong>断路器打开之后</strong></p>
<p>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p>
<p>原来的主逻辑要如何恢复呢？</p>
<p>对于这一问题，hystrix也为我们实现了自动恢复功能。</p>
<p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p>
<p><strong>@HystrixCommand 的所有配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;, </span></span><br><span class="line"><span class="meta">                groupKey = &quot;strGroupCommand&quot;, </span></span><br><span class="line"><span class="meta">                commandKey = &quot;strCommand&quot;, </span></span><br><span class="line"><span class="meta">                threadPoolKey = &quot;strThreadPool&quot;,</span></span><br><span class="line"><span class="meta">                </span></span><br><span class="line"><span class="meta">                commandProperties = &#123;</span></span><br><span class="line"><span class="meta">                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;),</span></span><br><span class="line"><span class="meta">                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 配置命令执行的超时时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutinMilliseconds&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否启用超时时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 执行超时的时候是否中断</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 执行被取消的时候是否中断</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnCancel&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 允许回调方法执行的最大并发数</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 服务降级是否启用，是否执行回调函数</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否启用断路器</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 &quot;打开&quot; 状态，否则就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 &quot;半开&quot; 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 &quot;打开&quot; 状态，如果成功就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowinMilliseconds&quot;, value = &quot;5000&quot;),</span></span><br><span class="line"><span class="meta">                    // 断路器强制打开</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 断路器强制关闭</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.timeinMilliseconds&quot;, value = &quot;10000&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 &quot;桶&quot; 来累计各度量值，每个&quot;桶&quot;记录了一段时间内的采集指标。</span></span><br><span class="line"><span class="meta">                    // 比如 10 秒内拆分成 10 个&quot;桶&quot;收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，</span></span><br><span class="line"><span class="meta">                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，</span></span><br><span class="line"><span class="meta">                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalinMilliseconds&quot;, value = &quot;500&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否开启请求缓存</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;-1&quot;),</span></span><br><span class="line"><span class="meta">                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。</span></span><br><span class="line"><span class="meta">                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;5&quot;),</span></span><br><span class="line"><span class="meta">                &#125;</span></span><br><span class="line"><span class="meta">               )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix工作流程最后总结"><a href="#Hystrix工作流程最后总结" class="headerlink" title="Hystrix工作流程最后总结"></a>Hystrix工作流程最后总结</h3><p><strong>服务限流</strong> - 后面高级篇讲解alibaba的Sentinel说明</p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">官方解释</a></p>
<p><strong>官网图例</strong></p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220220234546640.png"></p>
<p><strong>步骤说明</strong></p>
<ol>
<li>创建 <code>HystrixCommand</code>（用在依赖的服务返回单个操作结果的时候）或 <code>HystrixObserableCommand</code>（用在依赖的服务返回多个操作结果的时候）对象。</li>
<li>命令执行。</li>
<li>其中 <code>HystrixCommand</code> 实现了下面两种执行方式：<ol>
<li><code>execute()</code>：同步执行，从依赖的服务返回一个单一的结果对象或是在发生错误的时候抛出异常。</li>
<li><code>queue()</code>：异步执行，直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。</li>
</ol>
</li>
<li>而 <code>HystrixObservableCommand</code> 实现了后两种执行方式：<ol>
<li><code>obseve()</code>：返回 <code>Observable</code> 对象，它代表了操作的多个结果，它是一个 <code>Hot Observable</code>（不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于 <code>Hot Observable</code> 的每一个“订阅者”都有可能是从“事件源”的中途开始的，并可能只是看到了整个操作的局部过程）。</li>
<li><code>toObservable()</code>：同样会返回 <code>Observable</code> 对象，也代表了操作的多个结果，但它返回的是一个 <code>Cold Observable</code>（没有“订间者”的时候并不会发布事件，而是进行等待，直到有“订阅者”之后才发布事件，所以对于 <code>Cold Observable</code> 的订阅者，它可以保证从一开始看到整个操作的全部过程）。</li>
</ol>
</li>
<li>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以 <code>Observable</code> 对象的形式返回。</li>
<li>检查断路器是否为打开状态。如果断路器是打开的，那么Hystrix不会执行命令，而是转接到fallback处理逻辑（第8步）；如果断路器是关闭的，检查是否有可用资源来执行命令（第5步）。</li>
<li>线程池/请求队列信号量是否占满。如果命令依赖服务的专有线程地和请求队列，或者信号量（不使用线程的时候）已经被占满，那么Hystrix也不会执行命令，而是转接到fallback处理理辑（第8步）。</li>
<li>Hystrix会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。<ul>
<li><code>HystrixCommand.run()</code>：返回一个单一的结果，或者抛出异常。</li>
<li><code>HystrixObservableCommand.construct()</code>：返回一个 <code>Observable</code> 对象来发射多个结果，或通过onError发送错误通知。</li>
</ul>
</li>
<li>Hystix会将“成功”、“失败”、“拒绝”、“超时” 等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行”熔断/短路”。</li>
<li>当命令执行失败的时候，Hystix会进入fallback尝试回退处理，我们通常也称波操作为“服务降级”。而能够引起服务降级处理的情况有下面几种：<ol>
<li>第4步：当前命令处于“熔断/短路”状态，断洛器是打开的时候。</li>
<li>第5步：当前命令的钱程池、请求队列或者信号量被占满的时候。</li>
<li>第6步：<code>HystrixObsevableCommand.construct()</code> 或 <code>HytrixCommand.run()</code> 抛出异常的时候。</li>
</ol>
</li>
<li>当Hystrix命令执行成功之后，它会将处理结果直接返回或是以 <code>Observable</code> 的形式返回。</li>
</ol>
<p><strong>tips</strong>：如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常，Hystrix依然会返回一个Obsevable对象，但是它不会发射任结果数据，而是通过onError方法通知命令立即中断请求，并通过onError方法将引起命令失败的异常发送给调用者。</p>
<h3 id="Hystrix图形化Dashboard搭建"><a href="#Hystrix图形化Dashboard搭建" class="headerlink" title="Hystrix图形化Dashboard搭建"></a>Hystrix图形化Dashboard搭建</h3><p><strong>概述</strong></p>
<p>除了隔离依赖服务的调用以外，Hystrix还提供了<strong>准实时的调用监控</strong>(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。</p>
<p>Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p>
<p><strong>仪表盘9001</strong></p>
<ol>
<li><p>新建cloud-consumer-hystrix-dashboard9001</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-hystrix-dashboard9001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure></li>
<li><p>HystrixDashboardMain9001+新注解 <code>@EnableHystrixDashboard</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001</p>
</li>
<li><p>测试：浏览器输入<a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></p>
</li>
</ol>
<h3 id="Hystrix图形化Dashboard监控实战"><a href="#Hystrix图形化Dashboard监控实战" class="headerlink" title="Hystrix图形化Dashboard监控实战"></a>Hystrix图形化Dashboard监控实战</h3><p><strong>修改cloud-provider-hystrix-payment8001</strong></p>
<p>注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     *否则，Unable to connect to Command Metric Stream 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>监控测试</strong></p>
<p>启动1个eureka</p>
<p>启动8001，9001</p>
<p><strong>观察监控窗口</strong></p>
<p>9001监控8001 - 填写监控地址 - <a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a> 到 <a href="http://localhost:9001/hystrix%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86%E3%80%82">http://localhost:9001/hystrix页面的输入框。</a></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221001359927.png" style="zoom:80%;" />

<p>测试地址</p>
<ul>
<li><a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></li>
<li><a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></li>
</ul>
<p>测试通过</p>
<p>先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。</p>
<p><strong>7色</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221001439550.png" style="zoom:80%;" />

<p><strong>1圈</strong></p>
<p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色 &lt; 黄色 &lt; 橙色 &lt; 红色递减。</p>
<p>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，<strong>流量越大该实心圆就越大</strong>。所以通过该实心圆的展示，就可以在大量的实例中快速的发现<strong>故障实例</strong>和<strong>高压力实例</strong>。</p>
<p><strong>1线</strong></p>
<p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。</p>
<p><strong>整图说明</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221001831095.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221001854140.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221002056423.png" style="zoom:80%;" />

<h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>概述描述</p>
<p>路由基本配置</p>
<p>路由访问映射规则</p>
<p>查看路由信息</p>
<p>过滤器</p>
<p>Zuul开发人员窝里斗，实属明日黄花</p>
<p>重点关注Gate Way</p>
<h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/Netflix/zuul/wiki">上一代zuul 1.x官网</a></p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">Gateway官网</a></p>
<p><strong>概述</strong></p>
<p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；</p>
<p>但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221002436221.png" style="zoom:80%;" />

<p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。</p>
<p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断、限流、重试等。</p>
<p>SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。</p>
<p>SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，<strong>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty</strong>。</p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如：安全，监控/指标和限流。</p>
<p><strong>作用</strong></p>
<ul>
<li>方向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
<li>…</li>
</ul>
<p><strong>微服务架构中网关的位置</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221002832231.png" style="zoom:80%;" />

<h3 id="GateWay非阻塞异步模型"><a href="#GateWay非阻塞异步模型" class="headerlink" title="GateWay非阻塞异步模型"></a>GateWay非阻塞异步模型</h3><p>有Zuull了怎么又出来Gateway？<strong>我们为什么选择Gateway?</strong></p>
<p>netflix不太靠谱，zuul2.0一直跳票，迟迟不发布。</p>
<ol>
<li>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。</li>
<li>Gateway是<strong>基于异步非阻塞模型</strong>上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的Zuul 2.x，但Spring Cloud貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何?</li>
<li>多方面综合考虑Gateway是很理想的网关选择。</li>
</ol>
<p>SpringCloud Gateway具有如下特性：</p>
<ol>
<li>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定Predicate(断言)和Filter(过滤器)；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成Spring Cloud 服务发现功能；</li>
<li>易于编写的Predicate (断言)和Filter (过滤器)；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ol>
<p>SpringCloud Gateway与Zuul的区别：</p>
<ol>
<li>在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。</li>
<li>Zuul 1.x 是一个基于阻塞I/O的API Gateway。</li>
<li>Zuul 1.x 基于Servlet 2.5使用阻塞架构它不支持任何长连接（如WebSocket）Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用 Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能相对较差。</li>
<li>Zuul 2.x 理念更先进，想<strong>基于Netty非阻塞</strong>和<strong>支持长连接</strong>，但SpringCloud目前还没有整合。Zuul 2.x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</li>
<li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。</li>
<li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li>
</ol>
<p><strong>Zuul1.x模型</strong></p>
<p>SpringCloud中所集成的Zuul版本，采用的是<strong>Tomcat容器</strong>，使用的是传统的<strong>Serviet IO处理模型</strong>。</p>
<p>Servlet的生命周期？servlet由<strong>servlet container</strong>进行生命周期管理。</p>
<ul>
<li>container启动时构造servlet对象并调用 <code>servlet init()</code> 进行初始化；</li>
<li>container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用 <code>service</code>；</li>
<li>container关闭时调用 <code>servlet destory()</code> 销毁servlet。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221011112790.png" style="zoom:80%;" />

<p>上述模式的<strong>缺点</strong>：</p>
<p>Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发（如抽风用Jmeter压），线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。</p>
<p>所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)并由该servlet阻塞式处理。所以SpringCloud Zuul无法摆脱servlet模型的弊端。</p>
<p><strong>Gateway模型</strong></p>
<p>WebFlux是什么？<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">官方文档</a></p>
<p>传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。</p>
<p>但是在Servlet3.1之后有了<strong>异步非阻塞</strong>的支持。而<strong>WebFlux</strong>是一个<strong>典型非阻塞异步的框架</strong>，它的核心是<strong>基于Reactor</strong>的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring 5必须让你使用Java 8）。</p>
<p>Spring WebFlux是Spring 5.0 引入的新的<strong>响应式框架</strong>，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</p>
<blockquote>
<p>Spring Cloud Gateway requires the Netty runtime provided by Spring Boot and Spring Webflux. It does not work in a traditional Servlet Container or when built as a WAR.<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-starter">link</a></p>
</blockquote>
<h3 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h3><p><strong>三大核心概念</strong></p>
<ol>
<li>**Route(路由)**：路由是构建网关的基本模块，它由ID、目标URI、一系列的断言和过滤器组成，如断言为true则匹配该路由；</li>
<li>**Predicate(断言)**：参考的是 Java8的 <code>java.util.function.Predicate</code>，开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由；</li>
<li>**Filter(过滤)**：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221011824289.png" style="zoom:80%;" />

<p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。</p>
<p>Predicate就是我们的匹配条件；而Fliter 就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。</p>
<p><strong>Gateway工作流程</strong></p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-how-it-works">官网总结</a></p>
<blockquote>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221012018941.png" style="zoom:80%;" />

<p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-how-it-works">link</a></p>
</blockquote>
<p>客户端向 <code>Spring Cloud Gateway</code> 发出请求。然后在 <code>Gateway Handler Mapping</code> 中找到与请求相匹配的路由，将其发送到<code>GatewayWeb Handler</code>。</p>
<p>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”）执行业务逻辑。</p>
<p>Filter在“pre”类型的过滤器可以做<strong>参数校验</strong>、<strong>权限校验</strong>、<strong>流量监控</strong>、<strong>日志输出</strong>、<strong>协议转换</strong>等，在“post”类型的过滤器中可以做<strong>响应内容</strong>、<strong>响应头的修改</strong>，<strong>日志的输出</strong>，<strong>流量监控</strong>等有着非常重要的作用。</p>
<p><strong>核心逻辑</strong>：路由转发 + 执行过滤器链。</p>
<h3 id="Gateway9527搭建"><a href="#Gateway9527搭建" class="headerlink" title="Gateway9527搭建"></a>Gateway9527搭建</h3><ol>
<li><p>新建Module - cloud-gateway-gateway9527</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-gateway-gateway9527<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般基础配置类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>无</p>
</li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayMain9527</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>9527网关如何做路由映射？</p>
<p>cloud-provider-payment8001看看controller的访问地址</p>
<ul>
<li>get</li>
<li>lb</li>
</ul>
<p>我们目前不想暴露8001端口，希望在8001外面套一层9527</p>
</li>
<li><p>YML新增网关配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"><span class="comment">#############################新增网关配置###########################</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>启动7001</p>
<p>启动8001-cloud-provider-payment8001</p>
<p>启动9527网关</p>
<p>访问说明</p>
<ul>
<li>添加网关前 - <a href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a></li>
<li>添加网关后 - <a href="http://localhost:9527/payment/get/1">http://localhost:9527/payment/get/1</a></li>
<li>两者访问成功，返回相同结果</li>
</ul>
</li>
</ol>
<h3 id="Gateway配置路由的两种方式"><a href="#Gateway配置路由的两种方式" class="headerlink" title="Gateway配置路由的两种方式"></a>Gateway配置路由的两种方式</h3><p><strong>在配置文件yml中配置，见上一章节</strong></p>
<p><strong>代码中注入RouteLocator的Bean</strong></p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#modifying-the-way-remote-addresses-are-resolved">官方案例</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver</span><br><span class="line">    .maxTrustedIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.route(<span class="string">&quot;direct-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(<span class="string">&quot;10.1.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream1&quot;</span>)</span><br><span class="line">.route(<span class="string">&quot;proxied-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(resolver, <span class="string">&quot;10.10.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream2&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>百度国内新闻网址，需要外网 - <a href="http://news.baidu.com/guonei">http://news.baidu.com/guonei</a></p>
<p><strong>自己写一个</strong></p>
<p>业务需求 - 通过9527网关访问到外网的百度新闻网址</p>
<p><strong>编码</strong></p>
<p>cloud-gateway-gateway9527业务实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *配置了一个id为route-name的路由规则，当访问地址：http://localhost:9527/guonei时</span></span><br><span class="line"><span class="comment">    *会自动转发到地址：http://news.baidu.com/guonei</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span> </span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>浏览器输入<a href="http://localhost:9527/guonei%EF%BC%8C%E8%BF%94%E5%9B%9Ehttp://news.baidu.com/guonei%E7%9B%B8%E5%90%8C%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:9527/guonei，返回http://news.baidu.com/guonei相同的页面。</a></p>
<h3 id="GateWay配置动态路由"><a href="#GateWay配置动态路由" class="headerlink" title="GateWay配置动态路由"></a>GateWay配置动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<strong>动态路由进行转发，从而实现动态路由的功能</strong>（不写死一个地址）。</p>
<ol>
<li><p>启动</p>
<ul>
<li>eureka7001</li>
<li>payment8001/8002</li>
</ul>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<p>需要注意的是 <code>uri</code> 的协议为 <code>lb</code>，表示启用 Gateway 的负载均衡功能。</p>
<p><code>lb://serviceName</code> 是 spring cloud gateway 在微服务中自动为我们创建的负载均衡 <code>uri</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"><span class="comment">#############################新增网关配置###########################</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>浏览器输入 - <a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a></p>
<p>结果</p>
<p>不停刷新页面，8001/8002两个端口切换。</p>
</li>
</ol>
<h3 id="GateWay常用的Predicate"><a href="#GateWay常用的Predicate" class="headerlink" title="GateWay常用的Predicate"></a>GateWay常用的Predicate</h3><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">官方文档</a></p>
<p><strong>Route Predicate Factories这个是什么？</strong></p>
<blockquote>
<p>Spring Cloud Gateway matches routes as part of the Spring WebFlux HandlerMapping infrastructure. Spring Cloud Gateway includes many built-in route predicate factories. All of these predicates match on different attributes of the HTTP request. You can combine multiple route predicate factories with logical and statements. <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">link</a></p>
</blockquote>
<p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。</p>
<p>Spring Cloud Gateway包括许多内置的 Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合。</p>
<p>Spring Cloud Gateway创建Route 对象时，使用RoutePredicateFactory 创建 Predicate对象，Predicate 对象可以赋值给Route。Spring Cloud Gateway 包含许多内置的 Route Predicate Factories。<br>所有这些谓词都匹配 HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。</p>
<blockquote>
<p>predicate<br>美: [‘predɪkeɪt] 英: [‘predɪkət]<br>v. 断言；使基于；使以…为依据；表明<br>adj. 述语的；谓项的<br>n. 谓语（句子成分，对主语加以陈述，如 John went home 中的 went home）</p>
</blockquote>
<p><strong>常用的Route Predicate Factory</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220221115030672.png" style="zoom:80%;" />

<ul>
<li>The After Route Predicate Factory</li>
<li>The Before Route Predicate Factory</li>
<li>The Between Route Predicate Factory</li>
<li>The Cookie Route Predicate Factory</li>
<li>The Header Route Predicate Factory</li>
<li>The Host Route Predicate Factory</li>
<li>The Method Route Predicate Factory</li>
<li>The Path Route Predicate Factory</li>
<li>The Query Route Predicate Factory</li>
<li>The RemoteAddr Route Predicate Factory</li>
<li>The weight Route Predicate Factory</li>
</ul>
<p><strong>讨论几个Route Predicate Factory</strong></p>
<p><strong>The After Route Predicate Factory</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="comment"># 这个时间后才能起效</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>可以通过下述方法获得上述格式的时间戳字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2021-02-22T15:51:37.485+08:00[Asia/Shanghai]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>The Between Route Predicate Factory</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="comment"># 两个时间点之间</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<p><strong>The Cookie Route Predicate Factory</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br></pre></td></tr></table></figure>

<p>The cookie route predicate factory takes two parameters, the cookie name and a regular expression.</p>
<p>This predicate matches cookies that have the given name and whose values match the regular expression.</p>
<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令相当于发get请求，且没带cookie</span></span><br><span class="line">curl http://localhost:9527/payment/lb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带cookie的</span></span><br><span class="line">curl http://localhost:9527/payment/lb --cookie <span class="string">&quot;chocolate=chip&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>The Header Route Predicate Factory</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<p>The header route predicate factory takes two parameters, the header name and a regular expression.</p>
<p>This predicate matches with a header that has the given name whose value matches the regular expression.</p>
<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带指定请求头的参数的CURL命令</span></span><br><span class="line">curl http://localhost:9527/payment/lb -H <span class="string">&quot;X-Request-Id:123&quot;</span></span><br></pre></td></tr></table></figure>

<p>其它的，举一反三。</p>
<p><strong>小结</strong></p>
<p>说白了，<strong>Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理</strong>。</p>
<h3 id="GateWay的Filter"><a href="#GateWay的Filter" class="headerlink" title="GateWay的Filter"></a>GateWay的Filter</h3><p>官方文档</p>
<blockquote>
<p>Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p>
</blockquote>
<p>路由过滤器可用于<strong>修改进入的HTTP请求和返回的HTTP响应</strong>，路由过滤器只能<strong>指定路由进行使用</strong>。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。</p>
<p>Spring Cloud Gateway的Filter：</p>
<ul>
<li>生命周期：<ul>
<li>pre</li>
<li>post</li>
</ul>
</li>
<li>种类（具体看官方文档）：<ul>
<li>GatewayFilter - 有31种</li>
<li>GlobalFilter - 有10种</li>
</ul>
</li>
</ul>
<p>常用的GatewayFilter：<code>AddRequestParameterGatewayFilter</code></p>
<p>自定义全局GlobalFilter：</p>
<p>两个主要接口介绍：</p>
<ol>
<li>GlobalFilter</li>
<li>Ordered</li>
</ol>
<p>能干什么：</p>
<ol>
<li>全局日志记录</li>
<li>统一网关鉴权</li>
<li>…</li>
</ol>
<p><strong>代码案例：</strong></p>
<p>GateWay9527项目添加MyLogGateWayFilter类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;***********come in MyLogGateWayFilter:  &quot;</span>+ <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>启动：</p>
<p>EurekaMain7001<br>PaymentMain8001<br>GateWayMain9527<br>PaymentMain8002<br>浏览器输入：</p>
<p><a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a> - 访问异常<br><a href="http://localhost:9527/payment/lb?uname=abc">http://localhost:9527/payment/lb?uname=abc</a> - 正常访问</p>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="Config分布式配置中心介绍"><a href="#Config分布式配置中心介绍" class="headerlink" title="Config分布式配置中心介绍"></a>Config分布式配置中心介绍</h3><p><strong>分布式系统面临的配置问题</strong></p>
<p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套<strong>集中式的</strong>、<strong>动态的</strong>配置管理设施是必不可少的。</p>
<p>SpringCloud提供了<strong>ConfigServer</strong>来解决这个问题，我们每一个微服务自己带着一个<strong>application.yml</strong>，上百个配置文件的管理.……</p>
<p><strong>是什么？</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302191903393.png" style="zoom:80%;" />

<p>SpringCloud Config为微服务架构中的微服务提供<strong>集中化的外部配置</strong>支持，<strong>配置服务器</strong>为各个不同微服务应用的所有环境提供了一个中心化的外部配置。</p>
<p><strong>怎么玩？</strong></p>
<p>SpringCloud Config分为<strong>服务端</strong>和<strong>客户端</strong>两部分。</p>
<ul>
<li>服务端也称为<strong>分布式配置中心</strong>，它是一个独立的微服务应用，用来<strong>连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口</strong>。</li>
<li>客户端则是通过指定的配置中心来<strong>管理应用资源</strong>，以及<strong>与业务相关的配置内容</strong>，并在启动的时候<strong>从配置中心获取和加载配置信息</strong>配置服务器<strong>默认采用git来存储配置信息</strong>，这样就有助于<strong>对环境配置进行版本管理</strong>，并且可以<strong>通过git客户端工具来方便的管理和访问配置内容</strong>。</li>
</ul>
<p><strong>能干嘛？</strong></p>
<ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露 - post/curl访问刷新即可…</li>
</ul>
<p><strong>与GitHub整合配置</strong></p>
<p>由于SpringCloud Config默认使用Git来存储配置文件（也有其它方式，比如支持SVN和本地文件），但最推荐的还是Git，而且使用的是http/https访问的形式。</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">官网</a></p>
<h3 id="Config配置总控中心搭建"><a href="#Config配置总控中心搭建" class="headerlink" title="Config配置总控中心搭建"></a>Config配置总控中心搭建</h3><p>用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository。</p>
<p>由上一步获得刚新建的git地址 - <code>git@github.com:abc/springcloud-config.git</code>。</p>
<p>本地硬盘目录上新建git仓库并clone。</p>
<ul>
<li>工作目录为D:\SpringCloud2021</li>
<li><code>git clone git@github.com:abc/springcloud-config.git</code></li>
</ul>
<p>此时在工作目录会创建名为springcloud-config的文件夹。</p>
<p>在springcloud-config的文件夹种创建三个配置文件（为本次教学使用的），随后 <code>git add .</code>，<code>git commit -m &quot;sth&quot;</code> 等一系列上传操作上传到springcloud-config的新Repository。</p>
<ul>
<li><p>config-dev.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">&quot;master branch,springcloud-config/config-dev.yml version=7&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>config-prod.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">&quot;master branch,springcloud-config/config-prod.yml version=1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>config-test.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">&quot;master branch,springcloud-config/config-test.yml version=1&quot;</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfigCenter</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-config-center-3344<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:zzyybs/springcloud-config.git</span> <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">#搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">#读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterMain3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(ConfigCenterMain3344.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>windows下修改hosts文件，增加映射</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">127.0.0.1 config-3344.com</span><br></pre></td></tr></table></figure></li>
<li><p>测试通过Config微服务是否可以从GitHub上获取配置内容</p>
<ul>
<li><p>启动ConfigCenterMain3344</p>
</li>
<li><p>浏览器防问 - <a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p>
</li>
<li><p>页面返回结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: &quot;master branch,springcloud-config/config-dev.yml version=7&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置读取规则</p>
<ul>
<li><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start">官方文档</a></p>
</li>
<li><p><code>/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</code>（推荐）</p>
<ul>
<li>master分支<br><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a><br><a href="http://config-3344.com:3344/master/config-test.yml">http://config-3344.com:3344/master/config-test.yml</a><br><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></li>
<li>dev分支<br><a href="http://config-3344.com:3344/dev/config-dev.yml">http://config-3344.com:3344/dev/config-dev.yml</a><br><a href="http://config-3344.com:3344/dev/config-test.yml">http://config-3344.com:3344/dev/config-test.yml</a><br><a href="http://config-3344.com:3344/dev/config-prod.yml">http://config-3344.com:3344/dev/config-prod.yml</a></li>
</ul>
</li>
<li><p><code>/&#123;application&#125;-&#123;profile&#125;.yml</code></p>
<p><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a><br><a href="http://config-3344.com:3344/config-test.yml">http://config-3344.com:3344/config-test.yml</a><br><a href="http://config-3344.com:3344/config-prod.yml">http://config-3344.com:3344/config-prod.yml</a><br><a href="http://config-3344.com:3344/config-xxxx.yml(%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%85%8D%E7%BD%AE)">http://config-3344.com:3344/config-xxxx.yml(不存在的配置)</a></p>
</li>
<li><p><code>/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</code></p>
<p><a href="http://config-3344.com:3344/config/dev/master">http://config-3344.com:3344/config/dev/master</a><br><a href="http://config-3344.com:3344/config/test/master">http://config-3344.com:3344/config/test/master</a><br><a href="http://config-3344.com:3344/config/test/dev">http://config-3344.com:3344/config/test/dev</a></p>
</li>
<li><p>重要配置细节总结</p>
<p><code>/&#123;name&#125;-&#123;profiles&#125;.yml</code><br><code>/&#123;label&#125;-&#123;name&#125;-&#123;profiles&#125;.yml</code><br><code>label</code>：分支（branch）<br><code>name</code>：服务名<br><code>profiles</code>：环境（dev/test/prod）<br>成功实现了用SpringCloud Config通过GitHub获取配置信息</p>
</li>
</ul>
</li>
</ol>
<h3 id="Config客户端配置与测试"><a href="#Config客户端配置与测试" class="headerlink" title="Config客户端配置与测试"></a>Config客户端配置与测试</h3><p><strong>新建cloud-config-client-3355</strong></p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-config-client-3355<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>bootstrap.yml</strong></p>
<p>applicaiton.yml 是<strong>用户级的资源配置项</strong>。</p>
<p>bootstrap.yml是<strong>系统级</strong>的，<strong>优先级更加高</strong></p>
<p><strong>Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文</strong>。</p>
<p>初始化的时候，BootstrapContext 负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。</p>
<p>Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。<strong>Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离</strong>。</p>
<p>要将Client模块下的 application.yml文件改为 bootstrap.yml，这是很关键的，因为 bootstrap.yml是比 application.yml先加载的。bootstrap.yml优先级高于application.yml。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改config-dev.yml配置并提交到GitHub中，比如加个变量age或者版本号version</p>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientMain3355</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(ConfigClientMain3355.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ul>
<li><p>启动Config配置中心3344微服务并自测</p>
<p><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a><br><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p>
</li>
<li><p>启动3355作为Client准备访问</p>
<p><a href="http://localhost:3355/configlnfo">http://localhost:3355/configlnfo</a></p>
</li>
</ul>
<p><strong>成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可随时而来</strong></p>
<p><strong>分布式配置的动态刷新问题</strong></p>
<ul>
<li>Linux运维修改GitHub上的配置文件内容做调整</li>
<li>刷新3344，发现ConfigServer配置中心立刻响应</li>
<li>刷新3355，发现ConfigClient客户端没有任何响应</li>
<li>3355没有变化除非自己重启或者重新加载</li>
<li>难到每次运维修改配置文件，客户端都需要重启？噩梦</li>
</ul>
</li>
</ol>
<h3 id="Config动态刷新之手动版"><a href="#Config动态刷新之手动版" class="headerlink" title="Config动态刷新之手动版"></a>Config动态刷新之手动版</h3><p>避免每次更新配置都要重启客户端微服务3355</p>
<p><strong>动态刷新步骤</strong>：</p>
<p>修改3355模块</p>
<ol>
<li><p>POM引入actuator监控</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改YML，添加暴露监控端口配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>@RefreshScope</code> 业务类Controller修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">//&lt;-----</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>此时修改github配置文件内容 -&gt; 访问3344 -&gt; 访问3355</p>
<p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<p>3355改变没有？没有，还需一步</p>
<p>需要运维人员发送Post请求刷新3355</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:3355/actuator/refresh&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>再次测试</p>
<p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<p>3355改变没有？改了。</p>
<p>成功实现了客户端3355刷新到最新配置内容，避免了服务重启</p>
<p>想想还有什么问题？</p>
<ul>
<li>假如有多个微服务客户端3355/3366/3377</li>
<li>每个微服务都要执行—次post请求，手动刷新？</li>
<li>可否广播，一次通知，处处生效？</li>
<li>我们想大范围的自动刷新，求方法</li>
</ul>
</li>
</ol>
<h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><h3 id="Bus消息总线是什么"><a href="#Bus消息总线是什么" class="headerlink" title="Bus消息总线是什么"></a>Bus消息总线是什么</h3><p><strong>上—讲解的加深和扩充</strong></p>
<p>一言以蔽之，分布式自动刷新配置功能。</p>
<p><strong>是什么？</strong></p>
<p>Spring Cloud Bus 配合Spring Cloud Config 使用可以实现配置的动态刷新。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302213852316.png"></p>
<p>Spring Cloud Bus是用来<strong>将分布式系统的节点与轻量级消息系统链接起来</strong>的框架，它<strong>整合了Java的事件处理机制和消息中间件的功能</strong>。Spring Cloud Bus目前支持RabbitMQ和Kafka。</p>
<p><strong>能干嘛?</strong></p>
<p>Spring Cloud Bus能<strong>管理和传播分布式系统间的消息</strong>，就像一个<strong>分布式执行器</strong>，可<strong>用于广播状态更改、事件推送</strong>等，也可以当作<strong>微服务间的通信通道</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302214224009.png" style="zoom: 67%;" />

<p><strong>为何被称为总线？</strong></p>
<p><strong>什么是总线</strong></p>
<p>在微服务架构的系统中，通常会<strong>使用轻量级的消息代理来构建一个共用的消息主题</strong>，并让系统中所有微服务实例都连接上来。由于<strong>该主题中产生的消息会被所有实例监听和消费</strong>，所以称它为<strong>消息总线</strong>。<strong>在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息</strong>。</p>
<p><strong>基本原理</strong></p>
<p>ConfigClient实例都<strong>监听MQ</strong>中<strong>同一个topic</strong>（默认是Spring Cloud Bus）。当一个<strong>服务刷新数据的时候</strong>，它会<strong>把这个信息放入到Topic中</strong>，这样其它监听同一Topic的服务就能<strong>得到通知</strong>，然后去<strong>更新自身的配置</strong>。</p>
<h3 id="Bus之RabbitMQ环境配置"><a href="#Bus之RabbitMQ环境配置" class="headerlink" title="Bus之RabbitMQ环境配置"></a>Bus之RabbitMQ环境配置</h3><ul>
<li><p>安装Erlang，<a href="http://erlang.org/download/otp_win64_21.3.exe">下载地址</a></p>
</li>
<li><p>安装RabbitMQ，<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe">下载地址</a></p>
</li>
<li><p>打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\devSoft\RabbitMQ Scrverk\rabbitmq_server-3.7.14\sbin</p>
</li>
<li><p>输入以下命令启动管理功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样就可以添加可视化插件。</p>
<p>访问地址查看是否安装成功：<a href="http://localhost:15672/">http://localhost:15672/</a></p>
<p>输入账号密码并登录：guest guest</p>
<h3 id="Bus动态刷新全局广播的设计思想和选型"><a href="#Bus动态刷新全局广播的设计思想和选型" class="headerlink" title="Bus动态刷新全局广播的设计思想和选型"></a>Bus动态刷新全局广播的设计思想和选型</h3><p>必须先具备良好的RabbitMQ环境先</p>
<p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366</p>
<p>新建cloud-config-client-3366</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-config-client-3366<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3366</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientMain3366</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3366.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">configInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;serverPort: &quot;</span>+serverPort+<span class="string">&quot;\t\n\n configInfo: &quot;</span>+configInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>设计思想</strong></p>
<ol>
<li><p>利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302215858369.png" style="zoom:80%;" /></li>
<li><p>利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302215942988.png" style="zoom:80%;" /></li>
</ol>
<p>图二的架构显然更加适合，图—不适合的原因如下：</p>
<ul>
<li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</li>
<li>破坏了微服务各节点的对等性。</li>
<li>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li>
</ul>
<h3 id="Bus动态刷新全局广播配置实现"><a href="#Bus动态刷新全局广播配置实现" class="headerlink" title="Bus动态刷新全局广播配置实现"></a>Bus动态刷新全局广播配置实现</h3><p><strong>给cloud-config-center-3344配置中心服务端添加消息总线支持</strong></p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org-springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:zzyybs/springcloud-config.git</span> <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">          <span class="comment">#搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">#读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#rabbitmq相关配置&lt;--------------------------</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置,暴露bus刷新配置的端点&lt;--------------------------</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span> <span class="comment">#暴露bus刷新配置的端点</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>给cloud-config-client-3355客户端添加消息总线支持</strong></p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org-springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口&lt;----------------------</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>给cloud-config-client-3366客户端添加消息总线支持</strong></p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org-springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3366</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口&lt;-----------------------</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>启动</p>
<ul>
<li>EurekaMain7001</li>
<li>ConfigcenterMain3344</li>
<li>ConfigclientMain3355</li>
<li>ConfigclicntMain3366</li>
</ul>
<p>运维工程师</p>
<p>修改Github上配置文件内容，增加版本号</p>
<p>发送POST请求</p>
<ul>
<li><p><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;</code></p>
</li>
<li><p><strong>一次发送，处处生效</strong></p>
</li>
</ul>
<p>配置中心</p>
<ul>
<li><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a></li>
</ul>
<p>客户端</p>
<ul>
<li><a href="http://localhost:3355/configlnfo">http://localhost:3355/configlnfo</a></li>
<li><a href="http://localhost:3366/configInfo">http://localhost:3366/configInfo</a></li>
<li>获取配置信息，发现都已经刷新了</li>
</ul>
<p><strong>—次修改，广播通知，处处生效</strong></p>
</li>
</ol>
<h3 id="Bus动态刷新定点通知"><a href="#Bus动态刷新定点通知" class="headerlink" title="Bus动态刷新定点通知"></a>Bus动态刷新定点通知</h3><p>不想全部通知，只想定点通知</p>
<ul>
<li>只通知3355</li>
<li>不通知3366</li>
</ul>
<p>简单一句话 - 指定具体某一个实例生效而不是全部</p>
<ul>
<li>公式：<a href="http://localhost:3344/actuator/bus-refresh/%7Bdestination%7D">http://localhost:3344/actuator/bus-refresh/{destination}</a></li>
<li>/bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例</li>
</ul>
<p>案例</p>
<p>我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:3344/actuator/bus-refresh/config-client:3355</span></span><br></pre></td></tr></table></figure>

<p>通知总结</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302224948964.png" style="zoom:80%;" />

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="Stream为什么被引入"><a href="#Stream为什么被引入" class="headerlink" title="Stream为什么被引入"></a>Stream为什么被引入</h3><p>常见MQ（消息中间件）：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>有没有一种新的技术诞生，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，<strong>自动的给我们在各种MQ内切换</strong>。（类似于Hibernate）</p>
<p>Cloud Stream是什么？<strong>屏蔽底层消息中间件的差异，降低切换成本，统一消息</strong>的<strong>编程模型</strong>。</p>
<h3 id="Stream是什么及Binder介绍"><a href="#Stream是什么及Binder介绍" class="headerlink" title="Stream是什么及Binder介绍"></a>Stream是什么及Binder介绍</h3><p><a href="https://spring.io/projects/spring-cloud-stream#overview">官方文档1</a></p>
<p><a href="https://cloud.spring.io/spring-tloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/Spring">官方文档2</a></p>
<p><a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">Cloud Stream中文指导手册</a></p>
<p><strong>什么是Spring Cloud Stream？</strong></p>
<p>官方定义Spring Cloud Stream是一个<strong>构建消息驱动微服务</strong>的框架。</p>
<p>应用程序通过<strong>inputs</strong>或者<strong>outputs</strong>来与Spring Cloud Stream中binder对象交互。</p>
<p>通过我们配置来<strong>binding</strong>（绑定），而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。</p>
<p>通过使用<strong>Spring Integration</strong>来<strong>连接消息代理中间件以实现消息事件驱动</strong>。<br>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了<strong>发布-订阅</strong>、<strong>消费组</strong>、<strong>分区</strong>的三个核心概念。</p>
<p>目前仅支持RabbitMQ、 Kafka。</p>
<h3 id="Stream的设计思想"><a href="#Stream的设计思想" class="headerlink" title="Stream的设计思想"></a>Stream的设计思想</h3><p><strong>标准MQ</strong></p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302225509976.png"></p>
<ul>
<li>生产者/消费者之间靠消息媒介传递信息内容</li>
<li>消息必须走特定的通道 - <strong>消息通道 Message Channel</strong></li>
<li>消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口<strong>SubscribableChannel</strong>，由MessageHandler消息处理器所订阅。</li>
</ul>
<p><strong>为什么用Cloud Stream？</strong></p>
<p>比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302230008816.png" style="zoom:80%;" />

<p>这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候Spring Cloud Stream给我们提供了—种解耦合的方式。</p>
<p><strong>Stream凭什么可以统一底层差异？</strong></p>
<p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义<strong>绑定器作为中间层</strong>，<strong>完美地实现了应用程序与消息中间件细节之间的隔离</strong>。<strong>通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现</strong>。</p>
<p><strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</strong>。</p>
<p><strong>Binder</strong>：</p>
<ul>
<li>INPUT对应于消费者</li>
<li>OUTPUT对应于生产者</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302230406723.png" style="zoom: 80%;" />

<p><strong>Stream中的消息通信方式遵循了发布-订阅模式</strong></p>
<p>Topic主题进行广播</p>
<ul>
<li>在RabbitMQ就是Exchange</li>
<li>在Kakfa中就是Topic</li>
</ul>
<h3 id="Stream编码常用注解简介"><a href="#Stream编码常用注解简介" class="headerlink" title="Stream编码常用注解简介"></a>Stream编码常用注解简介</h3><p><strong>Spring Cloud Stream标准流程套路</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302230648087.png" style="zoom:80%;" />

<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220302231109871.png"></p>
<ul>
<li>Binder - 很方便的连接中间件，<strong>屏蔽差异</strong>。</li>
<li>Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现<strong>存储和转发的媒介</strong>，通过Channel对队列进行配置。</li>
<li>Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</li>
</ul>
<p><strong>编码API和常用注解</strong></p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Middleware</td>
<td>中间件，目前只支持RabbitMQ和Kafka</td>
</tr>
<tr>
<td>Binder</td>
<td>Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以<strong>动态的改变消息类型</strong>（对应于Kafka的topic，RabbitMQ的exchange），这些都可以<strong>通过配置文件来实现</strong></td>
</tr>
<tr>
<td>@Input</td>
<td>注解标识输入通道，通过该输入通道接收到的消息进入应用程序</td>
</tr>
<tr>
<td>@Output</td>
<td>注解标识输出通道，发布的消息将通过该通道离开应用程序</td>
</tr>
<tr>
<td>@StreamListener</td>
<td>监听队列，用于消费者的队列的消息接收</td>
</tr>
<tr>
<td>@EnableBinding</td>
<td>指信道channel和exchange绑定在一起</td>
</tr>
</tbody></table>
<p>案例说明</p>
<p>准备RabbitMQ环境（Bus之RabbitMQ环境配置有提及）</p>
<p>工程中新建三个子模块</p>
<ul>
<li>cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块</li>
<li>cloud-stream-rabbitmq-consumer8802，作为消息接收模块</li>
<li>cloud-stream-rabbitmq-consumer8803，作为消息接收模块</li>
</ul>
<h3 id="Stream消息驱动之生产者"><a href="#Stream消息驱动之生产者" class="headerlink" title="Stream消息驱动之生产者"></a>Stream消息驱动之生产者</h3><p>新建Module：cloud-stream-rabbitmq-provider8801</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-stream-rabbitmq-provider8801<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--基础配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">          <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类StreamMQMain8801</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8801</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<ol>
<li><p>发送消息接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送消息接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span> <span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;*****serial: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.springcloud.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>测试</p>
<p>启动 7001eureka<br>启动 RabpitMq（Bus之RabbitMQ环境配置）</p>
<ul>
<li>rabbitmq-plugins enable rabbitmq_management</li>
<li><a href="http://localhost:15672/">http://localhost:15672/</a></li>
</ul>
<p>启动 8801<br>访问 - <a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<ul>
<li>后台将打印serial: UUID字符串</li>
</ul>
</li>
</ol>
<h3 id="Stream消息驱动之消费者"><a href="#Stream消息驱动之消费者" class="headerlink" title="Stream消息驱动之消费者"></a>Stream消息驱动之消费者</h3><p>新建Module：cloud-stream-rabbitmq-consumer8802</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>LearnCloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-stream-rabbitmq-consumer8802<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--基础配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">          <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类StreamMQMain8802</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8802</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListenerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号,-----&gt;接受到的消息: &quot;</span>+message.getPayload()+<span class="string">&quot;\t  port: &quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试<br>启动EurekaMain7001</p>
<p>启动StreamMQMain8801</p>
<p>启动StreamMQMain8802</p>
<p>8801发送8802接收消息</p>
</li>
</ol>
<h3 id="Stream之消息重复消费"><a href="#Stream之消息重复消费" class="headerlink" title="Stream之消息重复消费"></a>Stream之消息重复消费</h3><p>依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。</p>
<p><strong>启动</strong></p>
<ul>
<li>RabbitMQ</li>
<li>服务注册 - 8801</li>
<li>消息生产 - 8801</li>
<li>消息消费 - 8802</li>
<li>消息消费 - 8803</li>
</ul>
<p><strong>运行后有两个问题</strong></p>
<ol>
<li>有重复消费问题</li>
<li>消息持久化问题</li>
</ol>
<p><strong>消费</strong></p>
<ul>
<li><a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></li>
<li>目前是8802/8803同时都收到了，存在重复消费问题</li>
<li>如何解决：分组和持久化属性group（重要）</li>
</ul>
<p><strong>生产实际案例</strong></p>
<p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以<strong>使用Stream中的消息分组来解决</strong>。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303151911796.png"></p>
<p>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的（重复消费）。    </p>
<h3 id="Stream之group解决消息重复消费"><a href="#Stream之group解决消息重复消费" class="headerlink" title="Stream之group解决消息重复消费"></a>Stream之group解决消息重复消费</h3><p><strong>原理</strong></p>
<p><strong>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次</strong>。</p>
<p><strong>不同的组</strong>是可以<strong>重复消费</strong>的，<strong>同一个组</strong>内会发生<strong>竞争关系</strong>，只有其中一个可以消费。</p>
<p>8802/8803都变成不同组，group两个不同</p>
<p>group: A_Group、B_Group</p>
<p><strong>8802修改YML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">           <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">A_Group</span> <span class="comment">#&lt;----------------------------------------关键</span></span><br></pre></td></tr></table></figure>

<p><strong>8803修改YML</strong>（与8802的类似位置 <code>group: B_Group</code>）</p>
<p>结论：<strong>还是重复消费</strong></p>
<p>8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。</p>
<p>多数情况，产者发送消息给某个具体微服务时只希望被消费一次,按照上面我们启动两个应用的例子，虽然它们同属一个应用，但是这个消息出现了被重复消费两次的情况。为了解决这个问题，在Spring Cloud Stream中提供了<strong>消费组</strong>的概念。</p>
<p><strong>8802/8803都变成相同组，group两个相同</strong></p>
<p>group: A_Group</p>
<p>8802修改YML<code>group: A_Group</code></p>
<p>8803修改YML<code>group: A_Group</code></p>
<p>结论：同一个组的多个微服务实例，每次只会有一个拿到</p>
<h3 id="Stream之消息持久化"><a href="#Stream之消息持久化" class="headerlink" title="Stream之消息持久化"></a>Stream之消息持久化</h3><p>通过上述，解决了重复消费问题，再看看持久化。</p>
<p>停止8802/8803并<strong>去除掉</strong>8802的分组<code>group: A_Group</code>，8803的分组<code>group: A_Group</code>没有去掉。</p>
<p>8801先发送4条消息到RabbitMq。</p>
<p>先启动8802，<strong>无分组属性配置</strong>，后台没有打出来消息。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303153337766.png" style="zoom: 65%;" />

<p>再启动8803，<strong>有分组属性配置</strong>，后台打出来了MQ上的消息。(消息持久化体现)</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303153418900.png" style="zoom:65%;" />

<h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><h3 id="Sleuth是什么？"><a href="#Sleuth是什么？" class="headerlink" title="Sleuth是什么？"></a>Sleuth是什么？</h3><p><strong>为什么会出现这个技术？要解决哪些问题？</strong></p>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303153923693.png" style="zoom:80%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303153957364.png" style="zoom:67%;" />

<p><strong>是什么？</strong></p>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-sleuth">官网地址</a></li>
<li>Spring Cloud Sleuth提供了一套完整的<strong>服务跟踪</strong>的解决方案</li>
<li>在分布式系统中提供追踪解决方案并且兼容支持了zipkin</li>
</ul>
<p><strong>解决</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303154114804.png" style="zoom:80%;" />

<blockquote>
<p>sleuth<br>英 [sluːθ] 美 [sluːθ]<br>n. 侦探</p>
</blockquote>
<h3 id="Sleuth之zipkin搭建安装"><a href="#Sleuth之zipkin搭建安装" class="headerlink" title="Sleuth之zipkin搭建安装"></a>Sleuth之zipkin搭建安装</h3><p>zipkin</p>
<ol>
<li><p><strong>下载</strong></p>
<ul>
<li>SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可</li>
<li><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></li>
<li>zipkin-server-2.12.9-exec.jar</li>
</ul>
</li>
<li><p><strong>运行jar</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar</span><br></pre></td></tr></table></figure></li>
<li><p><strong>运行控制台</strong></p>
<p><a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p>
</li>
<li><p><strong>术语</strong></p>
<p>完整的调用链路</p>
<p>表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303154412183.png" style="zoom: 75%;" />

<p>—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303154508694.png" style="zoom:75%;" />

<p>整个链路的依赖关系如下：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303154550508.png"></p>
<p>名词解释</p>
<ul>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li>
<li>span：表示调用链路来源，通俗的理解span就是一次请求信息</li>
</ul>
</li>
</ol>
<h3 id="Sleuth链路监控展现"><a href="#Sleuth链路监控展现" class="headerlink" title="Sleuth链路监控展现"></a>Sleuth链路监控展现</h3><p>服务提供者 cloud-provider-payment8001</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zipkin:</span> <span class="comment">#&lt;-------------------------------------关键 </span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span> <span class="comment">#&lt;-------------------------------------关键</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">    <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>            <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>             <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类 PaymentController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@GetMapping(&quot;/payment/zipkin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentZipkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>服务消费者（调用方）cloue-consumer-order80</p>
<ol>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--包含了sleuth+zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line">    <span class="attr">zipkin:</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">        <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类 OrderController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ====================&gt; zipkin+sleuth</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentZipkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = restTemplate.getForObject(<span class="string">&quot;http://localhost:8001&quot;</span>+<span class="string">&quot;/payment/zipkin/&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>依次启动eureka7001/8001/80 - 80调用8001几次测试下</p>
</li>
<li><p>打开浏览器访问：<a href="http://localhost:9411/">http://localhost:9411</a></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220303155242808.png" style="zoom:80%;" /></li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://blog.csdn.net/u011863024/article/details/114298270">Spring Cloud 学习笔记（1 / 3）</a></strong></p>
</li>
<li><p><strong><a href="https://blog.csdn.net/u011863024/article/details/114298282">Spring Cloud 学习笔记（2 / 3）</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>后端</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/post/9a0369ec/</url>
    <content><![CDATA[<h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><p>首先，我们需要了解布隆过滤器的概念。</p>
<p>布隆过滤器（<strong>Bloom Filter</strong>）是一个叫做 Bloom 的老哥于 1970 年提出的。我们<strong>可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构</strong>。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207002507111.png" style="zoom:80%;" />

<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p>
<p>总结：<strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</strong></p>
<h2 id="布隆过滤器的原理介绍"><a href="#布隆过滤器的原理介绍" class="headerlink" title="布隆过滤器的原理介绍"></a>布隆过滤器的原理介绍</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>举个简单的例子：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207002716080.png" style="zoom:80%;" />

<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>
<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h2 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h2><p><strong>判断给定数据是否存在：</strong>比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）、邮箱的垃圾邮件过滤、黑名单功能等等。</p>
<p><strong>去重：</strong>比如爬给定网址的时候对已经爬取过的 URL 去重。</p>
<h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><h3 id="通过-Java-编程手动实现布隆过滤器"><a href="#通过-Java-编程手动实现布隆过滤器" class="headerlink" title="通过 Java 编程手动实现布隆过滤器"></a>通过 Java 编程手动实现布隆过滤器</h3><p>我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。</p>
<p>如果你想要手动实现一个的话，你需要：</p>
<ol>
<li>一个合适大小的位数组保存数据</li>
<li>几个不同的哈希函数</li>
<li>添加元素到位数组（布隆过滤器）的方法实现</li>
<li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li>
</ol>
<p>下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建 6 个不同的哈希函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SEEDS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> SimpleHash[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBloomFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> SimpleHash(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(<span class="keyword">int</span> cap, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">            <span class="keyword">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="keyword">null</span>) ? <span class="number">0</span> : Math.abs(seed * (cap - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String value1 = <span class="string">&quot;https://javaguide.cn/&quot;</span>;</span><br><span class="line">	String value2 = <span class="string">&quot;https://github.com/Snailclimb&quot;</span>;</span><br><span class="line">	MyBloomFilter filter = <span class="keyword">new</span> MyBloomFilter();</span><br><span class="line">	System.out.println(filter.contains(value1));</span><br><span class="line">	System.out.println(filter.contains(value2));</span><br><span class="line">	filter.add(value1);</span><br><span class="line">	filter.add(value2);</span><br><span class="line">	System.out.println(filter.contains(value1));</span><br><span class="line">	System.out.println(filter.contains(value2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer value1 = <span class="number">13423</span>;</span><br><span class="line">    Integer value2 = <span class="number">22131</span>;</span><br><span class="line">    MyBloomFilter filter = <span class="keyword">new</span> MyBloomFilter();</span><br><span class="line">    System.out.println(filter.contains(value1));</span><br><span class="line">    System.out.println(filter.contains(value2));</span><br><span class="line">    filter.add(value1);</span><br><span class="line">    filter.add(value2);</span><br><span class="line">    System.out.println(filter.contains(value1));</span><br><span class="line">    System.out.println(filter.contains(value2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<h3 id="利用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#利用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="利用 Google 开源的 Guava 中自带的布隆过滤器"></a>利用 Google 开源的 Guava 中自带的布隆过滤器</h3><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">        Funnels.integerFunnel(),</span><br><span class="line">        <span class="number">1500</span>,</span><br><span class="line">        <span class="number">0.01</span>);</span><br><span class="line">    <span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">    filter.put(<span class="number">1</span>);</span><br><span class="line">    filter.put(<span class="number">2</span>);</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p>
<h2 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：<a href="https://redis.io/modules">https://redis.io/modules</a></p>
<p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a> 其他还有：</p>
<ul>
<li><a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter">redis-lua-scaling-bloom-filter（lua 脚本实现）</a></li>
<li><a href="https://github.com/seomoz/pyreBloom">pyreBloom（Python 中的快速 Redis 布隆过滤器）</a></li>
<li>……</li>
</ul>
<p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p>
<h3 id="使用-Docker-安装"><a href="#使用-Docker-安装" class="headerlink" title="使用 Docker 安装"></a>使用 Docker 安装</h3><p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！直接在 Google 搜索 <strong>docker redis bloomfilter</strong> 然后在排除广告的第一条搜素结果就找到了我们想要的答案，具体地址：<a href="https://hub.docker.com/r/redislabs/rebloom/">https://hub.docker.com/r/redislabs/rebloom/</a> 。</p>
<p><strong>具体操作如下：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">➜  ~ docker <span class="keyword">run</span><span class="bash"> -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span></span><br><span class="line">➜  ~ docker exec -it redis-redisbloom bash</span><br><span class="line">root@<span class="number">21396</span>d02c252:/data<span class="comment"># redis-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常用命令一览"><a href="#常用命令一览" class="headerlink" title="常用命令一览"></a>常用命令一览</h3><blockquote>
<p>注意： key：布隆过滤器的名称，item：添加的元素。</p>
</blockquote>
<ol>
<li><code>BF.ADD</code>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD &#123;key&#125; &#123;item&#125;</code>。</li>
<li><code>BF.MADD</code>：将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD &#123;key&#125; &#123;item&#125; [item ...]</code> 。</li>
<li><code>BF.EXISTS</code>：确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS &#123;key&#125; &#123;item&#125;</code>。</li>
<li><code>BF.MEXISTS</code> ：确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS &#123;key&#125; &#123;item&#125; [item ...]</code>。</li>
</ol>
<p>另外， <code>BF.RESERVE</code> 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<p><code>BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion]</code> 。</p>
<p>下面简单介绍一下每个参数的具体含义：</p>
<ul>
<li>key：布隆过滤器的名称</li>
<li>error_rate：期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li>
<li>capacity：过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ul>
<p>可选参数：</p>
<ul>
<li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li>
</ul>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter github</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>




<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><strong><a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">布隆过滤器</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础知识</title>
    <url>/post/1ad06ab1/</url>
    <content><![CDATA[<h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2><p><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p>
<p><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p>
<p><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</p>
<p><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</p>
<span id="more"></span>
<p>数据库系统基本构成如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" alt="数据库系统基本构成"></p>
<h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2><p><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</p>
<p><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</p>
<p><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</p>
<blockquote>
<p>例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</p>
</blockquote>
<p><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</p>
<p><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p>
<p><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。</p>
<blockquote>
<p>比如关系 工人（工号，身份证号，姓名，性别，部门）， 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</p>
</blockquote>
<p><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。</p>
<blockquote>
<p>比如关系 学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</p>
</blockquote>
<h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h2><ul>
<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2 id="为什么不推荐使用外键与级联"><a href="#为什么不推荐使用外键与级联" class="headerlink" title="为什么不推荐使用外键与级联?"></a>为什么不推荐使用外键与级联?</h2><p>对于外键和级联，阿里巴巴开发手册这样说到：</p>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>​        说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群</strong>；<strong>级联更新是强阻塞，存在数据库更新风暴的风险</strong>；<strong>外键影响数据库的插入速度</strong>。</p>
<p>为什么不要用外键呢？大部分人可能会这样回答：</p>
<ol>
<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦，测试数据极为不方便；b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>
<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增、删、更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>
<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>
<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>
<li>……</li>
</ol>
<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>
<ol>
<li>保证了数据库数据的一致性和完整性；</li>
<li>级联操作方便，减轻了程序代码量；</li>
<li>……</li>
</ol>
<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>
<h2 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h2><p>做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p>
<p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p>
<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是<strong>多对多（M: N）</strong>。另外，还有其他两种关系是：<strong>1 对 1（1:1）</strong>、<strong>1 对多（1: N）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png" alt="ER图示例"></p>
<p>试着将上面的 ER 图转换成数据库实际的关系模型（实际设计中，我们通常会将任课教师也作为一个实体来处理）：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png" alt="关系模型"></p>
<h2 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗?"></a>数据库范式了解吗?</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
<h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。</p>
<blockquote>
<p>表：学号、课程号、姓名、学分</p>
</blockquote>
<p>这个表明显说明了两个事务：学生信息，课程信息；由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p>
<p><strong>可能会存在问题：</strong></p>
<ul>
<li>数据冗余：每条记录都含有相同信息；</li>
<li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li>
<li>插入异常：学生未选课，无法记录进数据库；</li>
<li>更新异常：调整课程学分，所有行都调整。</li>
</ul>
<p>解决办法：将不符合第二范式的数据库表进行拆分。</p>
<p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p>
<h3 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h3><p><strong>函数依赖（Functional dependency）</strong>：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</p>
<p><strong>部分函数依赖（Partial functional dependency）</strong>：如果 X→Y，并且存在 X 的一个真子集 X<del>0</del>，使得 X<del>0</del>→Y，则称 Y 对 X 部分函数依赖。</p>
<blockquote>
<p>比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</p>
</blockquote>
<p><strong>完全函数依赖（Full functional dependency）</strong>：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</p>
<blockquote>
<p>比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt; (姓名)不成立，（班级）-&gt; (姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</p>
</blockquote>
<p><strong>传递函数依赖（Transitive functional dependency）</strong>： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传<strong>递函数依赖会导致数据冗余和异常</strong>。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</p>
<blockquote>
<p>比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</p>
</blockquote>
<p><strong>3NF(第三范式)</strong></p>
<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>
<p><strong>总结</strong></p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
<h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p>
<p>〖例〗：如订单表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>
<p>在<code>Rose 2002</code>中，规定列有两种类型：<strong>数据列</strong>和<strong>计算列</strong>。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。</p>
<h3 id="范式化设计和反范式化设计的优缺点"><a href="#范式化设计和反范式化设计的优缺点" class="headerlink" title="范式化设计和反范式化设计的优缺点"></a>范式化设计和反范式化设计的优缺点</h3><p><strong>范式化</strong></p>
<p>优点：</p>
<ul>
<li>可以尽量的减少数据冗余</li>
<li>数据表更新快体积小</li>
<li>范式化的更新操作比反范式化更快</li>
<li>范式化的表通常比反范式化更小</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于查询需要对多个表进行关联导致性能降低</li>
<li>更难进行索引优化</li>
</ul>
<p><strong>反范式化</strong></p>
<p>优点：</p>
<ul>
<li>可以减少表的关联</li>
<li>可以更好的进行索引优化</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在数据冗余及数据维护异常</li>
<li>对数据的修改需要更多的成本</li>
</ul>
<h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h2><p>可以把存储过程看成是一些 <strong>SQL 语句的集合，中间加了点逻辑控制语句</strong>。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候就可以写有一个存储过程，这样也方便了下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为<strong>存储过程是预编译过的</strong>。</p>
<p><strong>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</strong></p>
<blockquote>
<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>
<p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<h2 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h2><h3 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h3><p><strong>drop（丢弃数据）</strong>：<code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</p>
<p><strong>truncate（清空数据）</strong>：<code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</p>
<p><strong>delete（删除数据）</strong>：<code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</p>
<p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p>
<h3 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="属于不同的数据库语言"></a>属于不同的数据库语言</h3><p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>
<p><strong>DML 语句和 DDL 语句区别：</strong></p>
<ul>
<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>
<li>DDL 是数据定义语言（Data Definition Language）的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>
</ul>
<h3 id="执行速度不同"><a href="#执行速度不同" class="headerlink" title="执行速度不同"></a>执行速度不同</h3><p>一般来说：drop&gt;truncate&gt;delete</p>
<h2 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h2><ol>
<li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong>：包括编程、测试和试运行。</li>
<li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://javaguide.cn/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97">数据库基础知识</a></strong></p>
</li>
<li><p><strong><a href="https://segmentfault.com/a/1190000013695030">数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目学习</title>
    <url>/post/767bf05/</url>
    <content><![CDATA[<h2 id="开源项目结构"><a href="#开源项目结构" class="headerlink" title="开源项目结构"></a>开源项目结构</h2><h3 id="阿里巴巴-Java开发手册-工程结构-应用分层"><a href="#阿里巴巴-Java开发手册-工程结构-应用分层" class="headerlink" title="阿里巴巴 Java开发手册-工程结构-应用分层"></a>阿里巴巴 Java开发手册-工程结构-应用分层</h3><ol>
<li><p>【推荐】根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示， <strong>默认上层依赖于下层</strong>，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层 （Controller 层），也可以直接依赖于 Service 层，依此类推：</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211100733345.png" style="zoom: 75%;" />

<ul>
<li>开放 API 层：可直接封装 Service 接口暴露成 <strong>RPC 接口</strong>；通过 Web 封装成 <strong>http 接口</strong>；<strong>网关控制</strong>层等。</li>
<li>终端显示层：各个端的<strong>模板渲染并执行</strong>显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li>
<li>Web 层：主要是<strong>对访问控制进行转发</strong>，<strong>各类基本参数校验</strong>，或者<strong>不复用的业务简单处理</strong>等。</li>
<li>Service 层：相对<strong>具体的业务逻辑</strong>服务层。</li>
<li>Manager 层：<strong>通用业务处理</strong>层，它有如下特征：<ol>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</li>
<li>对 Service 层<strong>通用</strong>能力的下沉，如缓存方案、中间件通用处理。</li>
<li>与 DAO 层交互，对多个 DAO 的组合复用。</li>
</ol>
</li>
<li>DAO 层：<strong>数据访问</strong>层，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。</li>
<li>第三方服务：包括<strong>其它部门 RPC 服务接口</strong>，基础平台，<strong>其它公司的 HTTP 接口</strong>，如淘宝开放平台、支付宝付款服务、高德地图服务等。</li>
<li>外部数据接口：<strong>外部（应用）数据存储服务提供的接口</strong>，多见于<strong>数据迁移场景</strong>中。</li>
</ul>
</li>
<li><p>【参考】分层异常处理规约：</p>
<ul>
<li>在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 <code>catch</code>，使用 <code>catch(Exception e)</code>方式，并 <code>throw new DAOException(e)</code>，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。</li>
<li>在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息， 相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是 单独部署，则采用与 Service 一致的处理方式。</li>
<li>Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面， 尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</li>
</ul>
</li>
<li><p>【参考】分层领域模型规约：</p>
<ul>
<li>DO（Data Object）：此对象<strong>与数据库表结构一一对应</strong>，通过 DAO 层向上传输数据源对象。</li>
<li>DTO（Data Transfer Object）：数据传输对象，<strong>Service 或 Manager 向外传输</strong>的对象。</li>
<li>BO（Business Object）：业务对象，可以<strong>由 Service 层输出</strong>的<strong>封装业务逻辑</strong>的对象。</li>
<li>Query：数据查询对象，各层<strong>接收上层的查询请求</strong>。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</li>
<li>VO（View Object）：显示层对象，通常是 <strong>Web 向模板渲染引擎层传输</strong>的对象。</li>
</ul>
</li>
</ol>
<h3 id="实际项目代码结构"><a href="#实际项目代码结构" class="headerlink" title="实际项目代码结构"></a>实际项目代码结构</h3><p><strong>通常的项目结构</strong></p>
<blockquote>
<p><strong>首先说在前面的是</strong>：这东西并没有一套通用的标准，不同公司或者团队的使用习惯和规范也不尽相同。</p>
</blockquote>
<p>以当下非常火热的Spring Boot典型项目结构为例，创建出来的项目应该总体分为三大层：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211103507042.png" style="zoom:80%;" />

<ul>
<li><code>项目根目录/src/main/java</code>：放置项目Java<strong>源代码</strong></li>
<li><code>项目根目录/src/main/resources</code>：放置项目<strong>静态资源和配置文件</strong></li>
<li><code>项目根目录/src/test/java</code>：放置项目<strong>测试用例代码</strong></li>
</ul>
<p>而位于 <code>/src/main/java</code> 目录下的Java源代码的组织结构大家比较关心，这地方也只能给出一个通常典型的结构，毕竟不同项目和团队实践不一样，稍许有区别，但整体安排应该差不多。而且如果是<strong>多模块</strong>的项目的话，下面的结构应该只对应其中一个模块，其他模块的代码组织也大致差不多。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211103646545.png" style="zoom: 65%;" />

<p>各个目录详细介绍：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|<span class="built_in">_</span>annotation：放置项目自定义注解</span><br><span class="line">|<span class="built_in">_</span>aspect：放置切面代码</span><br><span class="line">|<span class="built_in">_</span>config：放置配置类</span><br><span class="line">|<span class="built_in">_</span>constant：放置常量、枚举等定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>consist：存放常量定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>enums：存放枚举定义</span><br><span class="line">|<span class="built_in">_</span>controller：放置控制器代码</span><br><span class="line">|<span class="built_in">_</span>filter：放置一些过滤、拦截相关的代码</span><br><span class="line">|<span class="built_in">_</span>mapper：放置数据访问层代码接口</span><br><span class="line">|<span class="built_in">_</span>model：放置数据模型代码</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>entity：放置数据库实体对象定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>dto：存放数据传输对象定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>vo：存放显示层对象定义</span><br><span class="line">|<span class="built_in">_</span>service：放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>intf：存放业务逻辑接口定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>impl：存放业务逻辑实际实现</span><br><span class="line">|<span class="built_in">_</span>utils：放置工具类和辅助代码</span><br></pre></td></tr></table></figure>

<p>然后接下来 <code>/src/main/resources</code> 目录，里面主要存放静态配置文件和页面静态资源等东西：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|<span class="built_in">_</span>mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><br><span class="line">|<span class="built_in">_</span>static：存放网页静态资源，比如下面的js/css/img</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>js：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>css：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>img：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>font：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>等等</span><br><span class="line">|<span class="built_in">_</span>template：存放网页模板，比如thymeleaf/freemarker模板等</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>header</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>sidebar</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>bottom</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>XXX.html等等</span><br><span class="line">|<span class="built_in">_</span>application.yml       基本配置文件</span><br><span class="line">|<span class="built_in">_</span>application-dev.yml   开发环境配置文件</span><br><span class="line">|<span class="built_in">_</span>application-test.yml  测试环境配置文件</span><br><span class="line">|<span class="built_in">_</span>application-prod.yml  生产环境配置文件</span><br></pre></td></tr></table></figure>

<p>当然，这地方估计有一个<strong>很多人都会纠结的</strong>关于<code>DTO/VO/DO</code>等<strong>数据模型定义</strong>的区分。</p>
<p>这在《阿里巴巴Java开发手册》中倒是做了一个所谓的严格区分，如上所示。</p>
<p>实际项目开发时，没有必要刻意照搬去定义这么多层对象，这样后续做对象转换非常麻烦。出于简单起见，个人觉得，只要保证业务逻辑层 <code>Service</code> 和数据库 <code>DAO</code> 层的操作对象严格划分出来，确保互相不渗透，不混用，问题应该就不大。</p>
<blockquote>
<p>比如在我上面举例的这个项目的代码结构中，<code>Service</code>层处理的对象都定义在了<code>dto</code>包里，而<code>DAO</code>层处理的对象都放在了<code>entity</code>包里了。</p>
</blockquote>
<h3 id="项目结构划分总结"><a href="#项目结构划分总结" class="headerlink" title="项目结构划分总结"></a>项目结构划分总结</h3><p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211123707245.png" style="zoom: 75%;" />

<p>对应代码目录的流转逻辑就是：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211124408586.png" style="zoom:65%;" />

<p><strong>每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</strong>。</p>
<p><strong>一些注意事项</strong></p>
<ol>
<li><code>Contorller</code> 层参数传递建议不要使用 <code>HashMap</code>，建议使用数据模型定义。</li>
<li><code>Controller</code> 层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到 <code>Service</code> 层代码中去做。</li>
<li><code>Service</code> 层做实际业务逻辑，可以按照功能模块做好定义和区分，相互可以调用。</li>
<li>功能模块 <code>Service</code> 之间引用时，建议不要渗透到 <code>DAO</code> 层（或者 <code>mapper</code> 层），基于 <code>Service</code> 层进行调用和复用比较合理。</li>
<li>业务逻辑层 <code>Service</code> 和数据库 <code>DAO</code> 层的操作对象不要混用。<code>Controller </code> 层的数据对象不要直接渗透到 <code>DAO</code>层（或者 <code>mapper</code> 层）；同理数据表实体对象 <code>Entity</code> 也不要直接传到 <code>Controller</code> 层进行输出或展示。</li>
</ol>
<h2 id="如何学习开源项目？"><a href="#如何学习开源项目？" class="headerlink" title="如何学习开源项目？"></a>如何学习开源项目？</h2><p><a href="https://juejin.cn/post/6844904067257352205">为什么要学习源码？学习源码对我们有用吗？</a></p>
<h3 id="学习的价值"><a href="#学习的价值" class="headerlink" title="学习的价值"></a>学习的价值</h3><p>总结起来，学习开源项目的价值主要包括以下几点：</p>
<ul>
<li><p>专业水平的提升</p>
<p>很多通用的专业知识，在专业领域内去到哪个公司都能通用，特别是底层方面的知识，可以在开源项目中学到，比如多线程处理、网络通信、操作系统处理等。 举个例子，通过学习Redis 的 RDB 持久化模式的“会将当前内存中的数据库快照保存到磁盘文件中”，可以学习到其实就是在操作系统fork一个子进程来实现，再继续深入的话，就涉及到父子进程机制， copy-on-write 技术。这些专业知识之间是可以联系起来的并且像一颗大树一样自我生长，但是当没理解透彻，自然没法产生联系，也就不能够自我生长了。当我们对开源项目的关键的点理解清晰，知识也随着自我生长，也就如滚雪球一样可以滚起来了。</p>
</li>
<li><p>解决问题能力的提升</p>
<p>通过学习开源项目的实现，出现线上问题时，可以快速定位问题症结所在，通过修改配置或者修改源代码来解决；或者当业务需求没有合适的开源项目能满足时，可以改造现有的开源项目来满足业务。 作为要优秀开发，避免陷入“<strong>API操作工</strong>”的被动局面，学习开源项目的一个很重要目的就是知道其功能点是如何实现且优化的，学习其中的知识好比公式的推导过程，掌握基本API使用好比会数学公式可以应付考试，但是理解好的推导过程根据有助于记忆和理解，<strong>知其然也要知其所以然</strong>，当遇那些没法套公式的情况下，我们也知道如何解决。</p>
</li>
<li><p>思维的提升</p>
<p>通过学习成熟的开源项目的优秀架构，可以总结和理解一些软件设计常用的架构思路，例如实现高可用，主要是通过集群的数据冗余，例如Kafka集群，HDSF集群；实现可扩展可以考虑把变化层和不变层隔离，把业务实现抽象化，例如Spring的预留的一些可扩展接口。</p>
</li>
</ul>
<h3 id="常见错误观点"><a href="#常见错误观点" class="headerlink" title="常见错误观点"></a>常见错误观点</h3><p>学习开源项目有一些常见的错误观点，导致新手容易望而生畏而轻易放弃，或者浪费大量时间而收获不大：</p>
<ol>
<li><p><strong>学习开源项目是架构师，技术大牛的事，我作为新手根本难以学会，就算学了也用不到。</strong></p>
<p>学习是一个过程，不是一朝一夕就可以成为大牛的，但是只要踏出第一步，总会有可能实现的大牛梦想的；另一方面，通过不断复盘不断总结，加以合适的方法论指导，相信是可以有所收获的，能力得到提升的。 学习之后对于逻辑思维，知识体系的构建有相信会有很大提升，即使项目没用到具体的开源项目，以后遇到相关问题可以触类旁通，举一反三，也是一种进步。</p>
</li>
<li><p><strong>数据结构和算法很重要，我只要学习这项目中的2方面就可以了</strong></p>
<p>不要只盯着数据结构和算法，这两点在开源项目中并没有那么重要，例如Netty中的超时队列是基于红黑树来实现的，我们其实只需要知道这一点就够了，除非需要改造这方面的功能。更重要的是理解系统的设计，功能的实现方案。</p>
</li>
<li><p><strong>一头扎进源码进行学习</strong></p>
<p>很多新手笃信社区论坛流行的一句话“Talk is cheap, show me the code”，一头扎进源码阅读，却最后陷入源码的泥潭中，在层层代码函数跳转中迷失了方向。</p>
<p>其实学习开源项目应该是<strong>自顶而下</strong>的，最底层的源码应该是最后才开始学习，在此之前，需要学习项目相关架构设计方面的知识，有了这些知识，就仿佛数据库有了索引，按照知识索引来进行源码针对性突破，如巡航导弹精准爆破，自然比地毯式轰炸更起到事半功倍的作用。</p>
</li>
</ol>
<h3 id="学习的4个层次"><a href="#学习的4个层次" class="headerlink" title="学习的4个层次"></a>学习的4个层次</h3><p>根据学习理解的深入程度不同，可以把学习分为4个层次</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211160458562.png" style="zoom:80%;" />

<ul>
<li>基础学习：对项目有一个<strong>大概性、基础性</strong>的了解，比如<strong>项目是什么，有什么作用，大概怎么用，解决了什么问题</strong>。在面试中，不少初入职场的人的简历写到用到众多的技术框架，实际上往往仅仅只到了这个层次，再深入往下问，便支支吾吾答不上来了。</li>
<li>检视学习：对项目有一个<strong>系统性</strong>的了解，<strong>系统的各方面功能</strong>，<strong>基本原理</strong>，<strong>优缺点</strong>，<strong>使用场景</strong>，<strong>各配置项</strong>、<strong>API使用</strong>。在实际工作中，如果作为一个团队的普通成员，达到这个级别已经可以满足基本业务开发需求，但是如果想有更高的技术追求，仅仅到此是不够的。</li>
<li>分析学习：在检视学习的基础上，对开源项目的<strong>各项性能参数</strong>，<strong>各自场景性能调优</strong>有比较全面的了解和实践经验。到达这个层次，在项目生产中，已经有独当一面的能力，有一定能力承担核心主力开发的角色。</li>
<li>主题学习：在分析学习的基础上，对开源项目的<strong>关键功能模块的源码</strong>有所了解，能够<strong>根据实际需要封装、修改源码</strong>，或者<strong>借鉴项目造出新的轮子</strong>。 到达这个层次，往往有一定能力承担技术负责人、技术带头人的角色。</li>
</ul>
<h3 id="学习的4个步骤"><a href="#学习的4个步骤" class="headerlink" title="学习的4个步骤"></a>学习的4个步骤</h3><p>针对上面提到的学习的层次，下面介绍如何“<strong>自顶而下</strong>”学习，来达到这4个层次。</p>
<h4 id="基础性了解学习"><a href="#基础性了解学习" class="headerlink" title="基础性了解学习"></a>基础性了解学习</h4><p>目标是达到基础学习的层次，对项目有<strong>大概性</strong>的了解，包括项目背景，解决的问题场景，项目功能，使用场景，基本的API使用。通过查找官方文档、相关博客、视频资料学习即可。</p>
<p>通过对系统有大概性了解之后，会自然而然有一些疑问，例如实现的原理，优缺点等，后续学习带着这些疑问进行学习会更高效。</p>
<h4 id="系统性学习与实践"><a href="#系统性学习与实践" class="headerlink" title="系统性学习与实践"></a>系统性学习与实践</h4><p>目标是达到检视学习的层次，对项目有<strong>系统性、全面性</strong>的了解，包括项目的功能、组成模块、基本原理、使用场景、配置项、API使用、与其他类似项目的优缺点比较等。</p>
<p>方法步骤如下：</p>
<ol>
<li><strong>安装运行</strong> 按照相关文档，安装运行项目。在这个过程中，需要关注：<ul>
<li><strong>系统的依赖组件</strong>：因为依赖组件是系统设计和实现的基础，可以了解系统一下关键信息，例如 Memcached最重要的依赖是高性能的网络库 <code>libevent</code>，我们就能大概推测 Memcached 的网络实现应该是 <code>Reactor</code> 模型的。</li>
<li><strong>安装目录</strong>：常见的安装目录是 <code>conf </code>存放配置文件，<code>logs</code> 存放日志文件，<code>bin</code> 存放日志文件，而不同项目有些特殊目录，比如Nginx有 <code>html</code>目录，这种目录能促使我们带着相关疑问继续去研究学习，带着问题去学习效率是最高的。</li>
<li><strong>系统提供的工具</strong>：需要特别<strong>关注命令行和配置文件</strong>，它们提供两个非常重要的关键信息，系统具备哪些能力和系统将会如何运行。这些信息是我们学习系统内部机制和原理的一个观察窗口。 通常情况下，如果对每个命令行参数和配置项的作用和原理基本掌握了解的话，基本上对系统已经很熟悉了。实践中，可以不断尝试去修改配置项，然后观察系统有什么变化。</li>
</ul>
</li>
<li><strong>系统性研究原理与特性</strong> 这点相当重要，因为只有清楚掌握技术的原理特性，才能算真正掌握这门技术，才能做架构设计的时候做出合理的选择，在这个过程中，需要重点关注：<ul>
<li><strong>关键特性的基本实现原理</strong>：关键特性是该开源项目流行的重要卖点，常见的有高性能、高可用、可扩展等特性，项目是如何做到的，这是我们需要重点关注的地方。</li>
<li><strong>优缺点比对分析</strong>：优缺点主要通过对比来分析，即：我们将两个类似的系统进行对比，看看它们的实现差异，以及不同的实现优缺点都是什么。典型的对比有 Memcached 和 Redis、Kafka和ActiveMQ、RocketMQ的比较。</li>
<li><strong>使用场景</strong>：项目在哪些场景适用，哪些场景不适用，业界适用常见案例等。</li>
</ul>
</li>
</ol>
<p>在此阶段可以通过学习官方技术设计文档，架构图，原理图，或者相关技术博客，通常比较热门的开源项目都有很多分析文档，我们可以站在前人的基础上避免重复投入。但需要注意的是，<strong>由于经验、水平、关注点、使用的版本不同等差异，不同的人分析的结论可能有差异，甚至有的是错误的</strong>，因此不能完全参照。一个比较好的方式就是多方对照，也就是说看很多篇分析文档，比较它们的内容共同点和差异点。</p>
<p>同时，如果有些技术点难以查到资料，自己又不确定，可以通过写Example进行验证，通过日志打印、调试、监测工具观察理解具体的细节。例如可以写一个简单程序使用Netty，通过抓包工具观察网络包来理解其中的实现。</p>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><p>如果是只是自己学习和研究，可以参考网上测试和分析的文档，但是<strong>如果要在生产环境投入使用必须进行测试</strong>。因为网上搜的测试结果，不一定与自己的业务场景很契合，如果简单参考别人的测试结果，很可能会得出错误的结论，或者使用的版本不同，测试结果差异也比较大。</p>
<p>要特别注意的是，测试必须建立在对这个开源项目有<strong>系统性</strong>了解的基础上，不能安装完就立马测试，否则可能会因为配置项不对，使用方法不当，导致没有根据业务的特点搭建正确的环境、没有设计合理的测试用例，从而使得最终的测试结果得出了错误结论，误导了设计决策。</p>
<p>下面提供测试常见的思路参考，需要根据具体项目具体业务进行测试用例的设计。</p>
<ul>
<li>核对每个配置项的作用和影响，识别出关键配置项</li>
<li>进行多种场景的性能测试</li>
<li>进行压力测试：连续跑几天，观察 CPU、内存、磁盘 IO等指标波动</li>
<li>进行故障测试：kill，断电、拔网线、重启 100 次以上、倒换等</li>
</ul>
<h4 id="关键源码学习"><a href="#关键源码学习" class="headerlink" title="关键源码学习"></a>关键源码学习</h4><p>钻研、领悟该项目的各种<strong>设计思想</strong>与<strong>代码实现细节</strong>，基本定位是“精通”，精益求精，学无止境。这是大神们追求的境界。如果希望成为团队技术担当、项目社区的重要贡献者，则应当以这个层次作为努力的目标。</p>
<p><strong>代码不仅是读，还要理和试，有的人连API都没有调用过，上来就看代码，以为省了时间，实际是迈向自我摧残。</strong></p>
<p>对源码进行理和试的关键如下：</p>
<ul>
<li>在IDE拿到调用栈在IDE里读。IDE里可以方便跳转，查看定义，比起网页上看效率高得多。 通过IDE工具，运行example程序进行跟踪调试，通过打断点可以得到程序运行的调用栈。<strong>尽可能编译调试。能调试的代码，几乎没有看不懂的。</strong></li>
<li>把调用栈画下来 把代码的调用逻辑梳理出来之后，再通过画图工具，把代码的图画出来，可以画：流程图、类图、调用图、时序图，更具实际情况选择最有表现力的图。</li>
</ul>
<p>此外，平时多了解一些设计模式。这样看到名字里有<code>proxy</code>, <code>builder</code>, <code>factory</code>之类的，就心领神会了。横向分层，纵向分块。代码都是分模块的，有的是<strong>core</strong>，有的是<strong>util</strong>，<strong>parser</strong>之类的，要知道看的是哪一层，那一块。</p>
<p>有的小项目分层不明显，也不必强求。要看的不只是语法上的技巧，更重要的是设计上的思路和原理。<strong>读没读懂，最简单的标准是，假如给充足的时间，有没有信心写出一个差不多的东西来</strong>。</p>
<h4 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h4><p>实际实践操作中，完整执行上面4个步骤花费时间就长，通常情况下，前面2个步骤，在研究开源项目的时候都必不可少，第3个步骤可以在工作中打算采用开源项目才实施，第4个步骤在有一定的时间和精力下灵活安排时间做。</p>
<p><strong>与其每个项目走马观花去简单了解，不如集中火力把一个项目研究吃透，即使半年才吃透一个，积累几年之后数量还是很可观的。而且很多项目的思想是共同的，例如高可用方案、分布式协议等，研究透一个，再研究类似项目，会发现学习速度非常快，因为已经把共性的部分掌握了，只需要再研究新项目差异的部分。</strong></p>
<p>同时，在学习的过程中，需要不断总结，复盘，输出学习笔记，一方面锻炼逻辑思维能力，一方面有利于建立知识索引，过一段时间回顾的时候通过索引可以快速重新掌握知识，不容易遗忘。</p>
<h2 id="读源码的7大心得总结"><a href="#读源码的7大心得总结" class="headerlink" title="读源码的7大心得总结"></a>读源码的7大心得总结</h2><p>用了这么久的 Redis，也翻了很多次源码，经常有人问我到底怎么读 Redis 源码。</p>
<p>一提到读源码，很多人都会比较畏惧，认为读源码是高手才会做的事情。他们可能遇到问题时，会更倾向于去找别人分享的答案。但往往很多时候，自己查到的资料并不能解决所有问题，尤其是比较细节的问题。</p>
<p>从我的实战经验来看，遇到这种情况，通常就需要去源码中寻找答案了，因为在源码面前，这些细节会变得「一览无余」。</p>
<p>而且我认为，掌握读源码的能力，是从<strong>只懂得如何使用 Redis，到精通 Redis 实现原理</strong>的成长之路上，必须跨越的门槛。</p>
<p>可是，面对庞大复杂的项目，我们怎样读源码才能更高效呢？</p>
<p>这篇文章我就来和你聊一聊，我读 Redis 源码的经验，以及读源码的「通用思路」，希望这些心得可以帮助到你。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165157407.png"></p>
<h3 id="找到地图"><a href="#找到地图" class="headerlink" title="找到地图"></a>找到地图</h3><p>很多开源项目的源码，代码量一般都比较庞大，如果在读代码之前，我们没有制定合理的方法，就一头扎进去读代码，势必会把自己搞晕。</p>
<p>所以，我在拿到一个项目的代码之后，并不会马上着手去读，而是会先对整个项目结构进行梳理，划分出项目具体包含的模块。这样，我就对整个项目有了一个「宏观」的了解。</p>
<p>读代码就好比去一个陌生城市旅行，这个旅途过程充满着未知。如果在出发之前，我们手里能有一张地图，那我们对自己的行程就可以有一个非常清晰的规划。</p>
<p>我们就知道，如果想要到达目的地，需要从哪里出发、经过哪些地方、通过什么方式才能到达，<strong>有了地图就有了行进方向</strong>，否则很容易迷失。</p>
<p>因此，提前花一些时间梳理整个项目的「结构和目录」，对于后面更好地阅读代码是非常有必要的。</p>
<p>就拿 Redis 来举例，在读 Redis 源码之前，我们可以先梳理出整个项目的功能模块，以及每个模块对应的代码文件（src 下的代码结构）：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165332262.png" style="zoom:80%;" />

<p>有了这张地图之后，再去看代码的时候，就可以有重点地阅读了。</p>
<h3 id="前置知识准备"><a href="#前置知识准备" class="headerlink" title="前置知识准备"></a>前置知识准备</h3><p>在梳理完整个项目结构之后，我们就可以正式进入阅读环节当中了。不过，在阅读代码之前，我们其实还需要预先掌握一些「前置知识」。</p>
<p>因为一个完整的项目，必然综合了各个领域的技术知识点，比如<strong>数据结构、操作系统、网络协议、编程语言</strong>等，如果我们提前做好一些功课，在读源码的过程中就会轻松很多。</p>
<p>以下是根据我在阅读 Redis 书籍和实战过程中，提取的读源码必备前置知识点，你可以参考下：</p>
<ul>
<li><strong>常用数据结构</strong>：数组、链表、哈希表、跳表</li>
<li><strong>网络协议</strong>：TCP 协议</li>
<li><strong>网络 IO 模型</strong>：IO 多路复用、非阻塞 IO、Reactor 网络模型</li>
<li><strong>操作系统</strong>：写时复制（Copy On Write）、常见系统调用、磁盘 IO 机制</li>
<li><strong>C 语言基础</strong>：循环、分支、结构体、指针</li>
</ul>
<p>当然，在阅读源码的过程中，我们也可以根据实际问题再去查阅相关资料，但不管怎样，提前熟悉这些方面的知识，在真正读代码时就会省下不少时间。</p>
<h3 id="从基础模块开始读"><a href="#从基础模块开始读" class="headerlink" title="从基础模块开始读"></a>从基础模块开始读</h3><p>有了地图并掌握了前置知识之后，接下来我们就要进入主题了：<strong>读代码</strong>。</p>
<p>但具体要从哪个地方开始读起呢？我认为要先从「<strong>最基础</strong>」的模块开始读起。</p>
<p>我在前面也分析了，一个完整的项目会划分很多的功能模块，但这些模块并不是孤立的，而很可能是有「依赖」关系的。</p>
<p>比如说，Redis 中的 networking.c 文件，表示处理网络 IO 的具体实现。而如果我们能在理解事件驱动模块 ae.c 的基础上，再去阅读网络 IO 模块，效率就会更高。</p>
<p>那在 Redis 源码中，哪些是最基础的模块呢？</p>
<p>想一下，我们在使用 Redis 时，接触最频繁的是哪些功能？</p>
<p>答案是<strong>各种数据类型</strong>。</p>
<p>一切操作的基础，其实都是基于这些最常用的数据类型来做的，比如 String、List、Hash、Set、Sorted Set等。所以，我们就可以从这些基础模块开始读起，也就是从 t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c 代码入手。</p>
<p>如果你对 Redis 的数据类型有所了解，就会看到这些数据类型在实现时，底层都对应了不同的数据结构。比如，String 的底层是 SDS，List 的底层是 ziplist + quicklist，Hash 底层可能是ziplist，也可能是哈希表，等等。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165549459.png"></p>
<p>由此一来，我们会发现，这些数据结构又是更为「底层」的模块，所以我们在阅读数据类型模块时，就需要重点聚焦在这些模块上，也就是 sds.c、ziplist.c、quicklist.c、dict.c、intset.c 文件，而且这些文件都是比较独立的，阅读起来就可以更加集中。</p>
<p>这样，当我们真正掌握了这些「底层数据结构」的实现后，就能更好地理解基于它们实现的各种「数据类型」了。</p>
<p><strong>这些基础模块就相当于一座大厦的地基，地基打好了，才能做到高楼耸立。</strong></p>
<h3 id="找到核心主线"><a href="#找到核心主线" class="headerlink" title="找到核心主线"></a>找到核心主线</h3><p>掌握了数据结构模块之后，这时我们的重点就需要放在「<strong>核心主线</strong>」上来了。</p>
<p>在这个阶段，我们需要找到一个明确的目标，以这个目标为主线去读代码。因为读源码一个很常见的需求，就是为了了解这个项目最「核心功能」的实现细节，我们只有以此为目标，找到这条主线去读代码，才能达到最终目的。</p>
<p>那么在读 Redis 源码时，什么才是它的核心主线呢？这里我分享一个非常好用的技巧，就是根据「<strong>Redis 究竟是怎么处理客户端发来的命令的？</strong>」 为主线来梳理。</p>
<p>举个例子，当我们在执行 <code>SET testkey testval EX 60</code> 这样一条命令时，就需要搞清楚 Redis 是怎么执行这条命令的。</p>
<p>也就是要明确，<strong>Redis 从收到客户端请求，到把数据存到 Redis 中、设置过期时间，最后把响应结果返回给客户端</strong>，整个过程的每一个环节，到底是如何处理的。</p>
<p>有了这条主线，我们就有了非常明确的目标，而且沿着这条主线去读代码，我们还可以很清晰地把多个模块「串联」起来。比如从前面的例子中，我们会看到一条命令的执行，主要包含了这样几个阶段。</p>
<ul>
<li><strong>Redis Server 初始化</strong>：加载配置、监听端口、注册连接建立事件、启动事件循环（server.c、anet.c）。</li>
<li><strong>接收、解析客户端请求</strong>：初始化 client、注册读事件、读客户端 socket（networking.c）。</li>
<li><strong>处理具体的命令</strong>：找到对应的命令函数、执行命令（server.c、t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c）。</li>
<li><strong>返回响应给客户端</strong>：写客户端缓冲区、注册写事件、写客户端 socket（networking.c）。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165810148.png" style="zoom:80%;" />

<p>沿着这条主线去读代码，我们就可以掌握一条命令的执行全过程。</p>
<p>而且，由于这条主线的代码逻辑，已经覆盖了「所有命令」的执行流程，我们下次再去读其它命令时，比如 SADD，就只需要关注「处理命令」部分的逻辑即可，其它逻辑有 80% 都是相同的。</p>
<h3 id="先整体后细节"><a href="#先整体后细节" class="headerlink" title="先整体后细节"></a>先整体后细节</h3><p>当然，在阅读主线代码的过程中，肯定也会遇到过于「<strong>复杂</strong>」的函数，第一次在读这种函数时，很容易就会「陷进去」，导致整个主线代码的阅读，无法继续推进下去。</p>
<p>遇到这种情况其实是很正常的，可这时我们应该怎么办呢？</p>
<p>这里我的做法是，前期读到这种逻辑时，不要马上陷入到细节中去，而是要先「抓整体」。</p>
<p>具体来说，对于复杂的函数逻辑，我们刚开始并不需要知道它的每一个细节是如何实现的，而是只需知道这个函数「大致」做了几件事情即可。</p>
<p>举个例子，在执行 HSET 命令时，有一段代码很复杂，其中包括了很多分支判断，一次很难读懂：</p>
<img src="E:\Typora\images\image-20220211165931298.png" style="zoom:80%;" />

<p>那么，我在读这段代码时，就可以先简化逻辑，把握整体思路：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211170007546.png" style="zoom:80%;" />

<p>之后，再了解每个分支大致做了哪些事情：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211170050814.png" style="zoom:80%;" />

<p>这样做的好处，一是不会被复杂的细节逻辑搞晕，打击自己的自信心，二是可以有效避免阅读的连贯性被打断，从而能持续推进我们把整个主线逻辑读完。</p>
<p>所以，这里的重点就是：<strong>先把复杂代码的主逻辑搞清楚，知道涉及的每个方法完成了什么事，心里要先搭建一个简单的「框架」，等有了框架之后，我们再去给框架填充「细节」。</strong></p>
<p>这样通过「先整体后细节」的方式，我们就可以不再畏惧代码中的复杂逻辑。</p>
<h3 id="先主线后支线"><a href="#先主线后支线" class="headerlink" title="先主线后支线"></a>先主线后支线</h3><p>不过，在阅读主线代码的过程中，我们肯定还会遇到各种「支线」逻辑，比如<strong>数据过期、替换淘汰、持久化、主从复制</strong>等。</p>
<p>其实，在阅读主线逻辑的时候，我们并不需要去重点关注这些支线，而当整个主线逻辑「清晰」起来之后，我们再去读这些支线模块，就会容易很多了。</p>
<p>这时，我们就可以从这些支线中，选取下一个「目标」，带着这个目标去阅读，比如说：</p>
<ul>
<li>过期策略是怎么实现的？（expire.c、lazyfree.c）</li>
<li>淘汰策略是如何实现的？（evict.c）</li>
<li>持久化 RDB、AOF 是怎么做的？（rdb.c、aof.c）</li>
<li>主从复制是怎么做的？（replication.c）</li>
<li>哨兵如何完成故障自动切换？（sentinel.c）</li>
<li>分片逻辑如何实现？（cluster.c）</li>
<li>…</li>
</ul>
<p>有了新的支线目标后，我们依旧可以采用前面提到的「先整体后细节」的思路阅读相关模块，这样下来，整个项目的每个模块，就可以被「逐一击破」了。</p>
<h3 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="查漏补缺"></a>查漏补缺</h3><p>最后，我们还需要「查漏补缺」。</p>
<p>按照前面提到的方法，基本就可以把整个项目的主要模块读得七七八八了，这时我们基本已经对整个项目有了整体的「把控」。</p>
<p>不过，当我们在工作中遇到问题时，很有可能会发现，在当时读代码的过程中，有很多并不在意的「细节」被忽略了。</p>
<p>所以这时，我们就可以再带着「具体问题」出发，聚焦这个问题相关的模块，再一次去读源码。这样一来，我们就可以填补当时阅读源码的「空白区」。</p>
<p>举个例子，当我们在阅读 String 底层数据结构 SDS（简单动态字符串）的实现时，我们会看到当 SDS 需要追加新内容时会进行扩容，而我们之前阅读这块代码时，<strong>很有可能只是了解到有这样的逻辑存在，但并没有在意扩容的相关细节（一次扩容多大）。</strong></p>
<p>所以，当我们在工作中遇到这个细节问题后，就可以把目光聚焦在 SDS 的扩容逻辑上（sds.c 的sdsMakeRoomFor函数），而此时我们会发现，当需要申请的新内存小于 1MB 时，Redis 就会翻倍申请内存，否则按 1MB 申请新内存。</p>
<p>采用这个方法进行查漏补缺，我们就可以对整个项目了解得更深入、更全面，真正把项目「吃透」。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、<strong>找到地图</strong>：拿到项目代码后，提前梳理整个项目结构，知晓整个项目的模块划分，以及对应的代码文件。</p>
<p>2、<strong>前置知识准备</strong>：提前掌握项目中用到的前置知识，比如数据结构、操作系统原理、网络协议、网络 IO 模型、编程语言语法等等。</p>
<p>3、<strong>从基础模块开始读</strong>：从最底层的基础模块开始入手，先掌握了这些模块，之后基于它们构建的模块读起来会更加高效。</p>
<p>4、<strong>找到核心主线</strong>：找到整个项目中最核心的主线逻辑，以此为目标，了解各模块为了完成这个功能，是如何协作和组织的。</p>
<p>5、<strong>先整体后细节</strong>：对于复杂函数，不要上来就陷入细节，前期阅读只需了解这个函数大致做了什么事情，建立框架，等搭建起框架之后，再去填充细节。</p>
<p>6、<strong>先主线后支线</strong>：整个主线逻辑清晰之后，再去延伸阅读支线逻辑，因为支线逻辑肯定是服务主线逻辑的，读完主线后再去读这些支线，也会变得更简单。</p>
<p>7、<strong>查漏补缺</strong>：在工作中遇到具体问题，带着这些实际的问题出发再次去读源码，进行查漏补缺，填补之前读源码时没有注意到的地方。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>你可以看到，上面介绍的阅读源码的方法，其实并不局限于读 Redis 代码。</p>
<p>这 7 个步骤，可以算是一个的「通用思路」，我也经常用这个思路来读其它项目的源码，非常有用，你也可以试试。</p>
<p>另外，我认为很多人读源码觉得难，<strong>一是因为心理上自认为自己读不懂，不敢迈步这一步，二是因为找不到合理的方法，在读源码时屡次受挫，最终知难而退。</strong></p>
<p>我在读源码时也经历过这些，这里再分享一下我的经验。</p>
<p>1、<strong>永远不要给自己设限</strong>：想想看，曾经以为很多自己做不到的事，在有压力的情况下，是不是慢慢都做到了，而且发现做得还挺好？学习技术也是一样，技术是死的，东西就那么多，一遍不行来两遍，总有一次能搞懂，所以心态上一定不要先「否定」自己，凡事先迈一小步进去试试看，好的开始就是成功的一半。</p>
<p>2、<strong>找到对的学习方法</strong>：正所谓「学会学习，再学习」，科学高效的方法，能帮你事半功倍，这篇文章分享的方法论，就是属于学习方法的范畴，你可以结合自己的实际情况试试看。</p>
<h2 id="开源软件的许可协议"><a href="#开源软件的许可协议" class="headerlink" title="开源软件的许可协议"></a>开源软件的许可协议</h2><p>世界上现在有 60 多种被开源促进组织（<strong>Open Source Initiative</strong>）认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。<br>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。<br>对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。</p>
<h3 id="常见开源协议"><a href="#常见开源协议" class="headerlink" title="常见开源协议"></a>常见开源协议</h3><p><strong>GNU GPL（GNU General Public License，GNU通用公共许可证）</strong></p>
<p>只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是<strong>必须开源免费，不能闭源收费</strong>，因此这个协议并不适合商用软件。</p>
<p>遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。</p>
<p><strong>GPL 开源协议的主要特点：</strong></p>
<ul>
<li><strong>复制自由：</strong>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</li>
<li><strong>传播自由：</strong>允许软件以各种形式进行传播。</li>
<li><strong>收费传播：</strong>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</li>
<li><strong>修改自由：</strong>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。</li>
</ul>
<p><strong>BSD（Berkeley Software Distribution，伯克利软件发布版）协议</strong></p>
<p>BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：</p>
<p>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。<br>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。<br>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</p>
<p><strong>Apache 许可证版本（Apache License Version）协议</strong></p>
<p>Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为<strong>开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由</strong>。</p>
<p>现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件：</p>
<ul>
<li>该软件及其衍生品必须继续使用 Apache 许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li>
</ul>
<p><strong>MIT（Massachusetts Institute of Technology）协议</strong></p>
<p>目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p>
<p>使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p>
<p><strong>GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）</strong></p>
<p>LGPL 是 GPL 的一个衍生版本，也被称为 <strong>GPL V2</strong>，该协议<strong>主要是为类库设计的开源协议</strong>。</p>
<p>LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<h3 id="如何选择开源协议"><a href="#如何选择开源协议" class="headerlink" title="如何选择开源协议"></a>如何选择开源协议</h3><p>世界上的开源协议有上百种，很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。</p>
<p>乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211094515896.png" style="zoom:80%;" />



<p><strong>开源等于免费吗？</strong></p>
<p>首先，开源软件和免费软件是两个概念：</p>
<ul>
<li><strong>开源软件是指公开源代码的软件。</strong>开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</li>
<li><strong>免费软件就是免费提供给用户使用的软件。</strong>但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</li>
</ul>
<p>免费软件的例子比比皆是，QQ、微信、迅雷、酷狗、360 等都是免费软件，你可以随意使用，尽情蹂躏；但是，如果你嫌弃它们复杂，自己删除了一些无用的功能，然后在网上发布了一个精简版本供大家下载，那么你就离法院的传票不远了。</p>
<p>开源软件是不抵触商业的，开源的目的也不是做慈善事业，而是通过更多人的参与，减少软件的缺陷，丰富软件的功能，同时也避免了少数人在软件里留一些不正当的后门。开源软件最终还会反哺商业，让商业公司为用户提供更好的产品。</p>
<p>Android 就是大众最熟知的一款开源操作系统，它除了用在手机上，还用在汽车、平板电脑、电视、智能手表等其它硬件平台，小米、华为、OPPO、三星等都是 Android 的受益者，他们都赚得盆满钵满。</p>
<p>很多著名的开源项目背后都有商业公司支撑，它们的开发者也都有正式的工作，享受和我们一样的社会福利；如果一个成功的开源项目背后没有商业公司，这反而是不健康的，社会需要开源和商业之间的互补来促进技术的革新。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://gitee.com/opensource-guide/">开源指北</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg">看完这篇，别人的开源项目结构应该能看懂了</a></strong></p>
</li>
<li><p><strong>阿里巴巴 Java开发手册（嵩山版）</strong></p>
</li>
<li><p><strong><a href="https://juejin.cn/post/6844903657348022280">谈谈如何高效学习开源项目</a></strong></p>
</li>
<li><p><strong><a href="https://mp.weixin.qq.com/s/eWN7I8eHGE2exrdF3xziIA">读懂Redis源码，我总结了这7大心得</a></strong></p>
</li>
<li><p><strong><a href="https://mp.weixin.qq.com/s/ojGRSWSaJutAsBC0i5_6jA">开源软件的许可协议</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>开源项目</tag>
        <tag>学习经验</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟</title>
    <url>/post/d1f7904c/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模拟就是用计算机来模拟题目中要求的操作。</p>
<p>模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。</p>
<p>模拟算法是一种最基本的算法思想，是对程序员基本编程能力的一种考查，其解决方法就是<strong>根据题目给出的规则对题目要求的相关过程进行编程模拟。</strong>在解决模拟类问题时，需要注意字符串处理、<strong>特殊情况处理</strong>和<strong>对题目意思的理解</strong>。在程序设计过程中，可使用随机函数来模拟自然界中发生的不可预测情况。在解题时，需要<strong>仔细分析题目给出的规则</strong>，要<strong>尽可能地做到全面地考虑所有可能出现的情况</strong>，这是解模拟类问题的关键点之一。</p>
<span id="more"></span>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>写模拟题时，遵循以下的建议有可能会提升做题速度：</p>
<ul>
<li>在动手写代码之前，在草纸上尽可能地写好要实现的流程。</li>
<li>在代码中，<strong>尽量把每个部分模块化，</strong>写成函数、结构体或类。</li>
<li><strong>对于一些可能重复用到的概念，可以统一转化，方便处理</strong>：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。</li>
<li>调试时<strong>分块调试</strong>。模块化的好处就是可以方便的单独调某一部分。</li>
<li>写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。</li>
</ul>
<p>实际上，上述步骤在解决其它类型的题目时也是很有帮助的。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></td>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">官方题解</a><br><a href="https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/">优化版竖式(打败99.4%)</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">C++ 详细题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">Spiral Matrix II （模拟法，设定边界，代码简短清晰）</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈数据库并发控制 - 锁和 MVCC</title>
    <url>/post/7881a926/</url>
    <content><![CDATA[<p>在学习几年编程之后，你会发现所有的问题都没有简单、快捷的解决方案，很多问题都需要权衡和妥协，而本文介绍的就是数据库在并发性能和可串行化之间做的权衡和妥协 - 并发控制机制。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315194543550.png" style="zoom:80%;" />

<p>如果数据库中的所有事务都是串行执行的，那么它非常容易成为整个应用的性能瓶颈，虽然说<strong>没法水平扩展的节点在最后都会成为瓶颈</strong>，但是串行执行事务的数据库会加速这一过程；而并发（Concurrency）使一切事情的发生都有了可能，它能够解决一定的性能问题，但是它会带来更多诡异的错误。</p>
<p>引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，你可能没有享受到并发带来的性能提升就已经被各种奇怪的问题折磨的欲仙欲死了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介绍的内容，文章中会介绍最为常见的三种并发控制机制：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315194703883.png" style="zoom:80%;" />

<p>分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，<strong>乐观锁其实并不是一种真实存在的锁</strong>，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，<strong>MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能</strong>。</p>
<p>既然这篇文章介绍了不同的并发控制机制，那么一定会涉及到不同事务的并发，我们会通过示意图的方式分析各种机制是如何工作的。</p>
<h2 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h2><p>控制不同的事务对同一份数据的获取是保证数据库的一致性的最根本方法，如果我们能够让事务在同一时间对同一资源有着独占的能力，那么就可以保证操作同一资源的不同事务不会相互影响。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315194850633.png" style="zoom:80%;" />

<p>最简单的、应用最广的方法就是使用锁来解决，当事务需要对资源进行操作时需要先获得资源对应的锁，保证其他事务不会访问该资源后，在对资源进行各种操作；在悲观并发控制中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是<strong>共享锁</strong>和<strong>互斥锁</strong>。<strong>当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫读锁</strong>；而<strong>当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫写锁</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315195037359.png" style="zoom:80%;" />

<p>共享锁和互斥锁除了限制事务能够执行的读写操作之外，它们之间还有『共享』和『互斥』的关系，也就是多个事务可以同时获得某一行数据的共享锁，但是互斥锁与共享锁和其他的互斥锁并不兼容，我们可以很自然地理解这么设计的原因：多个事务同时写入同一数据难免会发生各种诡异的问题。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315195253382.png" style="zoom:80%;" />

<p>如果当前事务没有办法获取该行数据对应的锁时就会陷入等待的状态，直到其他事务将当前数据对应的锁释放才可以获得锁并执行相应的操作。</p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>两阶段锁协议（<strong>2PL</strong>）是一种能够<strong>保证事务可串行化</strong>的协议，它将事务的获取锁和释放锁划分成了<strong>增长（Growing）</strong>和<strong>缩减（Shrinking）</strong>两个不同的阶段。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315195513469.png" style="zoom:80%;" />

<p>在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁，如果只看 2PL 的定义，那么到这里就已经介绍完了，但是它还有两个变种：</p>
<ol>
<li><p><strong>Strict 2PL</strong>：事务持有的<strong>互斥</strong>锁必须在提交后再释放；</p>
</li>
<li><p><strong>Rigorous 2PL</strong>：事务持有的<strong>所有</strong>锁必须在提交后释放；</p>
<blockquote>
<p>Rigorous</p>
<p>adj. （测试、系统或程序）严密的，缜密的；（规则，制度等）严格的，苛刻的；一丝不苟的；严酷的，恶劣的</p>
</blockquote>
</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315195630470.png" style="zoom:80%;" />

<p>虽然锁的使用能够为我们解决不同事务之间由于并发执行造成的问题，但是两阶段锁的使用却引入了另一个严重的问题，死锁；不同的事务等待对方已经锁定的资源就会造成死锁，我们在这里举一个简单的例子：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315200112469.png" style="zoom:80%;" />

<p>两个事务在刚开始时分别获取了 draven 和 beacon 资源上面的锁，然后再请求对方已经获得的锁时就会发生死锁，双方都没有办法等到锁的释放，如果没有死锁的处理机制就会无限等待下去，两个事务都没有办法完成。</p>
<h3 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h3><p>死锁在多线程编程中是经常遇到的事情，一旦涉及多个线程对资源进行争夺就需要考虑当前的几个线程或者事务是否会造成死锁；<strong>解决死锁</strong>大体来看有<strong>两种办法</strong>，一种是<strong>从源头杜绝死锁的产生和出现</strong>，另一种是<strong>允许系统进入死锁的状态，但是在系统出现死锁时能够及时发现并且进行恢复</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315200220746.png" style="zoom:80%;" />

<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>有两种方式可以帮助我们预防死锁的出现，一种是保证事务之间的等待不会出现环，也就是事务之间的<strong>等待图应该是一张有向无环图</strong>，<strong>没有循环等待的情况或者保证一个事务中想要获得的所有资源都在事务开始时以原子的方式被锁定，所有的资源要么被锁定要么都不被锁定</strong>。</p>
<p>但是这种方式有两个问题，<strong>在事务一开始时很难判断哪些资源是需要锁定的，同时因为一些很晚才会用到的数据被提前锁定，数据的利用率与事务的并发率也非常的低</strong>。一种解决的办法就是<strong>按照一定的顺序为所有的数据行加锁，同时与 2PL 协议结合</strong>，在加锁阶段保证所有的数据行都是从小到大依次进行加锁的，不过这种方式依然需要事务提前知道将要加锁的数据集。</p>
<p>另一种预防死锁的方法就是使用<strong>抢占加事务回滚</strong>的方式预防死锁，当事务开始执行时会先获得一个<strong>时间戳</strong>，数据库程序会根据事务的时间戳决定事务应该等待还是回滚，在这时也有两种机制供我们选择，一种是 <strong>wait-die 机制</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315200421244.png" style="zoom:80%;" />

<p>当执行事务的时间戳小于另一事务时，即事务 A 先于 B 开始，那么它就会等待另一个事务释放对应资源的锁，否则就会保持当前的时间戳并回滚。</p>
<p>另一种机制叫做 <strong>wound-wait</strong>，这是一种抢占的解决方案，它和 wait-die 机制的结果完全相反，当前事务如果先于另一事务执行并请求了另一事务的资源，那么另一事务会立刻回滚，将资源让给先执行的事务，否则就会等待其他事务释放资源：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315200731551.png" style="zoom:80%;" />

<p>两种方法都会造成不必要的事务回滚，由此会带来一定的性能损失，更简单的解决死锁的方式就是使用<strong>超时时间</strong>，但是超时时间的设定是需要仔细考虑的，否则会造成耗时较长的事务无法正常执行，或者无法及时发现需要解决的死锁，所以它的使用还是有一定的局限性。</p>
<h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><p>如果数据库程序无法通过协议从原理上保证死锁不会发生，那么就需要在死锁发生时及时检测到并从死锁状态恢复到正常状态保证数据库程序可以正常工作。<strong>在使用检测和恢复的方式解决死锁时，数据库程序需要维护数据和事务之间的引用信息，同时也需要提供一个用于判断当前数据库是否进入死锁状态的算法，最后需要在死锁发生时提供合适的策略及时恢复</strong>。</p>
<p>在上一节中我们其实提到死锁的检测可以通过一个有向的等待图来进行判断，如果一个事务依赖于另一个事务正在处理的数据，那么当前事务就会等待另一个事务的结束，这也就是整个等待图中的一条边：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315210436899.png" style="zoom:80%;" />

<p>如上图所示，如果在这个有向图中出现了环，就说明当前数据库进入了死锁的状态 <code>TransB -&gt; TransE -&gt; TransF -&gt; TransD -&gt; TransB</code>，在这时就需要死锁恢复机制接入了。</p>
<p>如何从死锁中恢复其实非常简单，最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环，在整个恢复的过程中有三个事情需要考虑：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315210813326.png" style="zoom:80%;" />

<p>每次出现死锁时其实都会有多个事务被波及，而选择其中哪一个任务进行回滚是必须要做的事情，在选择<strong>牺牲品（Victim）</strong>时的黄金原则就是<strong>最小化代价</strong>，所以我们需要<strong>综合考虑事务已经计算的时间、使用的数据行以及涉及的事务等因素</strong>；当我们选择了牺牲品之后就可以开始回滚了，回滚其实有两种选择一种是<strong>全部回滚</strong>，另一种是<strong>部分回滚</strong>，部分回滚会回滚到事务之前的一个<strong>检查点</strong>上，如果没有检查点那自然没有办法进行部分回滚。</p>
<p>在死锁恢复的过程中，其实还可能出现<strong>某些任务在多次死锁时都被选择成为牺牲品，一直都不会成功执行，造成饥饿（Starvation）</strong>，我们<strong>需要保证事务会在有穷的时间内执行，所以要在选择牺牲品时将时间戳加入考虑的范围</strong>。</p>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>到目前为止我们都没有对不同粒度的锁进行讨论，一直以来我们都讨论的都是数据行锁，但是在有些时候我们希望将多个节点看做一个数据单元，使用锁直接将这个数据单元、表甚至数据库锁定起来。这个目标的实现需要我们在数据库中定义不同粒度的锁：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315211004521.png" style="zoom:80%;" />

<p>当我们拥有了不同粒度的锁之后，如果某个事务想要锁定整个数据库或者整张表时只需要简单的锁住对应的节点就会在当前节点加上<strong>显示（explicit）锁</strong>，在所有的子节点上加<strong>隐式（implicit）锁</strong>；虽然这种不同粒度的锁能够解决父节点被加锁时，子节点不能被加锁的问题，但是我们没有办法在子节点被加锁时，立刻确定父节点不能被加锁。</p>
<p>在这时我们就需要引入<strong>意向锁</strong>来解决这个问题了，当需要给子节点加锁时，先给所有的父节点加对应的意向锁，<strong>意向锁之间是完全不会互斥的，只是用来帮助父节点快速判断是否可以对该节点进行加锁</strong>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315211259803.png" style="zoom:80%;" />

<p>这里是一张引入了两种意向锁，<strong>意向共享锁</strong>和<strong>意向互斥锁</strong>之后所有的锁之间的兼容关系；到这里，我们通过不同粒度的锁和意向锁加快了数据库的吞吐量。</p>
<h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><p>除了悲观并发控制机制 - 锁之外，我们其实还有其他的并发控制机制，<strong>乐观并发控制（Optimistic Concurrency Control）</strong>。乐观并发控制也叫乐观锁，但是它并不是真正的锁，很多人都会误以为乐观锁是一种真正的锁，然而它只<strong>是一种并发控制的思想</strong>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315211435924.png" style="zoom:80%;" />

<p>在这一节中，我们将会先介绍<strong>基于时间戳的并发控制机制</strong>，然后在这个协议的基础上进行扩展，实现乐观的并发控制机制。</p>
<h3 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h3><p>锁协议按照不同事务对同一数据项请求的时间依次执行，因为后面执行的事务想要获取的数据已将被前面的事务加锁，只能等待锁的释放，所以基于锁的协议执行事务的顺序与获得锁的顺序有关。在这里想要介绍的<strong>基于时间戳的协议能够在事务执行之前先决定事务的执行顺序</strong>。</p>
<p><strong>每一个事务都会具有一个全局唯一的时间戳</strong>，它即可以使用系统的时钟时间，也可以使用计数器，只要能够保证所有的时间戳都是唯一并且是随时间递增的就可以。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315211703708.png" style="zoom:80%;" />

<p><strong>基于时间戳的协议能够保证事务并行执行的顺序与事务按照时间戳串行执行的效果完全相同</strong>；每一个数据项都有两个时间戳，读时间戳和写时间戳，分别代表了当前成功执行对应操作的事务的时间戳。</p>
<p>该协议能够保证所有冲突的读写操作都能按照时间戳的大小串行执行，在执行对应的操作时不需要关注其他的事务只需要关心数据项对应时间戳的值就可以了：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315212242720.png" style="zoom:80%;" />

<p>无论是读操作还是写操作都会从左到右依次比较读写时间戳的值，如果小于当前值就会直接被拒绝然后回滚，数据库系统会给回滚的事务添加一个新的时间戳并重新执行这个事务。</p>
<h3 id="基于验证的协议"><a href="#基于验证的协议" class="headerlink" title="基于验证的协议"></a>基于验证的协议</h3><p><strong>乐观并发控制</strong>其实本质上就是<strong>基于验证的协议</strong>，因为在多数的应用中只读的事务占了绝大多数，事务之间因为写操作造成冲突的可能非常小，也就是说大多数的事务在不需要并发控制机制也能运行的非常好，也可以保证数据库的一致性；而并发控制机制其实向整个数据库系统添加了很多的开销，我们其实可以通过别的策略降低这部分开销。</p>
<p>而验证协议就是我们找到的解决办法，它根据事务的只读或者更新将所有事务的执行分为两到三个阶段：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315212451550.png" style="zoom:80%;" />

<p>在读阶段，数据库会执行事务中的<strong>全部读操作和写操作</strong>，并将所有写后的值存入临时变量中，并不会真正更新数据库中的内容；在这时候会进入下一个阶段，数据库程序会检查当前的改动是否合法，也就是是否有其他事务在 RAED PHASE 期间更新了数据，如果通过测试那么直接就进入 WRITE PHASE 将所有存在临时变量中的改动全部写入数据库，没有通过测试的事务会直接被终止。</p>
<p>为了保证乐观并发控制能够正常运行，我们需要知道一个事务不同阶段的发生时间，包括事务开始时间、验证阶段的开始时间以及写阶段的结束时间；通过这三个时间戳，我们可以保证任意冲突的事务不会同时写入数据库，一旦由一个事务完成了验证阶段就会立即写入，其他读取了相同数据的事务就会回滚重新执行。</p>
<p>作为乐观的并发控制机制，它会假定所有的事务在最终都会通过验证阶段并且执行成功，而锁机制和基于时间戳排序的协议是悲观的，因为它们会在发生冲突时强制事务进行等待或者回滚，哪怕有不需要锁也能够保证事务之间不会冲突的可能。</p>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>到目前为止我们介绍的并发控制机制其实都是通过延迟或者终止相应的事务来解决事务之间的竞争条件（Race condition）来保证事务的可串行化；虽然前面的两种并发控制机制确实能够从根本上解决并发事务的可串行化的问题，但是在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315213024115.png" style="zoom:80%;" />

<p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <strong>多版本并发控制（Multiversion Concurrency Control）</strong>，<strong>每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回</strong>；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p>
<p>MVCC 并不是一个与乐观和悲观并发控制对立的东西，它能够与两者很好的结合以增加事务的并发量，在目前最流行的 SQL 数据库 MySQL 和 PostgreSQL 中都对 MVCC 进行了实现；但是由于它们分别实现了悲观锁和乐观锁，所以 MVCC 实现的方式也不同。</p>
<h3 id="MySQL-与-MVCC"><a href="#MySQL-与-MVCC" class="headerlink" title="MySQL 与 MVCC"></a>MySQL 与 MVCC</h3><p>MySQL 中实现的<strong>多版本两阶段锁协议（Multiversion 2PL）</strong>将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315214000083.png" style="zoom:80%;" />

<p>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 <code>＋1</code>：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315214050132.png" style="zoom:80%;" />

<p>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p>
<h3 id="PostgreSQL-与-MVCC"><a href="#PostgreSQL-与-MVCC" class="headerlink" title="PostgreSQL 与 MVCC"></a>PostgreSQL 与 MVCC</h3><p>与 MySQL 中使用悲观并发控制不同，PostgreSQL 中都是使用乐观并发控制的，这也就导致了 MVCC 在于乐观锁结合时的实现上有一些不同，最终实现的叫做<strong>多版本时间戳排序协议（Multiversion Timestamp Ordering）</strong>，在这个协议中，所有的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220315214154565.png" style="zoom: 80%;" />

<p>当 PostgreSQL 的事务发出了一个读请求，数据库直接将最新版本的数据返回，不会被任何操作阻塞，而写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。</p>
<p>这种 MVCC 的实现保证了读事务永远都不会失败并且不需要等待锁的释放，对于读请求远远多于写请求的应用程序，乐观锁加 MVCC 对数据库的性能有着非常大的提升；虽然这种协议能够针对一些实际情况做出一些明显的性能提升，但是也会导致两个问题，一个是每一次读操作都会更新读时间戳造成两次的磁盘写入，第二是事务之间的冲突是通过回滚解决的，所以如果冲突的可能性非常高或者回滚代价巨大，数据库的读写性能还不如使用传统的锁等待方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库的并发控制机制到今天已经有了非常成熟、完善的解决方案，我们并不需要自己去设计一套新的协议来处理不同事务之间的冲突问题，从数据库的并发控制机制中学习到的相关知识，无论是锁还是乐观并发控制在其他的领域或者应用中都被广泛使用，所以了解、熟悉不同的并发控制机制的原理是很有必要的。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://draveness.me/database-concurrency-control.html">浅谈数据库并发控制 - 锁和 MVCC · 面向信仰编程</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSPK3V_7.0.0/com.ibm.swg.im.soliddb.sql.doc/doc/pessimistic.vs.optimistic.concurrency.control.html">PESSIMISTIC vs. OPTIMISTIC concurrency control</a></li>
<li><a href="https://devcenter.heroku.com/articles/postgresql-concurrency">PostgreSQL Concurrency with MVCC</a></li>
<li><a href="https://www.enterprisedb.com/well-known-databases-use-different-approaches-mvcc">Well-known Databases Use Different Approaches for MVCC</a></li>
<li><a href="https://www.cs.unc.edu/~dewan/242/s01/notes/trans/node3.html">Serializability</a></li>
<li><a href="https://en.wikipedia.org/wiki/Race_condition">Race condition</a></li>
</ul>
<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://draveness.me/database-concurrency-control/">浅谈数据库并发控制 - 锁和 MVCC</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>并发控制</tag>
        <tag>锁</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>理解linux中的file descriptor(文件描述符)</title>
    <url>/post/1e8930fb/</url>
    <content><![CDATA[<p>file descriptor（以下简称fd）又叫文件描述符，它是一个抽象的指示符，用一个整数表示（非负整数）。它指向了由系统内核维护的一个file table中的某个条目（entry）。这个解释可能过于抽象，不过在正式详细介绍fd之前，有必要先了解用户程序和系统内核之间的工作过程。</p>
<p>注：本文描述的所有场景仅限于类unix系统环境，在windows中叫file handle（句柄）。</p>
<span id="more"></span>
<h2 id="User-space-amp-Kernel-space"><a href="#User-space-amp-Kernel-space" class="headerlink" title="User space &amp; Kernel space"></a>User space &amp; Kernel space</h2><p>现代操作系统会把内存划分为2个区域，分别为Use space(用户空间) 和 Kernel space(内核空间)。用户的程序在User space执行，系统内核在Kernel space中执行。</p>
<p>用户的程序没有权限直接访问硬件资源，但系统内核可以。比如读写本地文件需要访问磁盘，创建socket需要网卡等。因此用户程序想要读写文件，必须要向内核发起读写请求，这个过程叫system call。</p>
<p>内核收到用户程序system call时，负责访问硬件，并把结果返回给程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">fis.read(buf);</span><br></pre></td></tr></table></figure>

<p>上面代码的流程如下图所示：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126181103666.png" style="zoom:50%;" />



<h2 id="File-Descriptor"><a href="#File-Descriptor" class="headerlink" title="File Descriptor"></a>File Descriptor</h2><p>上面简单介绍了User space和Kernel space，这对于理解fd有很大的帮助。fd会存在，就是因为用户程序无法直接访问硬件，因此当程序向内核发起system call打开一个文件时，在用户进程中必须有一个东西标识着打开的文件，这个东西就是fd。</p>
<h3 id="file-tables"><a href="#file-tables" class="headerlink" title="file tables"></a>file tables</h3><p>和fd相关的一共有3张表，分别是file descriptor、file table、inode table，如下图所示。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126181152940.png"></p>
<ul>
<li><p>file descriptors</p>
<p>file descriptors table由用户进程所有，每个进程都有一个这样的表，这里记录了进程打开的文件所代表的fd，fd的值映射到file table中的条目(entry)。</p>
<p>另外，每个进程都会预留3个默认的fd: stdin、stdout、stderr;它们的值分别是0、1，2。</p>
<table>
<thead>
<tr>
<th align="center">Integer value</th>
<th align="center">Name</th>
<th align="center">symbolic constant</th>
<th align="center">file stream</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
</li>
<li><p>file table</p>
<p>file table是全局唯一的表，由系统内核维护。这个表记录了所有进程打开的文件的状态（是否可读、可写等状态），同时它也映射到inode table中的entry。</p>
</li>
<li><p>inode table</p>
<p>inode table同样是全局唯一的，它指向了真正的文件地址（磁盘中的位置），每个entry全局唯一。</p>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当程序向内核发起system call <code>open()</code>，内核将会</p>
<ol>
<li>允许程序请求</li>
<li>创建一个entry插入到file table，并返回file descriptor</li>
<li>程序把fd插入到fds中。</li>
</ol>
<p>当程序再次发起<code>read()</code>system call时，需要把相关的fd传给内核，内核定位到具体的文件(fd –&gt; file table –&gt; inode table)向磁盘发起读取请求，再把读取到的数据返回给程序处理。</p>
<p>下面是<code>read</code>这个函数的定义，第一个参数<code>fd</code>即file descriptor。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同样的，<code>write</code>system call函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从上面的结果来看，fd就是file table的一个索引，指向了file table中的entry。</p>
<h2 id="查看进程的file-descriptors"><a href="#查看进程的file-descriptors" class="headerlink" title="查看进程的file descriptors"></a>查看进程的file descriptors</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>linux系统可以通过<code>/proc/pid/fd</code>文件夹查看进程的fd，比如我的redis进程id为96104，执行以下命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /proc/96104/fd</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126182056967.png" style="zoom:67%;" />

<p>上图中的数字即fd。</p>
<h3 id="mac-os-x"><a href="#mac-os-x" class="headerlink" title="mac os x"></a>mac os x</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p pid</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126194304823.png" style="zoom: 67%;" />

<h2 id="操作file-descriptors"><a href="#操作file-descriptors" class="headerlink" title="操作file descriptors"></a>操作file descriptors</h2><p>下面是一些系统函数。当程序发起system call，大多需要传递fd到这些函数中，kernel去访问具体的资源。</p>
<ul>
<li>open()</li>
<li>read()</li>
<li>write()</li>
<li>select()</li>
<li>poll()</li>
</ul>
<p>更多系统函数可以参考维基百科<a href="https://en.wikipedia.org/wiki/File_descriptor">File Descriptor</a>，整理了大量常见的函数</p>
<h2 id="Java中的File-Descriptor"><a href="#Java中的File-Descriptor" class="headerlink" title="Java中的File Descriptor"></a>Java中的File Descriptor</h2><p>Java封装了<code>FileDescriptor</code>类表示fd，FileInputStrem和FileOutputStream中都会持有这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fd;  </span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以看到fd和之前描述的一致，是一个整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* File Descriptor - handle to the open file */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">      security.checkRead(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;Invalid file path&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fd在输入输出流的构造器中创建，JVM会发起system call <code>open()</code>初始化资源并返回fd。</p>
<p><strong>stand stream fd</strong></p>
<p>下面代码可以查看标准输入/输出/错误流中的fd，用debug启动即可在面板中看到fd的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FDTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedInputStream in = (BufferedInputStream) System.in;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        PrintStream err = System.err;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192812494.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192838936.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192905490.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192934419.png" style="zoom:50%;" />





<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://wiyi.org/linux-file-descriptor.html">理解linux中的file descriptor(文件描述符)</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/post/50cab45/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>滑动窗口算法是较为入门题目的算法，一般是一些有规律数组问题的最优解，也就是说，如果一个数组问题可以用动态规划解，但又可以使用滑动窗口解决，那么往往滑动窗口的效率更高。</p>
<p>双指针也并不局限在数组问题，像链表场景的 “快慢指针” 也属于双指针的场景，其快慢指针滑动过程中本身就会产生一个窗口，比如当窗口收缩到某种程度，可以得到一些结论。</p>
<p><strong>滑动窗口使用双指针解决问题</strong>，所以一般也叫<strong>双指针算法</strong>，因为<strong>两个指针间形成一个窗口</strong>。</p>
<p>什么情况适合用双指针呢？一般双指针是暴力算法的优化版，所以：</p>
<ol>
<li>如果题目较为简单，且是<strong>数组或链表问题</strong>，往往可以尝试双指针是否可解。</li>
<li>如果<strong>数组存在规律</strong>，可以尝试双指针。</li>
<li>如果<strong>链表问题限制较多</strong>，比如要求 <strong>O(1) 空间复杂度解决</strong>，也许只有双指针可解。</li>
</ol>
<p>也就是说，当一个问题比较有规律，或者较为简单，或较为巧妙时，可以尝试双指针（滑动窗口）解法。</p>
<span id="more"></span>


<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度是 O(N)，比字符串暴力算法要高效得多。</p>
</blockquote>
<p>其实难点不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。</p>
<h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中两处 <code>...</code> 表示的更新窗口数据的地方</strong>。</p>
<p>而且，这两个 <code>...</code> 处的操作分别是右移和左移窗口更新操作，它们操作是完全对称的。</p>
<blockquote>
<p>C++：</p>
<p><code>unordered_map</code> 就是哈希表（字典），它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 key 是否存在。</p>
<p>可以使用方括号访问键对应的值 <code>map[key]</code>。需要注意的是，如果该 <code>key</code> 不存在，C++ 会自动创建这个 key，并把 <code>map[key]</code> 赋值为 0。</p>
<p>所以代码中多次出现的 <code>map[key]++</code> 相当于 Java 的 <code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
<td><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/">面试题48. 最长不含重复字符的子字符串（动态规划 / 双指针 + 哈希表，清晰图解）</a><br/><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/">官方题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></td>
<td><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/xiang-jie-mei-ju-shuang-zhi-zhen-jie-fa-50ri1/">【宫水三叶の相信科学系列】为什么不能用「滑动窗口」？以及如何发掘题目性质</a><br/><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">借本题帮助大家理解递归</a></td>
</tr>
</tbody></table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://segmentfault.com/a/1190000040174595">精读《算法 - 滑动窗口》</a></strong></p>
</li>
<li><p><strong><a href="https://labuladong.gitee.io/algo/2/21/60/">我写了首诗，把滑动窗口算法算法变成了默写题</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/post/34811d5f/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>贪心法</strong>，又称<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><strong>贪心算法</strong></a>、<strong>贪婪算法</strong>、或称<strong>贪婪法</strong>，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p>
<span id="more"></span>


<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>贪心算法的基本思路是<strong>从问题的某一个初始解出发一步一步地进行</strong>，根据某个优化测度，<strong>每一步都要确保能获得局部最优解</strong>。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，<strong>直到把所有数据枚举完，或者不能再添加算法停止</strong>。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><strong>建立数学模型</strong>来描述问题；</li>
<li>把求解的问题<strong>分成若干个子问题</strong>；</li>
<li>对每一子问题求解，<strong>得到子问题的局部最优解</strong>；</li>
<li>把子问题的解<strong>局部最优解合成</strong>原来解问题的一个解。</li>
</ol>
<p>贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常<strong>以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况</strong>，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用<strong>自顶向下</strong>，以<strong>迭代</strong>的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然<strong>每一步上都要保证能获得局部最优解</strong>，<strong>但由此产生的全局解有时不一定是最优的</strong>，所以贪心算法不要回溯。</p>
<h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p>贪婪算法可解决的问题通常大部分都有如下的特性：</p>
<ol>
<li>有一个以最优方式来解决的问题。为了构造问题的解决方案，有一个候选的对象的集合：比如不同面值的硬币。</li>
<li>随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并<strong>被选出</strong>的候选对象，另一个包含已经被考虑过但<strong>被丢弃</strong>的候选对象。</li>
<li>有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。</li>
<li>还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。</li>
<li><strong>选择函数</strong>可以指出哪一个剩余的候选对象最有希望构成问题的解。</li>
<li>最后，<strong>目标函数</strong>给出解的值。</li>
</ol>
<p>为了解决问题，需要<strong>寻找</strong>一个<strong>构成解的候选对象集合</strong>，它可以<strong>优化目标函数</strong>，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的<strong>每一步</strong>中，<strong>根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象</strong>。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都<strong>扩充集合</strong>，并检查该集合是否构成解。<strong>如果贪婪算法正确工作，那么找到的第一个解通常是最优的</strong>。</p>
<h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><p>贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。</p>
<ol>
<li><strong>反证法</strong>：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。</li>
<li><strong>归纳法</strong>：先算得出边界情况（例如 n = 1）的最优解 ，然后再证明：对于每个 n，  F<sub>n+1</sub> 都可以由 F<sub>n</sub> 推导出结果。</li>
</ol>
<h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><p>利用贪心法求解的问题应具备如下2个特征：</p>
<ol>
<li><p><strong>贪心选择性质</strong></p>
<p>一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且<strong>每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质</strong>。对于一个具体问题，要确定它是否具有贪心选择性质，<strong>必须证明每一步所作的贪心选择最终导致问题的整体最优解</strong></p>
</li>
<li><p><strong>最优子结构性质</strong></p>
<p>当<strong>一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质</strong>。问题的最优子结构性质是该问题可用贪心法求解的关键所在。在实际应用中，至于什么问题具有什么样的贪心选择性质是不确定的，需要具体问题具体分析。</p>
</li>
</ol>
<h2 id="解题策略"><a href="#解题策略" class="headerlink" title="解题策略"></a>解题策略</h2><p>贪心算法不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优选择。<strong>使用贪心策略要注意局部最优与全局最优的关系，选择当前的局部最优并不一定能推导出问题的全局最优</strong>。贪心策略解题需要解决以下两个问题：</p>
<ol>
<li>该问题是否适合使用贪心策略求解，也就是该问题是否具有贪心选择性质；</li>
<li>制定贪心策略，以达到问题的最优解或较优解。</li>
</ol>
<p>要确定一个问题是否适合用贪心算法求解，必须证明每一步所作的贪心选择最终导致问题的整体最优解。证明的大致过程为：首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。然后用<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95">数学归纳法</a>证明通过每一步做贪心选择，最终可得到问题的整体最优解。</p>
<h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><p>在提高组难度以下的题目中，最常见的贪心有两种。</p>
<ul>
<li>「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。</li>
<li>「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）</li>
</ul>
<p>二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。</p>
<h3 id="排序解法"><a href="#排序解法" class="headerlink" title="排序解法"></a>排序解法</h3><p>用排序法常见的情况是输入一个包含几个（一般一到两个）<strong>权值</strong>的数组，通过排序然后<strong>遍历模拟计算</strong>的方法求出最优值。</p>
<h3 id="后悔解法"><a href="#后悔解法" class="headerlink" title="后悔解法"></a>后悔解法</h3><p>思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。</p>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>贪心算法也存在如下问题：</p>
<ol>
<li>不能保证解是最佳的。因为贪心算法总是从局部出发，并<strong>没从整体考虑</strong>；</li>
<li>贪心算法一般用来<strong>解决求最大或最小解</strong>；</li>
<li>贪心算法<strong>只能确定某些问题的可行性范围</strong>。</li>
</ol>
<h2 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h2><p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></td>
<td><a href="https://leetcode-cn.com/problems/largest-number/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-vn86e/">【宫水三叶の相信科学系列】为什么根据「拼接结果的字典序大小」决定「其在序列里的相对关系」是正确的</a><br/><a href="https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-by-leetcode-solution-sid5/">官方题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></td>
<td><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">【先排序，再插队】动画演示算法过程，有点小套路</a><br/><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode-sol/">官方题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></td>
<td><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/">官方题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/peaks-and-valleys-lcci/">面试题 10.11. 峰与谷</a></td>
<td><a href="https://leetcode-cn.com/problems/peaks-and-valleys-lcci/solution/onsuan-fa-qiu-jie-by-whut_hj/">O（n）算法求解</a></td>
</tr>
</tbody></table>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>经典得贪婪算法有<em><strong>Dijkstra’s algorithm</strong></em>, <em><strong>Huffman coding</strong></em>, <em><strong>Kruskal’s algorithm</strong></em>, <em><strong>optimal merge</strong></em>, <em><strong>Prim-Jarnik algorithm</strong></em>.</p>
<p>该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，Prim算法又被称为<strong>DJP算法</strong>、<strong>亚尔尼克算法</strong>或<em>Prim-Jarnik algorithm</em>.。</p>
<p>1951年，David A. Huffman和他的麻省理工学院信息理论同学们选择了学期论文。Robert M. Fano教授为寻找最有效的二进制代码问题分配了一份学期论文。Huffman无法证明任何代码是最有效的，他打算放弃并开始研究最终的结果时，他碰到使用频率排序二叉树的想法，并迅速证明这种方法是最有效的。这样做，Huffman超过了与信息理论发明家克劳德香农合作开发类似代码的范诺。与自顶向下Shannon-Fano编码不同，从底层构建树保证了最优性。1952年，于论文《一种构建极小多余编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）中发表了这个编码方法。</p>
<p><strong>Kruskal算法</strong>是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。</p>
<p>Edsger Dijkstra在1959年在ARMAC计算机上写出了Dijkstra算法，它来搜索最短路径的算法。Dijkstra是经典得贪婪算法之一。</p>
<p>在1968年，人工智能研究员尼尔斯·尼尔森(Nils Nilsson)试图改进机器人Shakey所做的路径规划，这个机器人原型可以通过在一个包含障碍物的房间进行导航。这种寻路算法，Nilsson称之为A1，是当时最著名的Hans Berliner于1979算法的更快版本，用于在图中找到最短路径。Bertram Raphael建议对这个算法进行一些重要的改进，并调用了修改后的A2。然后Peter E. Hart引入了一个论证，建立了A2，只有微小的变化，才能成为寻找最短路径的最佳算法。</p>
<p>1985 Richard Korf <strong>Iterative deepening A*</strong> (<strong>IDA*</strong>)是一种图遍历和路径搜索算法，它可以在一个加权图中找到指定的起始节点和一组目标节点的任何成员之间的最短路径。它是迭代深化深度优先搜索的一个变体，它借用了一个启发函数来评估剩余的成本，以从a <em>搜索算法获得目标。由于它是深度优先的搜索算法，它的内存使用率低于A</em>，但与普通的迭代深化搜索不同，它专注于探索最有希望的节点，因此不会访问。与A<em>不同，IDA</em>不使用动态编程，因此经常会多次访问相同的节点。1993年，Korf, R. E. (1993).对BFS进行延伸，提出RBFS，将**A***储存空间减小为线性增长。</p>
<h3 id="主要事件"><a href="#主要事件" class="headerlink" title="主要事件"></a>主要事件</h3><table>
<thead>
<tr>
<th></th>
<th>年份</th>
<th>事件</th>
<th>相关论文/Reference</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1952</td>
<td>Huffman, D. A.提出哈夫曼编码</td>
<td>Huffman, D. A. (1952). A method for the construction of minimum-redundancy codes. Proceedings of the IRE, 40(9), 1098-1101.</td>
</tr>
<tr>
<td>2</td>
<td>1958</td>
<td>Hart, P. E., Nilsson, N. J., &amp; Raphael, B.提出A星算法使用两个代价函数作为目标函数</td>
<td>Hart, P. E., Nilsson, N. J., &amp; Raphael, B. (1968). A formal basis for the heuristic determination of minimum cost paths. IEEE transactions on Systems Science and Cybernetics, 4(2), 100-107.</td>
</tr>
<tr>
<td>3</td>
<td>1959</td>
<td>Dijkstra, E. W.提出Dijkstra路径搜索算法</td>
<td>Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische mathematik, 1(1), 269-271.</td>
</tr>
<tr>
<td>4</td>
<td>1985</td>
<td>Korf, R. E.对A星算法进行了优化减小了A星算法的消耗</td>
<td>Korf, R. E. (1985). Depth-first iterative-deepening: An optimal admissible tree search. Artificial intelligence, 27(1), 97-109.</td>
</tr>
<tr>
<td>5</td>
<td>2000</td>
<td>Zhang, Z., Schwartz, S., Wagner, L., &amp; Miller, W.将贪婪算法应用于DNA得排序上</td>
<td>Zhang, Z., Schwartz, S., Wagner, L., &amp; Miller, W. (2000). A greedy algorithm for aligning DNA sequences. Journal of Computational biology, 7(1-2), 203-214.</td>
</tr>
</tbody></table>
<h2 id="发展分析"><a href="#发展分析" class="headerlink" title="发展分析"></a>发展分析</h2><h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><p>一个正确的贪心算法拥有很多优点，比如思维复杂度低、代码量小、运行效率高、空间复杂度低等，是信息学竞赛中的一个有力武器。缺点：贪心法的缺点集中表现在他的“非完美性”。通常我们很难找到一个简单可行并且保证正确的贪心思路，即使我们找到一个看上去很正确的贪心思路，也需要严格的正确性证明。这往往给我们直接使用贪心算法带来了巨大的困难。</p>
<h3 id="未来发展方向"><a href="#未来发展方向" class="headerlink" title="未来发展方向"></a>未来发展方向</h3><p>在求解一个问题的过程中，如果再每一个阶段的选择都是当前状态下的最优选择，即局部最优选择，并且最终能够求得问题的整体最优解，那么说明这个问题可以通过贪心选择来求解，这时就说明此问题具有贪心选择性质。然而如何，可以更简单得来证明一个问题具有贪心选择性质也是可以考虑得地方。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章总结来源：</p>
<ul>
<li><p><strong><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin&fromid=2979635&fromtitle=%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95">百度百科 - 贪心算法</a></strong></p>
</li>
<li><p><strong><a href="https://www.jiqizhixin.com/graph/technologies/d939b81d-166f-4a73-974f-a44976c15148">贪心算法</a></strong></p>
</li>
<li><p><strong><a href="https://oi-wiki.org/basic/greedy/#_11">贪心</a></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索</title>
    <url>/post/cb5e0eb8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记忆化搜索是一种典型的<strong>空间换时间</strong>的思想。</p>
<p>一般说来，动态规划总要遍历所有的状态，而<strong>搜索可以排除一些无效状态</strong>。更重要的是<strong>搜索</strong>还可以<strong>剪枝</strong>，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。<strong>记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解</strong>了。这种方法综合了搜索和动态规划两方面的优点，因而还是很有实用价值的。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>函数有返回值</li>
<li>函数返回结果和输入参数有关，和其他全局状态无关</li>
<li>参数列表中传入哈希表或者其他用于记录计算结果的数据结构</li>
</ul>
<p>在递归函数中, 在函数返回前，记录函数的返回结果。在下一次以同样参数访问函数时直接返回记录下的结果。也就是对递归树进行剪枝，遇到已经计算过的节点就不再继续往下计算，直接返回储存在哈希表或者其他数据结构中的值。</p>
<blockquote>
<p>本质上是自顶向下的动态规划加备忘录。</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></a></td>
<td><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">官方题解</a><br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/hua-jie-suan-fa-70-pa-lou-ti-by-guanpengchn/">画解算法：70. 爬楼梯</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></td>
<td><a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/">「手画图解」剖析三种解法: DFS, BFS, 动态规划 </a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></td>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/329-ju-zhen-zhong-de-zui-chang-di-zeng-l-64yg/">DFS（记忆化搜索）</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td>
<td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">【宫水三叶】一题三解 :「DFS/BFS」&amp;「贪心（位运算）」</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/post/f89cb603/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>红黑树是一种<strong>自平衡的二叉查找树</strong>，是一种高效的查找树。它是由 Rudolf Bayer 于1978年发明，在当时被称为 <strong>对称二叉 B 树(symmetric binary B-trees)<strong>。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的 <strong>红黑树</strong>。红黑树具有良好的效率，它</strong>可在</strong> <code>O(logN)</code> <strong>时间内完成查找、增加、删除等操作</strong>。因此，红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。考虑到红黑树是一种被广泛应用的数据结构，所以我们很有必要去弄懂它。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207175122084.png" style="zoom:80%;" />

<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>学过二叉查找树的同学都知道，普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些<strong>自平衡的查找树</strong>，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，<strong>将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态</strong>。以红黑树为例，红黑树通过如下的性质定义实现自平衡：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</li>
</ol>
<p>有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的节点进行增删查操作时，效率也会大大降低。这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证<strong>任意节点到其每个叶子节点路径最长不会超过最短路径的2倍</strong>。原因如下：</p>
<p>当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明一下，请看下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207180835565.png" style="zoom:80%;" />

<p>上图画出了从根节点 M 出发的到其叶子节点的最长和最短路径。这里偷懒只画出了两条最长路径，实际上最长路径有4条，分别为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">M -&gt; Q -&gt; O -&gt; N</span><br><span class="line">M -&gt; Q -&gt; O -&gt; p</span><br><span class="line">M -&gt; Q -&gt; Y -&gt; X</span><br><span class="line">M -&gt; Q -&gt; Y -&gt; Z</span><br></pre></td></tr></table></figure>

<p>长度为4，最短路径为 <code>M -&gt; E</code>，长度为2。最长路径的长度正好为最短路径长度的2倍。</p>
<p>前面说了关于红黑树的一些性质，这里还需要补充一些其他方面的东西。在红黑树简介一节中说到红黑树被发明出来的时候并不叫 <code>红黑树</code>，而是叫做 <code>对称二叉 B 树</code>，从名字中可发现红黑树和 B 树（这里指的是<strong>2-3树</strong>）或许有一定的关联，事实也正是如此。如果对红黑树的性质稍加修改，就能让红黑树和B树形成一一对应的关系。关于红黑树和 B 树关系的细节这里不展开说明了，有兴趣的同学可以参考<a href="https://book.douban.com/subject/19952400/">《算法》</a>第4版，那本书上讲的很透彻。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。</p>
<h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为左旋和右旋，<strong>左旋是将某个节点旋转为其右孩子的左孩子</strong>，而<strong>右旋是节点旋转为其左孩子的右孩子</strong>。这话听起来有点绕，所以还是请看下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182356324.png" style="zoom:80%;" />

<p>上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：</p>
<ol>
<li>将节点 M 的左孩子引用指向节点 E 的右孩子</li>
<li>将节点 E 的右孩子引用指向节点 M，完成旋转</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182602018.png" style="zoom:80%;" />

<p>上面分析了右旋操作，左旋操作与此类似，大家有兴趣自己画图试试吧，这里不再赘述了。旋转操作本身并不复杂，这里先分析到这吧。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。</p>
<p>接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：</p>
<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182903027.png" style="zoom:80%;" />

<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207183215154.png" style="zoom:80%;" />

<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所以性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152056319752.jpg" style="zoom:80%;" />

<h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><p>N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152057064115.jpg" style="zoom:80%;" />

<h4 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h4><p>N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152057476644.jpg" style="zoom:80%;" />

<h4 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h4><p>上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果<strong>叔叔节点为红色，直接变色</strong>即可。如果<strong>叔叔节点为黑色，则需要旋转，再交换颜色</strong>。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152052502152.jpg" style="zoom:80%;" />

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的<strong>前驱（该节点左子树中最大的节点）</strong>或者<strong>后继（该节点右子树中最小的节点）</strong>，然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。</p>
<p>红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。</p>
<p>在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为 <code>X</code>（至多只有一个孩子节点），其孩子节点为 <code>N</code>，<code>X</code> 的兄弟节点为 <code>S</code>，<code>S</code> 的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 <code>X</code> 被删除，节点 <code>N</code> 替换 <code>X</code> 的基础上进行的。这里说明把被删除的节点 <code>X</code> 特地拎出来说一下的原因是防止大家误以为节点 <code>N</code> 会被删除，不然后面就会看不明白。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15272593488180.jpg" style="zoom:80%;" />

<p>在上面的基础上，接下来就可以展开讨论了。红黑树删除有6种情况，分别是：</p>
<h4 id="情况一-1"><a href="#情况一-1" class="headerlink" title="情况一"></a>情况一</h4><blockquote>
<p>N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。</p>
</blockquote>
<p>上面是维基百科中关于红黑树删除的情况一说明，由于没有配图，看的有点晕。经过思考，我觉得可能会是下面这种情形：</p>
<p>要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。</p>
<p>可能还有其他情形，大家如果知道，烦请告知。</p>
<h4 id="情况二-1"><a href="#情况二-1" class="headerlink" title="情况二"></a>情况二</h4><p>S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（<code>P -&gt; X -&gt; N</code>），现在只剩两个了（<code>P -&gt; N</code>）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152097130545.jpg" style="zoom:80%;" />

<h4 id="情况三-1"><a href="#情况三-1" class="headerlink" title="情况三"></a>情况三</h4><p>N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152097574115.jpg" style="zoom:80%;" />

<h4 id="情况四-1"><a href="#情况四-1" class="headerlink" title="情况四"></a>情况四</h4><p>N 的父节点为红色，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以把 S 染成红色，把P染成黑色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致且经过 P 的路径黑色节点数不变。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207194653272.png" style="zoom:80%;" />

<h4 id="情况五-1"><a href="#情况五-1" class="headerlink" title="情况五"></a>情况五</h4><p>S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152098446251.jpg" style="zoom:80%;" />

<h4 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h4><p>S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：</p>
<ol>
<li>该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。</li>
<li>该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152098765266.jpg" style="zoom:80%;" />

<h4 id="删除总结"><a href="#删除总结" class="headerlink" title="删除总结"></a>删除总结</h4><p>红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152095299211.jpg" style="zoom:80%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树是一种重要的二叉树，应用广泛，但在很多数据结构相关的书本中出现的次数并不多。很多书中要么不说，要么就一笔带过，并不会进行详细的分析，这可能是因为红黑树比较复杂的缘故。我在学习红黑树的时候也找了很多资料，但总体感觉讲的都不太好。尤其是在我学习删除操作的时候，很多资料是实在人看不下去，看的我很痛苦。直到我看到维基百科上关于<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a>的分析时，很是欣喜。这篇文章分析的很有条理，言简意赅，比很多资料好了太多。本文对红黑树的分析也主要参考了维基百科中的红黑树分析，并对维基百科中容易让人产生疑问和误解的地方进行了说明。同时维基百科中文版红黑树文中的图片较为模糊，这里我重新进行了绘制。需要说明的是，维基百科中文版无法打开了，文中关于维基百科的链接都是英文版的。另外在给大家推荐一个数据结构可视化的网站，里面包含常见数据结构可视化过程，地址为：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">t.cn/RZFgryr</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/19952400/">《算法》第四版</a></li>
<li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树 – 维基百科</a></li>
</ul>
<p>推荐阅读：</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/24367771">红黑树深入剖析及Java实现</a></p>
</li>
<li><p><a href="https://brianway.github.io/2016/10/14/algorithms-data-structures-2/">常见数据结构(二)-树(二叉树，红黑树，B树)</a></p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://www.tianxiaobo.com/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">红黑树详细分析</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>自平衡树</tag>
        <tag>查找树</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/post/2e152a56/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">跳跃列表</a> 的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素，当工作中遇到某些场景时，需要想到可以使用跳表解决问题即可。毕竟平时的工作都是直接使用封装好的跳表，例如：java.util.concurrent 下的 ConcurrentSkipListMap()。</p>
<span id="more"></span>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="理解跳表，从单链表开始说起"><a href="#理解跳表，从单链表开始说起" class="headerlink" title="理解跳表，从单链表开始说起"></a>理解跳表，从单链表开始说起</h3><p>下图是一个简单的<strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115621197.png" style="zoom:67%;" />

<p>现在我们有个场景，想快速找到上图链表中的 10 这个元素，只能从头开始遍历链表，直到找到我们需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度很高O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115700024.png" style="zoom:67%;" />

<p>先在索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，于是不往后找了，而是通过 9 找到原始链表的 9，然后再往后遍历找到了我们要找的 10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p>
<p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115735116.png" style="zoom:67%;" />

<p>可能同学们会想，从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115830967.png" style="zoom:67%;" />

<p>到这里大家应该已经明白了什么是跳表。跳表是<strong>可以实现二分查找的有序链表</strong>。</p>
<h2 id="操作-amp-时空复杂度分析"><a href="#操作-amp-时空复杂度分析" class="headerlink" title="操作 &amp; 时空复杂度分析"></a>操作 &amp; 时空复杂度分析</h2><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><p>既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。</p>
<p>先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2<sup>k</sup>个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2<sup>h</sup>，即 h = log2<sup>n</sup> - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2<sup>n</sup>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120216604.png" style="zoom:67%;" />

<p>我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？</p>
<p>图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p>
<p>跳表的索引高度 h = log2<sup>n</sup>，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 <code>O(3*logn)</code>，省略常数即：<code>O(logn)</code>。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“<strong>空间换时间</strong>”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？</p>
<p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，空间复杂度是 <code>O(n)</code>。</p>
<p>如下图所示：如果每三个结点抽一个结点做为索引，索引总和数就是 n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据我们的应用场景来控制这个阈值，看我们更注重时间还是空间。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120715377.png" style="zoom:67%;" />

<p>但是，索引结点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号（int 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据看起来也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。如下图所示，要插入数据6，整个过程类似于查找6，整个的查找路径为 1、1、1、4、4、5。查找到第底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。整个时间复杂度为查找元素的时间复杂度 <code>O(logn)</code>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120902084.png" style="zoom:67%;" />

<p>如下图所示，假如一直往原始列表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 O(logn) 退化为 O(n)。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208121034389.png" style="zoom:67%;" />

<p>比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删掉全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。</p>
<p>那有没有其他效率比较高的方式来维护索引呢？假如跳表每一层的晋升概率是 1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素做为一级索引。换种说法，<strong>我们在原始链表中随机的选 n/2 个元素做为一级索引是不是也能通过索引提高查找的效率呢？</strong> 当然可以了，因为一般随机选的元素相对来说都是比较均匀的。如下图所示，随机选择了n/2 个元素做为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素 16，仍然可以通过一级索引，使得遍历路径较少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素 1、3、4、5、7、8，那么查找效率确实没有提升，但是这样的概率太小了。我们可以认为：当原始链表中<strong>元素数量足够大</strong>，且<strong>抽取足够随机</strong>的话，我们得到的索引是均匀的。我们要清楚设计良好的数据结构都是为了应对大数据量的场景，如果原始链表只有 5 个元素，那么依次遍历 5 个元素也没有关系，因为数据量太少了。所以，我们可以维护一个这样的索引：<strong>随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208121650431.png" style="zoom:67%;" />

<p>那代码该如何实现，才能使跳表满足上述这个样子呢？可以在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮我们把控这个 1/2、1/4、1/8 … ，<strong>当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。下面开始讲解这个概率算法代码如何实现。</p>
<p>我们可以实现一个 <code>randomLevel()</code> 方法，该方法会随机生成 <code>1~MAX_LEVEL</code> 之间的数（<code>MAX_LEVEL</code>表示索引的最高层数），且该方法<strong>有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推</strong>。</p>
<ul>
<li><code>randomLevel()</code> 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）</li>
<li><code>randomLevel()</code> 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）</li>
<li><code>randomLevel()</code> 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）</li>
<li><code>randomLevel()</code> 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）</li>
<li>…（以此类推）</li>
</ul>
<p>所以，通过 <code>randomLevel()</code> 方法，我们可以控制整个跳表各级索引中元素的个数。<strong>重点来了</strong>：<code>randomLevel()</code> 方法返回 2 的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的 1/2，但是 <code>randomLevel()</code> 方法返回 2 的概率为 1/4，那是不是有矛盾呢？明明说好的 1/2，结果一级索引元素个数怎么变成了原始链表的 1/4？我们先看下图，应该就明白了。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208122204227.png" style="zoom:67%;" />

<p>假设我们在插入元素 6 的时候，<code>randomLevel()</code> 方法返回 1，则我们不会为 6 建立索引。插入 7 的时候，<code>randomLevel()</code> 方法返回3 ，所以我们需要为元素 7 建立二级索引。这里我们发现了一个特点：当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。所以，一级索引中元素的个数等于 [ 原始链表元素个数 ] * [ <code>randomLevel()</code> 方法返回值 &gt; 1 的概率 ]。因为 <code>randomLevel()</code> 方法返回值 &gt; 1就会建索引，凡是建索引，无论几级索引必然有一级索引，<strong>所以一级索引中元素个数占原始数据个数的比率为 randomLevel() 方法返回值 &gt; 1 的概率</strong>。那 <code>randomLevel()</code> 方法返回值 &gt; 1 的概率是多少呢？因为 <code>randomLevel()</code> 方法随机生成 <code>1~MAX_LEVEL</code> 的数字，且 <code>randomLevel()</code> 方法返回值 1 的概率为 1/2，则 <code>randomLevel()</code> 方法返回值 &gt; 1 的概率为 1 - 1/2 = 1/2。即<strong>通过上述流程实现了一级索引中元素个数占原始数据个数的 1/2</strong>。</p>
<p>同理，当 <code>randomLevel()</code> 方法返回值 &gt; 2 时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此<strong>二级索引中元素个数占原始数据的比率为 randomLevel() 方法返回值 &gt; 2 的概率</strong>。 <code>randomLevel()</code> 方法返回值 &gt; 2 的概率为 1 减去 <code>randomLevel()</code> = 1 或 =2 的概率，即 1 - 1/2 - 1/4 = 1/4。OK，达到了我们设计的目标：<strong>二级索引中元素个数占原始数据的 1/4</strong>。</p>
<p>以此类推，可以得出，遵守以下两个条件：</p>
<ul>
<li><code>randomLevel()</code> 方法，随机生成 <code>1~MAX_LEVEL</code> 之间的数（<code>MAX_LEVEL</code>表示索引的最高层数），且<strong>有 1/2的概率返回 1、1/4的概率返回 2、1/8的概率返回 3 …</strong></li>
<li><code>randomLevel()</code> 方法返回 1 不建索引、返回 2 建一级索引、返回 3 建二级索引、返回 4 建三级索引 …</li>
</ul>
<p>就可以满足我们想要的结果，即：一级索引中元素个数应该占原始数据的 1/2，二级索引中元素个数占原始数据的 1/4，三级索引中元素个数占原始数据的 1/8 ，依次类推，一直到最顶层索引。</p>
<p>但是问题又来了，怎么设计这么一个 <code>randomLevel()</code> 方法呢？直接撸代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span></span><br><span class="line"><span class="comment">//        1/2 的概率返回 1</span></span><br><span class="line"><span class="comment">//        1/4 的概率返回 2</span></span><br><span class="line"><span class="comment">//        1/8 的概率返回 3 以此类推</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1</span></span><br><span class="line">  <span class="keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)</span><br><span class="line">    level += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以实现我们的功能，而且，我们的案例中晋升概率 SKIPLIST_P 设置的 1/2，即：每两个结点抽出一个结点作为上一级索引的结点。如果我们想节省空间利用率，可以适当的降低代码中的 SKIPLIST_P，从而减少索引元素个数，Redis 的 zset 中 SKIPLIST_P 设定的 0.25。下图所示，是Redis <a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c">t_zset.c</a> 中 zslRandomLevel 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 源码中 <code>(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)</code>  在功能上等价于我代码中的 <code>Math.random() &lt; SKIPLIST_P</code> ，只不过 Redis 作者 <a href="https://github.com/antirez">antirez</a> 使用位运算来提高浮点数比较的效率。</p>
<p>整体思路大家应该明白了，那插入数据时维护索引的时间复杂度是多少呢？元素插入到单链表的时间复杂度为 <code>O(1)</code>，我们索引的高度最多为 <code>logn</code>，当插入一个元素 x 时，最坏的情况就是元素 x 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 <code>O(logn)</code>。</p>
<p>过程大概理解了，再通过一个例子描述一下跳表插入数据的全流程。现在我们要插入数据 6 到跳表中，首先 randomLevel() 返回 3，表示<strong>需要建二级索引</strong>，即：一级索引和二级索引需要增加元素 6。该跳表目前最高三级索引，首先找到三级索引的 1，发现 6 比 1大比 13小，所以，从 1 下沉到二级索引。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125241674.png" style="zoom:67%;" />

<p>下沉到二级索引后，发现 6 比 1 大比 7 小，此时需要在二级索引中 1 和 7 之间加一个元素6 ，并从元素 1 继续下沉到一级索引。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125308947.png" style="zoom:67%;" />

<p>下沉到一级索引后，发现 6 比 1 大比 4 大，所以往后查找，发现 6 比 4 大比 7 小，此时需要在一级索引中 4 和 7 之间加一个元素 6 ，并把二级索引的 6 指向 一级索引的 6，最后，从元素 4 继续下沉到原始链表。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125342542.png" style="zoom:67%;" />

<p>下沉到原始链表后，就比较简单了，发现 4、5 比 6小，7比6大，所以将6插入到 5 和 7 之间即可，整个插入过程结束。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125414593.png" style="zoom:67%;" />

<p>整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 <code>O(1)</code>，所以整个插入的时间复杂度是 <code>O(logn)</code>。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125528595.png" style="zoom:67%;" />

<p>跳表中，删除元素的时间复杂度是多少呢？</p>
<p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <code>O(1)</code>，索引层数为 <code>logn</code> 表示最多需要删除 <code>logn</code> 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> 加 <em>删除 logn个元素的时间</em> 为 <code>O(logn) + O(logn) = 2 O(logn)</code>，忽略常数部分，删除元素的时间复杂度为 <code>O(logn)</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>跳表是可以实现二分查找的有序链表；</li>
<li>每个元素插入时随机生成它的 level；</li>
<li>最底层包含所有的元素；</li>
<li>如果一个元素出现在 <code>level(x)</code>，那么它肯定出现在 x 以下的 level中；</li>
<li>每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</li>
</ol>
<h2 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h2><p>Redis 中的有序集合(<code>zset</code>) 支持的操作：</p>
<ol>
<li>插入一个元素</li>
<li>删除一个元素</li>
<li>查找一个元素</li>
<li>有序输出所有元素</li>
<li>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</li>
</ol>
<p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 <code>O(logn)</code> 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p>
<h2 id="工业上其他使用跳表的场景"><a href="#工业上其他使用跳表的场景" class="headerlink" title="工业上其他使用跳表的场景"></a>工业上其他使用跳表的场景</h2><p>在博客上从来没有见过有同学讲述 HBase MemStore 的数据结构，其实 HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的<strong>有序文件</strong>，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 <code>java.util.concurrent</code> 下的 <code>ConcurrentSkipListMap()</code>。</p>
<p>Google 开源的 <code>key/value</code> 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，他们内部的 MemTable 都是使用了跳表这种数据结构。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c">Redis zset源码</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文章转载来源：</p>
<ul>
<li><strong><a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一）</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>跳表</tag>
        <tag>双向链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>面试规则</title>
    <url>/post/d13fc60c/</url>
    <content><![CDATA[<p><strong>规则一：面试的本质是寻找同类（同道中人）</strong></p>
<ul>
<li>知识密集型岗位（需要共鸣）</li>
</ul>
<p><strong>规则二：问题之间是可以转化的</strong></p>
<blockquote>
<p>可以将面试官问的问题转化为对应的具体的知识点，例如：</p>
<p>有没有高并发经验？ -&gt; 分库分表、缓冲区的使用、高并发网络IO如何处理</p>
</blockquote>
<span id="more"></span>
<p><strong>规则三：问题是可以被拆解的</strong></p>
<blockquote>
<p>有没有做过大项目？</p>
<p>拆解：什么样的大项目？</p>
<p>项目大在哪里？</p>
<ul>
<li>需求特别多？排期特别长？</li>
<li>沟通复杂？团队多？</li>
<li>技术特别难？</li>
</ul>
</blockquote>
<blockquote>
<p>类似的问题：</p>
<ul>
<li>Java做过几年？</li>
<li>有没有大项目经验？</li>
<li>有没有高并发经验？</li>
<li>有没有XXX方向的经验？</li>
</ul>
<p>应对方法：学会拆解问题，避虛就实，用硬核知识突破面试</p>
</blockquote>
<p><strong>规则四：永远不要被面试官牵着鼻子走</strong></p>
<blockquote>
<p>应对方法：“引导”面试官提问自己熟悉的知识，从而展示自己学习能力和对知识的学习深度（是否透彻）。</p>
</blockquote>
<p><strong>规则五：给面试官有思想深度的回答</strong></p>
<blockquote>
<p>如何说？<br>正着说、反着说、折中说、避免「背诵」</p>
<p>例如：</p>
<p>面试官：给我解释下高并发?</p>
<ul>
<li>高并发的核心是开发成本和硬件成本之间找到一个折中可行的方案</li>
<li>简单点说解决高并发是在延迟和丢包率可控的情况下，追求吞吐量</li>
<li>解决高并发要关注线程和I/O模型、数据库选型、缓存优化、缓冲区设计、解耦和消息队列、分布式服务设计等等方面的设计</li>
</ul>
<p>应对方法：只有自己<strong>对知识理解透彻</strong>的情况下，才能用自己的语言正确的表述出来。</p>
</blockquote>
<blockquote>
<p><strong>非官方、简短而本质的回答</strong></p>
<ul>
<li>LinkedHashMap是一个元素间用链表相连的哈希表</li>
<li>HashMap就是哈希表实现的Map，TreeMap是用树实现的Map，Map是一种映射关系</li>
<li>AQS解决Java语言没有实现同步元语底层框架的问题</li>
<li>B+树是一棵支持区间查找的B树</li>
<li>DNS是一个经典的分布式设计、BigTable是另一个</li>
<li>元编程是程序改写程序</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试软技能</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里Java开发手册</title>
    <url>/post/a5aab1c5/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
  </entry>
</search>
