<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap 的 7 种遍历方式与性能分析</title>
    <url>/post/844a20bd/</url>
    <content><![CDATA[<p>随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式，但应该选择那种遍历方式？反而成了一个问题。</p>
<p>本文<strong>先从 HashMap 的遍历方法讲起，然后再从性能、原理以及安全性等方面，来分析 HashMap 各种遍历方式的优势与不足</strong>，本文主要内容如下图所示：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220203232307417.png" style="zoom:75%;" />

<h2 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h2><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li><p>迭代器（Iterator）方式遍历；</p>
</li>
<li><p>For Each 方式遍历；</p>
</li>
<li><p>Lambda 表达式遍历（JDK 1.8+）；</p>
</li>
<li><p>Streams API 遍历（JDK 1.8+）。</p>
<span id="more"></span>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p>
</li>
<li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p>
</li>
<li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p>
</li>
<li><p>使用 For Each EntrySet 的方式进行遍历；</p>
</li>
<li><p>使用 For Each KeySet 的方式进行遍历；</p>
</li>
<li><p>使用 Lambda 表达式的方式进行遍历；</p>
</li>
<li><p>使用 Streams API 单线程的方式进行遍历；</p>
</li>
<li><p>使用 Streams API 多线程的方式进行遍历。</p>
</li>
</ol>
<p>接下来我们来看每种遍历方式的具体实现代码。</p>
<h3 id="迭代器-EntrySet"><a href="#迭代器-EntrySet" class="headerlink" title="迭代器 EntrySet"></a>迭代器 EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Java</span><br><span class="line">2</span><br><span class="line">JDK</span><br><span class="line">3</span><br><span class="line">Spring Framework</span><br><span class="line">4</span><br><span class="line">MyBatis Framework</span><br><span class="line">5</span><br><span class="line">Java中文社群</span><br></pre></td></tr></table></figure>

<h3 id="迭代器-KeySet"><a href="#迭代器-KeySet" class="headerlink" title="迭代器 KeySet"></a>迭代器 KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="ForEach-EntrySet"><a href="#ForEach-EntrySet" class="headerlink" title="ForEach EntrySet"></a>ForEach EntrySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="ForEach-KeySet"><a href="#ForEach-KeySet" class="headerlink" title="ForEach KeySet"></a>ForEach KeySet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Streams-API-单线程"><a href="#Streams-API-单线程" class="headerlink" title="Streams API 单线程"></a>Streams API 单线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果同上。</p>
<h3 id="Streams-API-多线程"><a href="#Streams-API-多线程" class="headerlink" title="Streams API 多线程"></a>Streams API 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>接下来使用 Oracle 官方提供的性能测试工具 <strong>JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）</strong>来测试一下这 7 种循环的性能。</p>
<p>首先，先要引入 JMH 框架，在 <code>pom.xml</code> 文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写测试代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 测试完成时间</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热 2 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试 5 轮，每次 1s</span></span><br><span class="line"><span class="meta">@Fork(1)</span> <span class="comment">// fork 1 个线程</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个测试线程一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapCycleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            put(i, <span class="string">&quot;val:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动基准测试</span></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(HashMapCycle.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line">                .output(<span class="string">&quot;/Users/admin/Desktop/jmh-map.log&quot;</span>) <span class="comment">// 输出测试结果的文件</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer k = iterator.next();</span><br><span class="line">            String v = map.get(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            Integer k = key;</span><br><span class="line">            String v = map.get(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            Integer k = key;</span><br><span class="line">            String v = value;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单线程遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parallelStreamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            Integer k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有被添加了 <code>@Benchmark</code> 注解的方法都会被测试，因为 parallelStream 为多线程版本性能一定是最好的，所以就不参与测试了，其他 6 个方法的测试结果如下：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220203233203211.png"></p>
<p>其中 Units 为 <code>ns/op</code> 意思是执行完成时间（单位为纳秒），而 Score 列为平均执行时间， <code>±</code> 符号表示误差。从以上结果可以看出，两个 <code>entrySet</code> 的性能相近，并且执行速度最快，接下来是 <code>stream</code> ，然后是两个 <code>keySet</code>，性能最差的是 <code>lambda</code> 。</p>
<blockquote>
<p>注：以上结果基于测试环境：JDK 1.8 / Mac mini (2018) / Idea 2020.1</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>从以上结果可以看出 entrySet 的性能比 keySet 的性能高出了一倍之多，因此我们应该尽量使用 entrySet 来实现 Map 集合的遍历</strong>。</p>
<h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p>要理解以上的测试结果，我们需要把所有遍历代码通过 <code>javac</code> 编译成字节码来看具体的原因。</p>
<p>编译后，我们使用 Idea 打开字节码，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var1 = <span class="number">0</span>; var1 &lt; <span class="number">2</span>; ++var1) &#123;</span><br><span class="line">                <span class="keyword">this</span>.put(var1, <span class="string">&quot;val:&quot;</span> + var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        entrySet();</span><br><span class="line">        keySet();</span><br><span class="line">        forEachEntrySet();</span><br><span class="line">        forEachKeySet();</span><br><span class="line">        lambda();</span><br><span class="line">        streamApi();</span><br><span class="line">        parallelStreamApi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Entry var1 = (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Integer var1 = (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Entry var1 = (Entry)var0.next();</span><br><span class="line">            System.out.println(var1.getKey());</span><br><span class="line">            System.out.println((String)var1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator var0 = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">            Integer var1 = (Integer)var0.next();</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">            System.out.println((String)map.get(var1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.forEach((var0, var1) -&gt; &#123;</span><br><span class="line">            System.out.println(var0);</span><br><span class="line">            System.out.println(var1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.entrySet().stream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelStreamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.entrySet().parallelStream().forEach((var0) -&gt; &#123;</span><br><span class="line">            System.out.println(var0.getKey());</span><br><span class="line">            System.out.println((String)var0.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 <code>for</code> 循环的遍历的 <code>EntrySet</code> 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 <code>Entry</code> ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Entry var1 = (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachEntrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Entry var1 = (Entry)var0.next();</span><br><span class="line">        System.out.println(var1.getKey());</span><br><span class="line">        System.out.println((String)var1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>KeySet</code> 的代码也是类似的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Integer var1 = (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEachKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator var0 = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line">        Integer var1 = (Integer)var0.next();</span><br><span class="line">        System.out.println(var1);</span><br><span class="line">        System.out.println((String)map.get(var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在使用迭代器或是 <code>for</code> 循环 <code>EntrySet</code> 时，他们的性能都是相同的，因为他们最终生成的字节码基本都是一样的；同理 <code>KeySet</code> 的两种遍历方式也是类似的。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“<code>Entry&lt;Integer, String&gt; entry = iterator.next()</code>”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h2 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h2><p>从上面的性能测试结果和原理分析，我想大家应该选用哪种遍历方式，已经心中有数的，而接下来从「安全」的角度入手，来分析哪种遍历方式更安全。</p>
<p>把以上遍历划分为四类进行测试：迭代器方式、For 循环方式、Lambda 方式和 Stream 方式，测试代码如下。</p>
<h3 id="迭代器方式"><a href="#迭代器方式" class="headerlink" title="迭代器方式"></a>迭代器方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">show:0</span><br><span class="line">del:1</span><br><span class="line">show:2</span><br></pre></td></tr></table></figure>

<p>测试结果：<strong>迭代器中循环删除数据安全</strong>。</p>
<h3 id="For-循环方式"><a href="#For-循环方式" class="headerlink" title="For 循环方式"></a>For 循环方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204114938065.png" style="zoom:80%;" />

<p>测试结果：<strong>For 循环中删除数据非安全</strong>。</p>
<h3 id="Lambda-方式"><a href="#Lambda-方式" class="headerlink" title="Lambda 方式"></a>Lambda 方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204115254456.png" style="zoom:80%;" />

<p>测试结果：<strong>Lambda 循环中删除数据非安全</strong>。</p>
<p><strong>Lambda 删除的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 map 中的 key 去判断删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; key == <span class="number">1</span>);</span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">show:0</span><br><span class="line">show:2</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，可以先使用 <code>Lambda</code> 的 <code>removeIf</code> 删除多余的数据，再进行循环是一种正确操作集合的方式。</p>
<h3 id="Stream-方式"><a href="#Stream-方式" class="headerlink" title="Stream 方式"></a>Stream 方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">        map.remove(entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220204115422219.png" style="zoom:80%;" />

<p>image.png</p>
<p>测试结果：<strong>Stream 循环中删除数据非安全</strong>。</p>
<p><strong>Stream 循环的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().filter(m -&gt; <span class="number">1</span> != m.getKey()).forEach((entry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：同上。</p>
<p>从上面的代码可以看出，可以使用 <code>Stream</code> 中的 <code>filter</code> 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们讲了 HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，<strong>我们应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。</p>
<p>文章来源：<a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap 的 7 种遍历方式与性能分析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程（基础）</title>
    <url>/post/7f164aae/</url>
    <content><![CDATA[<h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称<strong>主线程</strong>。</p>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202211820997.png" style="zoom:75%;" />

<h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[5] Attach Listener //添加事件</span><br><span class="line">[4] Signal Dispatcher //分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer //调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler //清除 reference 线程</span><br><span class="line">[1] main //main 线程,程序入口</span><br></pre></td></tr></table></figure>

<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p>
<h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202212556937.png" style="zoom:80%;" />

<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h3 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h3><ul>
<li><strong>虚拟机栈：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong>等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是<strong>所有线程共享的资源</strong>，其中<strong>堆是进程中最大的一块内存</strong>，主要用于存放<strong>新创建的对象</strong>（几乎所有对象都在这里分配内存），方法区主要用于存放<strong>已被加载的类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</p>
<h2 id="说说并发与并行的区别？"><a href="#说说并发与并行的区别？" class="headerlink" title="说说并发与并行的区别？"></a>说说并发与并行的区别？</h2><p><strong>并发：</strong>同一时间段，多个任务都在执行（单位时间内不一定同时执行）；</p>
<p><strong>并行：</strong>单位时间内（同一时刻），多个任务同时执行。</p>
<h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是<strong>程序执行的最小单位</strong>，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>：多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
<h2 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h2 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202220155953.png" alt="图源《Java 并发编程艺术》4.1.4 节"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202220327647.png" alt="图源《Java 并发编程艺术》4.1.4 节"></p>
<blockquote>
<p>订正(来自<a href="https://github.com/Snailclimb/JavaGuide/issues/736">issue736</a>)：原图中 wait 到 runnable 状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p>
</blockquote>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong>（摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">java线程运行怎么有第六种状态？ - Dawell的回答</a>）现在的<strong>时分</strong>（time-sharing）<strong>多任务</strong>（multi-task）操作系统架构通常都是用所谓的“<strong>时间分片</strong>（time quantum or time slice）”方式进行<strong>抢占式</strong>（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202221236800.png"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING（超时等待）</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code>方法或 <code>wait(long millis)</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用<strong>同步方法</strong>时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</a></p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><p>线程在执行过程中会有自己的<strong>运行条件和状态</strong>（也称<strong>上下文</strong>），比如上文所说到过的<strong>程序计数器</strong>，<strong>栈信息</strong>等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行。</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="什么是线程死锁？如何避免死锁？"><a href="#什么是线程死锁？如何避免死锁？" class="headerlink" title="什么是线程死锁？如何避免死锁？"></a>什么是线程死锁？如何避免死锁？</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220202222752163.png"></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<p>产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称&lt;P1、P2、P3…..Pn&gt;序列为安全序列。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">	System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul>
<li>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程<strong>进入了就绪状态</strong>，当分配到时间片后就可以<strong>开始运行</strong>了。 <code>start()</code> 会执行线程的相应<strong>准备工作</strong>，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<p>文章来源：<a href="https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">Java 并发常见知识点&amp;面试题总结（基础篇）</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/post/9fa75fc1/</url>
    <content><![CDATA[<p>Java <em>Lambda 表达式</em>的一个重要用法是简化某些<em>匿名内部类</em>（<code>Anonymous Classes</code>）的写法。实际上 Lambda 表达式并不仅仅是匿名内部类的语法糖，JVM 内部是通过<em>invokedynamic</em>指令来实现 Lambda 表达式的。具体原理放到下一篇。本篇我们首先感受一下使用 Lambda 表达式带来的便利之处。</p>
<h2 id="Lambda-and-Anonymous-Classes-I"><a href="#Lambda-and-Anonymous-Classes-I" class="headerlink" title="Lambda and Anonymous Classes(I)"></a>Lambda and Anonymous Classes(I)</h2><p>本节将介绍如何使用 Lambda 表达式简化匿名内部类的书写，但 Lambda 表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。先别在乎细节，看几个例子再说。</p>
<p>例子 1：无参函数的简写</p>
<p>如果需要新建一个线程，一种常见的写法是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;<span class="comment">// 接口名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Thread run()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上述代码给<code>Tread</code>类传递了一个匿名的<code>Runnable</code>对象，重载<code>Runnable</code>接口的<code>run()</code>方法来实现相应逻辑。这是 JDK7 以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在 Java 8 中可以简化为如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">		() -&gt; System.out.println(<span class="string">&quot;Thread run()&quot;</span>)<span class="comment">// 省略接口名和方法名</span></span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的，但比匿名内部类更进一步。这里连<strong>接口名和函数名都一同省掉</strong>了，写起来更加神清气爽。如果函数体有多行，可以用大括号括起来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式代码块写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; Hoolee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>例子 2：带参函数的简写</p>
<p>如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7 的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;<span class="comment">// 接口名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码通过内部类重载了<code>Comparator</code>接口的<code>compare()</code>方法，实现比较逻辑。采用 Lambda 表达式可简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt;&#123;<span class="comment">// 省略参数表的类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于<code>javac</code>的<strong>类型推断</strong>机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java 是强类型语言，每个变量和对象都必需有明确的类型。</p>
<h3 id="简写的依据"><a href="#简写的依据" class="headerlink" title="简写的依据"></a>简写的依据</h3><p>也许你已经想到了，<strong>能够使用 Lambda 的依据是必须有相应的函数接口</strong>（函数接口，是指内部只有一个抽象方法的接口）。这一点跟 Java 是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写 Lambda 表达式。实际上<em>Lambda 的类型就是对应函数接口的类型</em>。<strong>Lambda 表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda 表达更多合法的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的书写形式</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">// 1</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>);<span class="comment">// 2</span></span><br><span class="line">Runnable multiLine = () -&gt; &#123;<span class="comment">// 3 代码块</span></span><br><span class="line">    System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; Hoolee&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class="comment">// 4</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class="comment">// 5 类型推断</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，1 展示了无参函数的简写；2 处展示了有参函数的简写，以及类型推断机制；3 是代码块的写法；4 和 5 再次展示了类型推断机制。</p>
<h3 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h3><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的@FunctionalInterface 是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override 标注会检查是否重载了函数一样。</p>
<p>有了上述接口定义，就可以写出类似如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>进一步的，还可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myForEach</span><span class="params">(ConsumerInterface&lt;T&gt; consumer)</span></span>&#123;<span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">for</span>(T t : list)&#123;</span><br><span class="line">			consumer.accept(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyStream&lt;String&gt; stream = <span class="keyword">new</span> MyStream&lt;String&gt;();</span><br><span class="line">stream.myForEach(str -&gt; System.out.println(str));<span class="comment">// 使用自定义函数接口书写Lambda表达式</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda-and-Anonymous-Classes-II"><a href="#Lambda-and-Anonymous-Classes-II" class="headerlink" title="Lambda and Anonymous Classes(II)"></a>Lambda and Anonymous Classes(II)</h2><p>读过上一篇之后，相信对 Lambda 表达式的语法以及基本原理有了一定了解。对于编写代码，有这些知识已经够用。本文将<strong>进一步区分 Lambda 表达式和匿名内部类在 JVM 层面的区别，如果对这一部分不感兴趣，可以跳过</strong>。</p>
<p>经过第一篇的的介绍，我们看到 Lambda 表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的 Lambda 表达式替换成匿名内部类就可以了。但实时并非如此。在 JVM 层面，Lambda 表达式和匿名内部类有着明显的差别。</p>
<h3 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h3><p><strong>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名</strong>。因此如果有如下形式的代码，编译之后将会产生两个 class 文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Anonymous Class Thread run()&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>编译之后文件分布如下，两个 class 文件分别是主类和匿名内部类产生的：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/2-AnonymousClass.png"></p>
<p>进一步分析主类 MainAnonymousClass.class 的字节码，可发现其创建了匿名内部类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c MainAnonymousClass.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class MainAnonymousClass$1 /*创建内部类对象*/</span></span><br><span class="line">       <span class="number">7</span>: dup</span><br><span class="line">       <span class="number">8</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method MainAnonymousClass$1.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">11</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式实现"><a href="#Lambda-表达式实现" class="headerlink" title="Lambda 表达式实现"></a>Lambda 表达式实现</h3><p><strong>Lambda 表达式通过 invokedynamic 指令实现，书写 Lambda 表达式不会产生新的类</strong>。如果有如下代码，编译之后只有一个 class 文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(</span><br><span class="line">				() -&gt; System.out.println(<span class="string">&quot;Lambda Thread run()&quot;</span>)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的结果：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/2-Lambda.png"></p>
<p>通过 javap 反编译命名，我们更能看出 Lambda 表达式内部表示的不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c -p MainLambda.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokedynamic #<span class="number">3</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span></span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();  <span class="comment">/*Lambda表达式被封装成主类的私有方法*/</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">6</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String Lambda Thread run()</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后我们发现 Lambda 表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p>
<h3 id="推论，this-引用的意义"><a href="#推论，this-引用的意义" class="headerlink" title="推论，this 引用的意义"></a>推论，this 引用的意义</h3><p>既然 Lambda 表达式不是内部类的简写，那么 Lambda 内部的<code>this</code>引用也就跟内部类对象没什么关系了。在 Lambda 表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出两遍<code>Hello Hoolee</code>，而不是两个引用地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>); &#125;;</span><br><span class="line">	Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">		<span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello Hoolee&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h2><p>我们先从最熟悉的*Java 集合框架(Java Collections Framework, JCF)*开始说起。</p>
<p>为引入 Lambda 表达式，Java8 新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是 Lambda 表达式的基础，Java 集合框架也新增部分接口，以便与 Lambda 表达式对接。</p>
<p>首先回顾一下 Java 集合框架的接口继承结构：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/JCF_Collection_Interfaces.png"></p>
<p>上图中绿色标注的接口类，表示在 Java8 中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8 新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟 Lambda 表达式相关。我们将逐一学习这些方法。</p>
<h3 id="Collection-中的新方法"><a href="#Collection-中的新方法" class="headerlink" title="Collection 中的新方法"></a>Collection 中的新方法</h3><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以是<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于 3 的字符串.</em></p>
<p>Java7 及以前我们可以用增强的 for 循环实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记 Lambda 表达式，使用 Lambda 表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码给<code>forEach()</code>方法传入一个 Lambda 表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于 3 的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用 Lambda 表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的 Lambda 表达式就行了。</p>
<h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于 3 的元素转换成大写，其余元素不变。</em></p>
<p>Java7 及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的 Lambda 表达式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于 Java7 以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在可以直接使用<code>List.sort()方法</code>，结合 Lambda 表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h4 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream()和 parallelStream()"></a>stream()和 parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。**<code>Stream</code>是 Java 函数式编程的核心类**，我们会在后面章节中学习。</p>
<h3 id="Map-中的新方法"><a href="#Map-中的新方法" class="headerlink" title="Map 中的新方法"></a>Map 中的新方法</h3><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。了解[Java7<code>HashMap</code>实现原理](<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet</a> and HashMap.md)，将有助于理解下文。</p>
<h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的 Map，请输出 Map 中的所有映射关系．</em></p>
<p>Java7 以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;=&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有 Lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟 Lambda 表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是**按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>**。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的 Map，输出 4 对应的英文单词，如果不存在则输出 NoValue</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;NoValue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">&quot;NoValue&quot;</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟 Lambda 表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8 新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做．</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在 Java7 及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8 在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的 Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7 以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用 Lambda 表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>简洁到让人难以置信．</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的使用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>

<h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>

<h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;yi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Java8 为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写 Lambda 表达式时类型推断帮我们做了一切．</li>
</ol>
<h2 id="Streams-API-I"><a href="#Streams-API-I" class="headerlink" title="Streams API(I)"></a>Streams API(I)</h2><p>你可能没意识到 Java 对函数式编程的重视程度，看看 Java 8 加入函数式编程扩充多少功能就清楚了。Java 8 之所以费这么大功夫引入函数式编程，原因有二：</p>
<ol>
<li><strong>代码简洁</strong>函数式编程写出的代码简洁且意图明确，使用<em>stream</em>接口让你从此告别<em>for</em>循环。</li>
<li><strong>多核友好</strong>，Java 函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下<code>parallel()</code>方法。</li>
</ol>
<p>这一节我们学习<em>stream</em>，也就是 Java 函数式编程的主角。对于 Java 7 来说<em>stream</em>完全是个陌生东西，<em>stream</em>并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java 容器或 I/O channel 等。正因如此要得到一个<em>stream</em>通常不会手动创建，而是调用对应的工具方法，比如：</p>
<ul>
<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>
<li>调用<code>Arrays.stream(T[] array)</code>方法</li>
</ul>
<p>常见的<em>stream</em>接口继承关系如图：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Java_stream_Interfaces.png"></p>
<p>图中 4 种<em>stream</em>接口继承自<code>BaseStream</code>，其中<code>IntStream, LongStream, DoubleStream</code>对应三种基本类型（<code>int, long, double</code>，注意不是包装类型），<code>Stream</code>对应所有剩余类型的<em>stream</em>视图。为不同数据类型设置不同<em>stream</em>接口，可以 1.提高性能，2.增加特定接口函数。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/WRONG_Java_stream_Interfaces.png"></p>
<p>你可能会奇怪为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为 Java 不允许只有返回类型不同的方法重载。</p>
<p>虽然大部分情况下<em>stream</em>是容器调用<code>Collection.stream()</code>方法得到的，但<em>stream</em>和<em>collections</em>有以下不同：</p>
<ul>
<li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java 容器或 I/O channel 等。</li>
<li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li>
<li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>对<em>stream</em>的操作分为为两类，**中间操作(*intermediate operations*)和结束操作(*terminal operations*)**，二者特点是：</p>
<ol>
<li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li>
<li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li>
</ol>
<p>如果你熟悉 Apache Spark RDD，对<em>stream</em>的这个特点应该不陌生。</p>
<p>下表汇总了<code>Stream</code>接口的部分常见方法：</p>
<table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">接口方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中间操作</td>
<td align="left">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td align="left">结束操作</td>
<td align="left">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody></table>
<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p>
<h3 id="stream-方法使用"><a href="#stream-方法使用" class="headerlink" title="stream 方法使用"></a>stream 方法使用</h3><p><em>stream</em>跟函数接口关系非常紧密，没有函数接口<em>stream</em>就无法工作。回顾一下：<strong>函数接口是指内部只有一个抽象方法的接口</strong>。通常函数接口出现的地方都可以使用 Lambda 表达式，所以不必记忆函数接口的名字。</p>
<h4 id="forEach-2"><a href="#forEach-2" class="headerlink" title="forEach()"></a>forEach()</h4><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>由于<code>forEach()</code>是结束方法，上述代码会立即执行，输出所有字符串。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.filter.png"></p>
<p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出为长度等于 3 的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.distinct.png"></p>
<p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码会输出去掉一个<code>too</code>之后的其余字符串。</p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt; sorted()</code>和<code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.map.png"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);stream.map(str -&gt; str.toUpperCase())    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>上述代码将输出原字符串的大写形式。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.flatMap.png"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都”摊平”之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));stream.flatMap(list -&gt; list.stream())    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>

<p>上述代码中，原来的<code>stream</code>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个<code>List</code>都“摊平”成了一个个的数字，所以会新产生一个由 5 个数字组成的<code>Stream</code>。所以最终将输出 1~5 这 5 个数字。</p>
<p>截止到目前我们感觉良好，已介绍<code>Stream</code>接口函数理解起来并不费劲儿。如果你就此以为函数式编程不过如此，恐怕是高兴地太早了。下一节对<code>Stream</code>规约操作的介绍将刷新你现在的认识。</p>
<h2 id="Streams-API-II"><a href="#Streams-API-II" class="headerlink" title="Streams API(II)"></a>Streams API(II)</h2><p>上一节介绍了部分<em>Stream</em>常见接口方法，理解起来并不困难，但<em>Stream</em>的用法不止于此，本节我们将仍然以<em>Stream</em>为例，介绍流的规约操作。</p>
<p>规约操作（_reduction operation_）又被称作折叠操作（_fold_），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<em>Stream</em>类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>
<p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍<code>reduce()</code>和<code>collect()</code>，这是比较有魔法的地方。</p>
<h3 id="多面手-reduce"><a href="#多面手-reduce" class="headerlink" title="多面手 reduce()"></a>多面手 reduce()</h3><p><em>reduce</em>操作可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<em>reduce</em>操作，将他们单独设为函数只是因为常用。<code>reduce()</code>的方法定义有三种重写形式：</p>
<ul>
<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></li>
<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></li>
<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>
</ul>
<p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数<em>identity</em>），或者是指定并行执行时多个部分结果的合并方式（参数<em>combiner</em>）。<code>reduce()</code>最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>
<p>需求：_从一组单词中找出最长的单词_。这里“大”的含义就是“长”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>

<p>上述代码会选出最长的单词<em>love</em>，其中<em>Optional</em>是（一个）值的容器，使用它可以避免<em>null</em>值的麻烦。当然可以使用<code>Stream.max(Comparator&lt;? super T&gt; comparator)</code>方法来达到同等效果，但<code>reduce()</code>自有其存在的理由。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.reduce_parameter.png"></p>
<p>需求：_求出一组单词的长度之和_。这是个“求和”操作，操作对象输入类型是<em>String</em>，而结果类型是<em>Integer</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求单词长度之和</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Integer lengthSum = stream.reduce(<span class="number">0</span>,　<span class="comment">// 初始值　// (1)</span></span><br><span class="line">        (sum, str) -&gt; sum+str.length(), <span class="comment">// 累加器 // (2)</span></span><br><span class="line">        (a, b) -&gt; a+b);　<span class="comment">// 部分和拼接器，并行执行时才会用到 // (3)</span></span><br><span class="line"><span class="comment">// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();</span></span><br><span class="line">System.out.println(lengthSum);</span><br></pre></td></tr></table></figure>

<p>上述代码标号(2)处将 i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用<code>reduce()</code>函数将这两步合二为一，更有助于提升性能。如果想要使用<code>map()</code>和<code>sum()</code>组合来达到上述目的，也是可以的。</p>
<p><code>reduce()</code>擅长的是生成一个值，如果想要从<em>Stream</em>生成一个集合或者<em>Map</em>等复杂的对象该怎么办呢？终极武器<code>collect()</code>横空出世！</p>
<h3 id="终极武器-collect"><a href="#终极武器-collect" class="headerlink" title="终极武器 collect()"></a>终极武器 collect()</h3><p>不夸张的讲，如果你发现某个功能在<em>Stream</em>接口中没找到，十有八九可以通过<code>collect()</code>方法实现。<code>collect()</code>是<em>Stream</em>接口方法中最灵活的一个，学会它才算真正入门 Java 函数式编程。先看几个热身的小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成容器或Map</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)</span></span><br></pre></td></tr></table></figure>

<p>上述代码分别列举了如何将<em>Stream</em>转换成<em>List</em>、<em>Set</em>和<em>Map</em>。虽然代码语义很明确，可是我们仍然会有几个疑问：</p>
<ol>
<li><code>Function.identity()</code>是干什么的？</li>
<li><code>String::length</code>是什么意思？</li>
<li><em>Collectors</em>是个什么东西？</li>
</ol>
<h3 id="接口的静态方法和默认方法"><a href="#接口的静态方法和默认方法" class="headerlink" title="接口的静态方法和默认方法"></a>接口的静态方法和默认方法</h3><p><em>Function</em>是一个接口，那么<code>Function.identity()</code>是什么意思呢？这要从两方面解释：</p>
<ol>
<li>Java 8 允许在接口中加入具体方法。接口中的具体方法有两种，<em>default</em>方法和<em>static</em>方法，<code>identity()</code>就是<em>Function</em>接口的一个静态方法。</li>
<li><code>Function.identity()</code>返回一个输出跟输入一样的 Lambda 表达式对象，等价于形如<code>t -&gt; t</code>形式的 Lambda 表达式。</li>
</ol>
<p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得<code>t -&gt; t</code>比<code>identity()</code>方法更直观。我会告诉你接口中的<em>default</em>方法是一个无奈之举，在 Java 7 及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在<em>Collection</em>接口中加入一个<code>stream()</code>抽象方法会怎样？<em>default</em>方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了<em>default</em>方法，为何不再加入<em>static</em>方法来避免专门的工具类呢！</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>诸如<code>String::length</code>的语法形式叫做方法引用（_method references_），这种语法用来替代某些特定形式 Lambda 表达式。如果 Lambda 表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代 Lambda 表达式。方法引用可以细分为四类：</p>
<table>
<thead>
<tr>
<th align="left">方法引用类别</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">引用静态方法</td>
<td align="left"><code>Integer::sum</code></td>
</tr>
<tr>
<td align="left">引用某个对象的方法</td>
<td align="left"><code>list::add</code></td>
</tr>
<tr>
<td align="left">引用某个类的方法</td>
<td align="left"><code>String::length</code></td>
</tr>
<tr>
<td align="left">引用构造方法</td>
<td align="left"><code>HashMap::new</code></td>
</tr>
</tbody></table>
<p>我们会在后面的例子中使用方法引用。</p>
<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>相信前面繁琐的内容已彻底打消了你学习 Java 函数式编程的热情，不过很遗憾，下面的内容更繁琐。但这不能怪 Stream 类库，因为要实现的功能本身很复杂。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream.collect_parameter.png"></p>
<p>收集器（_Collector_）是为<code>Stream.collect()</code>方法量身打造的工具接口（类）。考虑一下将一个<em>Stream</em>转换成一个容器（或者<em>Map</em>）需要做哪些工作？我们至少需要两样东西：</p>
<ol>
<li>目标容器是什么？是<em>ArrayList</em>还是<em>HashSet</em>，或者是个<em>TreeMap</em>。</li>
<li>新元素如何添加到容器中？是<code>List.add()</code>还是<code>Map.put()</code>。</li>
</ol>
<p>如果并行的进行规约，还需要告诉<em>collect()</em> 3. 多个部分结果如何合并成一个。</p>
<p>结合以上分析，<em>collect()<em>方法定义为<code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>，三个参数依次对应上述三条分析。不过每次调用</em>collect()<em>都要传入这三个参数太麻烦，收集器</em>Collector</em>就是对这三个参数的简单封装,所以<em>collect()<em>的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。</em>Collectors</em>工具类可通过静态方法生成各种常用的<em>Collector</em>。举例来说，如果要将<em>Stream</em>规约成<em>List</em>可以通过如下两种方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>通常情况下我们不需要手动指定<em>collect()<em>的三个参数，而是调用<code>collect(Collector&lt;? super T,A,R&gt; collector)</code>方法，并且参数中的</em>Collector</em>对象大都是直接通过<em>Collectors</em>工具类获得。实际上传入的<strong>收集器的行为决定了<code>collect()</code>的行为</strong>。</p>
<h3 id="使用-collect-生成-Collection"><a href="#使用-collect-生成-Collection" class="headerlink" title="使用 collect()生成 Collection"></a>使用 collect()生成 Collection</h3><p>前面已经提到通过<code>collect()</code>方法将<em>Stream</em>转换成容器的方法，这里再汇总一下。将<em>Stream</em>转换成<em>List</em>或<em>Set</em>是比较常见的操作，所以<em>Collectors</em>工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成List或Set</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br></pre></td></tr></table></figure>

<p>上述代码(3)处指定规约结果是<em>ArrayList</em>，而(4)处指定规约结果为<em>HashSet</em>。一切如你所愿。</p>
<h3 id="使用-collect-生成-Map"><a href="#使用-collect-生成-Map" class="headerlink" title="使用 collect()生成 Map"></a>使用 collect()生成 Map</h3><p>前面已经说过<em>Stream</em>背后依赖于某种数据源，数据源可以是数组、容器等，但不能是<em>Map</em>。反过来从<em>Stream</em>生成<em>Map</em>是可以的，但我们要想清楚<em>Map</em>的<em>key</em>和<em>value</em>分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下<code>collect()</code>的结果会是<em>Map</em>：</p>
<ol>
<li>使用<code>Collectors.toMap()</code>生成的收集器，用户需要指定如何生成<em>Map</em>的<em>key</em>和<em>value</em>。</li>
<li>使用<code>Collectors.partitioningBy()</code>生成的收集器，对元素进行二分区操作时用到。</li>
<li>使用<code>Collectors.groupingBy()</code>生成的收集器，对元素做<em>group</em>操作时用到。</li>
</ol>
<p>情况 1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，前面例子中已提到，这是和<code>Collectors.toCollection()</code>并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的<em>Map</em>。非常直观，无需多言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toMap()统计学生GPA</span></span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Function.identity(),<span class="comment">// 如何生成key</span></span><br><span class="line">                                     student -&gt; computeGPA(student)));<span class="comment">// 如何生成value</span></span><br></pre></td></tr></table></figure>

<p>情况 2：使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将<code>Stream</code>中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partition students into passing and failing</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>

<p>情况 3：使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟 SQL 中的<em>group by</em>语句类似，这里的<em>groupingBy()<em>也是按照某个属性对数据进行分组，属性相同的元素会被对应到</em>Map</em>的同一个<em>key</em>上。下列代码展示将员工按照部门进行分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group employees by department</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure>

<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在 SQL 中使用<em>group by</em>是为了协助其他查询，比如<em>1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数</em>。Java 类库设计者也考虑到了这种情况，增强版的<code>groupingBy()</code>能够满足这种需求。增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器</strong>(<em>downstream Collector</em>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下游收集器统计每个部门的人数</span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));<span class="comment">// 下游收集器</span></span><br></pre></td></tr></table></figure>

<p>上面代码的逻辑是不是越看越像 SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果<em>我们想得到每个员工的名字（字符串），而不是一个个</em>Employee<em>对象</em>，可通过如下方式做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照部门对员工分布组，并只保留员工的名字</span></span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,<span class="comment">// 下游收集器</span></span><br><span class="line">                                Collectors.toList())));<span class="comment">// 更下游的收集器</span></span><br></pre></td></tr></table></figure>

<p>如果看到这里你还没有对 Java 函数式编程失去信心，恭喜你，你已经顺利成为 Java 函数式编程大师了。</p>
<h3 id="使用-collect-做字符串-join"><a href="#使用-collect-做字符串-join" class="headerlink" title="使用 collect()做字符串 join"></a>使用 collect()做字符串 join</h3><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用<code>Collectors.joining()</code>生成的收集器，从此告别<em>for</em>循环。<code>Collectors.joining()</code>方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Collectors.joining()拼接字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining());// &quot;Iloveyou&quot;</span></span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining(&quot;,&quot;));// &quot;I,love,you&quot;</span></span><br><span class="line">String joined = stream.collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));<span class="comment">// &quot;&#123;I,love,you&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="collect-还可以做更多"><a href="#collect-还可以做更多" class="headerlink" title="collect()还可以做更多"></a>collect()还可以做更多</h3><p>除了可以使用<em>Collectors</em>工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用<code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>方法，<strong>收集任何形式你想要的信息</strong>。不过<em>Collectors</em>工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。</p>
<h2 id="Stream-Pipelines"><a href="#Stream-Pipelines" class="headerlink" title="Stream Pipelines"></a>Stream Pipelines</h2><p>前面我们已经学会如何使用 Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的 API 是如何实现的呢？比如 Pipeline 是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习 Stream 流水线的原理，这是 Stream 实现的关键所在。</p>
<p>首先回顾一下容器执行 Lambda 表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList.forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);<span class="comment">// 回调方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个<em>for</em>循环，在该<em>for</em>循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在 Java GUI 的监听器中广泛使用。Lambda 表达式的作用就是相当于一个回调方法，这很好理解。</p>
<p>Stream API 中大量使用 Lambda 表达式作为回调方法，但这并不是关键。理解 Stream 我们更关心的是另外两个问题：流水线和自动并行。使用 Stream 或许很容易写入如下形式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">        = strings.stream()</span><br><span class="line">              .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">              .mapToInt(String::length)</span><br><span class="line">              .max();</span><br></pre></td></tr></table></figure>

<p>上述代码求出以字母<em>A</em>开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（_Pipeline_）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了 Stream 的所有操作。</p>
<table>
<thead>
<tr>
<th>Stream 操作分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>中间操作(Intermediate operations)</td>
<td>无状态(Stateless)</td>
<td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>
</tr>
<tr>
<td>有状态(Stateful)</td>
<td>distinct() sorted() sorted() limit() skip()</td>
<td></td>
</tr>
<tr>
<td>结束操作(Terminal operations)</td>
<td>非短路操作</td>
<td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td>
</tr>
<tr>
<td>短路操作(short-circuiting)</td>
<td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>
<td></td>
</tr>
</tbody></table>
<p>Stream 上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(<em>Stateless</em>)和有状态的(<em>Stateful</em>)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如<em>找到第一个满足条件的元素</em>。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>
<h3 id="一种直白的实现方式"><a href="#一种直白的实现方式" class="headerlink" title="一种直白的实现方式"></a>一种直白的实现方式</h3><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_naive.png"></p>
<p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以<em>A</em>开头的字符串并放到一个列表 list1 中，之后让 list1 传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到 list2 中，最后遍历 list2 找出最大的数字作为最终结果。程序的执行流程如如所示：</p>
<p>这样做实现起来非常简单直观，但有两个明显的弊端：</p>
<ol>
<li>迭代次数多。迭代次数跟函数调用的次数相等。</li>
<li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li>
</ol>
<p>这些弊端使得效率底下，根本无法接受。如果不使用 Stream API 我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;A&quot;</span>))&#123;<span class="comment">// 1. filter(), 保留以A开头的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></span><br><span class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟 Stream API 等价的功能，但问题是 Stream 类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p>
<h3 id="Stream-流水线解决方案"><a href="#Stream-流水线解决方案" class="headerlink" title="Stream 流水线解决方案"></a>Stream 流水线解决方案</h3><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p>
<ol>
<li>用户的操作如何记录？</li>
<li>操作如何叠加？</li>
<li>叠加之后的操作如何执行？</li>
<li>执行后的结果（如果有）在哪里？</li>
</ol>
<h4 id="操作如何记录？"><a href="#操作如何记录？" class="headerlink" title="操作如何记录？"></a>操作如何记录？</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Java_stream_pipeline_classes.png"></p>
<p>注意这里使用的是“_操作(operation)_”一词，指的是“Stream 中间操作”的操作，很多 Stream 操作会需要一个回调函数（Lambda 表达式），因此一个完整的操作是&lt;_数据来源，操作，回调函数_&gt;构成的三元组。Stream 中使用 Stage 的概念来描述一个完整的操作，并用某种实例化后的<em>PipelineHelper</em>来代表 Stage，将具有先后顺序的各个 Stage 连到一起，就构成了整个流水线。跟 Stream 相关类和接口的继承关系图示。</p>
<p>还有<em>IntPipeline, LongPipeline, DoublePipeline</em>没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟<em>ReferencePipeline</em>是并列关系。图中<em>Head</em>用于表示第一个 Stage，即调用调用诸如<em>Collection.stream()<em>方法产生的 Stage，很显然这个 Stage 里不包含任何操作；</em>StatelessOp</em>和<em>StatefulOp</em>分别表示无状态和有状态的 Stage，对应于无状态和有状态的中间操作。</p>
<p>Stream 流水线组织结构示意图如下：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_example.png"></p>
<p>图中通过<code>Collection.stream()</code>方法得到<em>Head</em>也就是 stage0，紧接着调用一系列的中间操作，不断产生新的 Stream。<strong>这些 Stream 对象以双向链表的形式组织在一起，构成整个流水线，由于每个 Stage 都记录了前一个 Stage 和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作</strong>。这就是 Stream 记录操作的方式。</p>
<h4 id="操作如何叠加？"><a href="#操作如何叠加？" class="headerlink" title="操作如何叠加？"></a>操作如何叠加？</h4><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的 head 开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的 Stage 并不知道后面 Stage 到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前 Stage 本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻 Stage 之间的调用关系。</p>
<p>这种协议由<em>Sink</em>接口完成，<em>Sink</em>接口包含的方法如下表所示：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void begin(long size)</td>
<td>开始遍历元素之前调用该方法，通知 Sink 做好准备。</td>
</tr>
<tr>
<td>void end()</td>
<td>所有元素遍历完成之后调用，通知 Sink 没有更多的元素了。</td>
</tr>
<tr>
<td>boolean cancellationRequested()</td>
<td>是否可以结束操作，可以让短路操作尽早结束。</td>
</tr>
<tr>
<td>void accept(T t)</td>
<td>遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage 把自己包含的操作和回调方法封装到该方法里，前一个 Stage 只需要调用当前 Stage.accept(T t)方法就行了。</td>
</tr>
</tbody></table>
<p>有了上面的协议，相邻 Stage 之间调用就很方便了，每个 Stage 都会将自己的操作封装到一个 Sink 里，前一个 Stage 只需调用后一个 Stage 的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink 的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如 Stream.sorted()是一个有状态的中间操作，其对应的 Sink.begin()方法可能创建一个盛放结果的容器，而 accept()方法负责将元素添加到该容器，最后 end()负责对容器进行排序。对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如 Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回<em>true</em>，以便调用者尽快结束查找。Sink 的四个接口方法常常相互协作，共同完成计算任务。<strong>实际上 Stream API 内部实现的的本质，就是如何重载 Sink 的这四个接口方法</strong>。</p>
<p>有了 Sink 对操作的包装，Stage 之间的调用问题就解决了，执行时只需要从流水线的 head 开始对数据源依次调用每个 Stage 对应的 Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的 Sink.accept()方法流程是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span> 使用当前Sink包装的回调函数处理u</span><br><span class="line">    <span class="number">2.</span> 将处理结果传递给流水线下游的Sink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sink 接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看 Stream 的中间操作是如何将自身的操作包装成 Sink 以及 Sink 是如何将处理结果转发给下一个 Sink 的。先看 Stream.map()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    R r = mapper.apply(u);<span class="comment">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class="line">                    downstream.accept(r);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<em>mapper</em>包装到一个 Sink 当中。由于 Stream.map()是一个无状态的中间操作，所以 map()方法返回了一个 StatelessOp 内部类对象（一个新的 Stream），调用这个新 Stream 的 opWripSink()方法将得到一个包装了当前回调函数的 Sink。</p>
<p>再来看一个复杂一点的例子。Stream.sorted()方法将对 Stream 中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成 Sink 的呢？sorted()一种可能封装的 Sink 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.sort()方法用到的Sink实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;<span class="comment">// 存放用于排序的元素</span></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(downstream, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建一个存放排序元素的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.sort(comparator);<span class="comment">// 只有元素全部接收之后才能开始排序</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;<span class="comment">// 下游Sink不包含短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 下游Sink包含短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;<span class="comment">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);<span class="comment">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码完美的展现了 Sink 的四个接口方法是如何协同工作的：</p>
<ol>
<li>首先 beging()方法告诉 Sink 参与排序的元素个数，方便确定中间结果容器的的大小；</li>
<li>之后通过 accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li>
<li>最后 end()方法告诉 Sink 所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的 Sink；</li>
<li>如果下游的 Sink 是短路操作，将结果传递给下游时不断询问下游 cancellationRequested()是否可以结束处理。</li>
</ol>
<h4 id="叠加之后的操作如何执行？"><a href="#叠加之后的操作如何执行？" class="headerlink" title="叠加之后的操作如何执行？"></a>叠加之后的操作如何执行？</h4><p><img src="https://gitee.com/Feyl/picgo/raw/master/img/Stream_pipeline_Sink.png"></p>
<p>Sink 完美封装了 Stream 每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</p>
<p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的 Sink，这也是流水线中最后一个 Sink，这个 Sink 只需要处理数据而不需要将结果传递给下游的 Sink（因为没有下游）。对于 Sink 的[处理-&gt;转发]模型，结束操作的 Sink 就是调用链的出口。</p>
<p>我们再来考察一下上游的 Sink 是如何找到下游 Sink 的。一种可选的方案是在<em>PipelineHelper</em>中设置一个 Sink 字段，在流水线中找到下游 Stage 并访问 Sink 字段即可。但 Stream 类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到 Sink，该方法的作用是返回一个新的包含了当前 Stage 代表的操作以及能够将结果传递给 downstream 的 Sink 对象。为什么要产生一个新对象而不是返回一个 Sink 字段？这是因为使用 opWrapSink()可以将当前操作与下游 Sink（上文中的 downstream 参数）结合成新 Sink。试想只要从流水线的最后一个 Stage 开始，不断调用上一个 Stage 的 opWrapSink()方法直到最开始（不包括 stage0，因为 stage0 代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的 Sink，用代码表示就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.wrapSink()</span></span><br><span class="line"><span class="comment">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class="line"><span class="comment">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在流水线上从开始到结束的所有的操作都被包装到了一个 Sink 里，执行这个 Sink 就相当于执行整个流水线，执行 Sink 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class="comment">// 通知开始遍历</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);<span class="comment">// 迭代</span></span><br><span class="line">        wrappedSink.end();<span class="comment">// 通知遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先调用 wrappedSink.begin()方法告诉 Sink 数据即将到来，然后调用 spliterator.forEachRemaining()方法对数据进行迭代（Spliterator 是容器的一种迭代器，[参阅](<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda</a> and Collections.md#spliterator)），最后调用 wrappedSink.end()方法通知 Sink 数据处理结束。逻辑如此清晰。</p>
<h4 id="执行后的结果在哪里？"><a href="#执行后的结果在哪里？" class="headerlink" title="执行后的结果在哪里？"></a>执行后的结果在哪里？</h4><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的 Stream 结束操作都需要返回结果，有些操作只是为了使用其副作用(<em>Side-effects</em>)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p>
<blockquote>
<p>特别说明：副作用不应该被滥用，也许你会觉得在 Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为 Stream 可能会并行执行。大多数使用副作用的地方都可以使用<strong>归约操作</strong>更安全和有效的完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的收集方式</span></span><br><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"><span class="comment">// 正确的收集方式</span></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">             .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure>

<p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的 Stream 结束操作。</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>对应的结束操作</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>anyMatch() allMatch() noneMatch()</td>
</tr>
<tr>
<td>Optional</td>
<td>findFirst() findAny()</td>
</tr>
<tr>
<td>归约结果</td>
<td>reduce() collect()</td>
</tr>
<tr>
<td>数组</td>
<td>toArray()</td>
</tr>
</tbody></table>
<ol>
<li>对于表中返回 boolean 或者 Optional 的操作（Optional 是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 Sink 中记录这个值，等到执行结束时返回就可以了。</li>
<li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过<strong>收集器</strong>指定）。collect(), reduce(), max(), min()都是归约操作，虽然 max()和 min()也是返回一个 Optional，但事实上底层是通过调用<code>reduce()</code>方法实现的。</li>
<li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做<em>Node</em>的数据结构中的。Node 是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于 Node 的具体结构，我们会在下一节探究 Stream 如何并行执行时给出详细说明。</li>
</ol>
<p>本文详细介绍了 Stream 流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的 Stream 代码，同时打消你对 Stream API 效率方面的顾虑。如你所见，Stream API 实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。</p>
<p>注：留下本文所用的 JDK 版本，以便有考究癖的人考证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_101&quot;</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_101</span>-b13)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> Server <span class="title">VM</span> <span class="params">(build <span class="number">25.101</span>-b13, mixed mode)</span></span></span><br></pre></td></tr></table></figure>

<p>文章来源：<a href="https://github.com/CarpenterLee/JavaLambdaInternals">https://github.com/CarpenterLee/JavaLambdaInternals</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO</title>
    <url>/post/57ec66b6/</url>
    <content><![CDATA[<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用<strong>虚拟存储器</strong>，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<blockquote>
<p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
</blockquote>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127193145761.png" style="zoom:67%;" />

<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<blockquote>
<p>进程切换需要消耗一定的资源。</p>
</blockquote>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行<strong>阻塞原语(Block)<strong>，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个<strong>用于表述指向文件的引用的抽象化概念</strong>。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>更多内容详见：<a href="https://feyl.github.io/post/1e8930fb/">理解linux中的file descriptor(文件描述符)</a></p>
<h3 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h3><p>缓存 IO 又被称作<strong>标准 IO</strong>，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，<strong>操作系统会将 IO 的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p><strong>缓存 IO 的缺点：</strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 中文翻译为套接字，是计算机网络中进程间进行<strong>双向通信的端点的抽象</strong>。一个 Socket 代表了网络通信的一端，是由操作系统提供的进程间通信机制。</p>
<ul>
<li>在操作系统中，通常会为应用程序提供一组应用程序接口，称为 Socket 接口（Socket API）。应用程序可以通过 Socket 接口，来使用网络 Socket，以进行数据的传输。</li>
<li>一个 Socket 由IP地址和端口组成，即：Socket 地址 = IP地址 : 端口号。</li>
<li>在同一台计算机上，TCP 协议与 UDP 协议可以同时使用相同的端口（Port），而互不干扰。</li>
<li>要想实现网络通信，至少需要一对 Socket，其中一个运行在客户端，称之为 Client Socket；另一个运行在服务器端，称之为 Server Socket。</li>
<li>Socket 之间的连接过程可以分为三个步骤：（1）服务器监听；（2）客户端连接；（3）连接确认。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127181515932.png" style="zoom:80%;" />

<h4 id="Socket-缓冲区"><a href="#Socket-缓冲区" class="headerlink" title="Socket 缓冲区"></a>Socket 缓冲区</h4><p>每个 Socket 被创建后，都会在内核中分配两个缓冲区：输入缓冲区和输出缓冲区。</p>
<ul>
<li>通过 Socket 发送数据并不会立即向网络中传输数据，而是先将数据写入到输出缓冲区中，再由 TCP 协议将数据从输出缓冲区发送到目标主机。</li>
<li>通过 Socket 接收数据也是如此，也是从输入缓冲区中读取数据，而不是直接从网络中读取。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127181657439.png" style="zoom:80%;" />





<h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><p>操作系统的内核是操作系统的核心部分。 它负责<strong>系统的内存，硬件设备，文件系统以及应用程序的管理</strong>。</p>
<h3 id="操作系统的用户态与内核态"><a href="#操作系统的用户态与内核态" class="headerlink" title="操作系统的用户态与内核态"></a>操作系统的用户态与内核态</h3><p>unix与linux的体系架构：分为用户态与内核态。 用户态与内核态与内核态是操作系统对<strong>执行权限进行分级</strong>后的不同的<strong>运行模式</strong>。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126105736357.png"></p>
<h3 id="为什么要有用户态与内核态？"><a href="#为什么要有用户态与内核态？" class="headerlink" title="为什么要有用户态与内核态？"></a>为什么要有用户态与内核态？</h3><p>在cpu的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。 为了避免这种情况发生，cpu将指令划分为<strong>特权级（内核态）指令</strong>和<strong>非特权级（用户态）指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态（核心态，特权态）：<strong>内核态是操作系统内核运行的模式。</strong> 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态：<strong>用户态是用户应用程序运行的状态。</strong>应用程序必须依托于内核态运行，因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用：系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h3 id="用户态切换到内核态的几种方式"><a href="#用户态切换到内核态的几种方式" class="headerlink" title="用户态切换到内核态的几种方式"></a>用户态切换到内核态的几种方式</h3><ul>
<li>系统调用：系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li>异常：当cpu在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li>硬件设备的中断：当硬件设备完成用户请求后，会向cpu发出相应的中断信号， 这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。</li>
</ul>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>首先来解释同步和异步的概念，这两个概念与消息的通知机制有关。也就是同步与异步主要是从<strong>消息通知机制</strong>角度来说的。</p>
<h4 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h4><p><strong>同步</strong>就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，如果方法没有计算完，就不返回。</p>
</blockquote>
<p><strong>异步</strong>是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，但是由于方法没有返回结果，所以就需要被调用的这个方法来通知调用线程 1 - 100的结果，或者线程在调用方法的时候指定一个回调函数来告诉被调用的方法执行完后就执行回调函数。</p>
</blockquote>
<h4 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h4><p>异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>这里提到执行部件和调用者通过三种途径返回结果：<strong>状态、通知和回调</strong>。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。</p>
<ol>
<li>如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）；</li>
<li>如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</li>
</ol>
<h4 id="场景比喻"><a href="#场景比喻" class="headerlink" title="场景比喻"></a>场景比喻</h4><p>举个例子，比如我去银行办理业务，可能会有两种方式：</p>
<ol>
<li>选择排队等候；</li>
<li>另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</li>
</ol>
<p>第一种：前者（排队等候）就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</p>
<p>第二种：后者（等待别人通知）就是异步等待消息通知。在异步消息处理中，等待消息通知者（在这个例子中就是等待办理业务的人）往往注册一个回调机制，在所等待的事件被触发时由触发机制（在这里是柜台的人）通过某种机制（在这里是写在小纸条上的号码，喊号）找到等待该事件的人。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞这两个概念与程序（线程）<strong>等待消息通知（无所谓同步或者异步）时的状态</strong>有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<h4 id="概念描述-1"><a href="#概念描述-1" class="headerlink" title="概念描述"></a>概念描述</h4><p>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100 的和，如果该方法没有返回结果， 那么调用方法的线程就一直等待直到该方法执行完毕。</p>
</blockquote>
<p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p>
<p>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：</p>
<ol>
<li>如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做<strong>同步非阻塞</strong>；</li>
<li>如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做<strong>同步阻塞</strong>；</li>
</ol>
<p><strong>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞；</strong></p>
<p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回；</p>
<p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<blockquote>
<p>例如：一个线程调用一个方法计算 1 - 100的和，该方法立刻返回，如果方法有返回结果，调用者线程也无需一直等待该方法的结果，可以执行其他任务，但是在方法返回结果之前，<strong>线程仍然需要轮询的检查方法是否已经有结果。</strong></p>
</blockquote>
<p>虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</p>
<h4 id="场景比喻-1"><a href="#场景比喻-1" class="headerlink" title="场景比喻"></a>场景比喻</h4><p>继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p>
<p>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他（等待者）没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p>
<p>但是需要注意了，<strong>同步非阻塞形式实际上是效率低下的</strong>，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<strong>异步非阻塞形式却没有这样的问题</strong>，因为打电话是你（等待者）的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。</p>
<p><strong>结论：同步和异步、阻塞与非阻塞针均是对调用者的立场而言的。</strong></p>
<h3 id="同步-异步与阻塞-非阻塞"><a href="#同步-异步与阻塞-非阻塞" class="headerlink" title="同步/异步与阻塞/非阻塞"></a>同步/异步与阻塞/非阻塞</h3><ol>
<li><p><strong>同步阻塞形式</strong></p>
<p><strong>效率是最低的</strong>，拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
<p><strong>实际程序中：</strong>就是未对fd 设置O_NONBLOCK标志位的read/write 操作；</p>
</li>
<li><p><strong>异步阻塞形式</strong></p>
<p>如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p><strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p>
<p>比如<strong>select 函数</strong>，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处。</p>
</li>
<li><p><strong>同步非阻塞形式</strong></p>
<p>实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
<p>很多人会写<strong>阻塞的read/write 操作</strong>，但是别忘了可以<strong>对fd设置O_NONBLOCK 标志位</strong>，这样就可以将同步操作变成非阻塞的了。</p>
</li>
<li><p><strong>异步非阻塞形式</strong></p>
<p>效率更高，因为打电话是你（等待者）的事情，而通知你则是柜台（消息触发机制）的事情，<strong>程序没有在两种不同的操作中来回切换</strong>。</p>
<p>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下（注册一个回调函数），那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步非阻塞的方式了。</p>
<p>如果使用异步非阻塞的情况，比如<code>aio_*</code>组的操作，当发起一个<code>aio_read</code>操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</p>
<p>很多人会把同步和阻塞混淆，我想是因为<strong>很多时候同步操作会以阻塞的形式表现出来</strong>，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置<code>O_NONBLOCK</code>标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。</p>
<p>同样的，很多人也会把异步和非阻塞混淆，因为<strong>异步操作一般都不会在真正的IO操作处被阻塞</strong>，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p>
</li>
</ol>
<h4 id="小明的故事"><a href="#小明的故事" class="headerlink" title="小明的故事"></a>小明的故事</h4><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说明，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态</strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能够更好的促进大家的理解。</p>
<ol>
<li><strong>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；<br>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；<br>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</p>
</blockquote>
<ol>
<li><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；<br>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；<br>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>
</blockquote>
<p>也就是说，<strong>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p>
<p>所以，综上所述，<strong>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态</strong>。也就是说，<strong>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者</strong>，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁：</p>
<blockquote>
<p>在银行的例子中，这个桥梁就是小纸条上面的号码。<br>在小明的例子中，这个桥梁就是软件“叮”的声音。</p>
</blockquote>
<p><strong>最后，请大家注意理解“消息通知机制”和“等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</strong></p>
<h2 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h2><p>网络IO的本质是socket的读取，<strong>socket在linux系统被抽象为流</strong>，IO可以理解为对流的操作。刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>第一阶段：等待数据准备 (Waiting for the data to be ready)。</p>
<p>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</p>
<p>对于socket流而言：</p>
<p>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</p>
<p>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</p>
<blockquote>
<p>网络应用需要处理的无非就是两大类问题，<strong>网络IO</strong>，<strong>数据计算</strong>。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。</p>
</blockquote>
<h3 id="一次I-O操作经历了什么"><a href="#一次I-O操作经历了什么" class="headerlink" title="一次I/O操作经历了什么"></a>一次I/O操作经历了什么</h3><p>在正式开始之前，先对I/O流程有一个感性的认识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">//fd已经在构造FileInputStream创建</span></span><br><span class="line">  FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/file1.txt&quot;</span>); </span><br><span class="line">  FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/file2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">  in.read(buf);</span><br><span class="line">  out.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是Java中典型的BIO，读取一个文件的内容，输出到另一个文件中。那么这个过程会发生那些事呢？</p>
<p>一次IO的读操作分为等待就绪和IO操作两个阶段，<strong>等待就绪</strong>就是等待TCP RecvBuffer里面的数据就绪好，也就是发送方的数据全部发送到网卡里面来，<strong>IO操作</strong>就是CPU将数据从网卡拷贝到用户空间。请看下图</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126195327555.png" style="zoom: 67%;" />

<p>发生了什么呢？</p>
<ul>
<li><code>in.read(buf)</code>执行时，JVM向kernel发起system call <code>read()</code></li>
<li>操作系统发生上下文切换，由用户态(User mode)切换到内核态(Kernel mode)，把数据读取到Kernel space buffer</li>
<li>Kernel把数据从Kernel space复制到User space，同时由内核态转为用户态。</li>
<li>JVM继续执行<code>out.write(buf)</code>这行代码</li>
<li>再次发生上下文切换，把数据复制到Kernel space buffer中。kernel把数据写入文件。</li>
</ul>
<p>从上面可以看出一个I/O操作，<strong>通常</strong>而言会发生下面的事</p>
<ol>
<li>两次上下文切换(User mode 和 Kernel mode之间转换)</li>
<li>数据在Kernel space 和 User space之间复制</li>
</ol>
<h3 id="I-O模型种类"><a href="#I-O模型种类" class="headerlink" title="I/O模型种类"></a>I/O模型种类</h3><p>Linux下共有5种IO模型：</p>
<ol>
<li>阻塞IO（Blocking I/O）</li>
<li>非阻塞IO（Non-Blocking I/O）</li>
<li>IO多路复用（I/O Multiplexing (<code>select</code> 、<code>poll</code>、 <code>epoll</code>)）</li>
<li>信号驱动IO（Signal driven I/O (<code>SIGIO</code>)）</li>
<li>异步IO（Asynchronous I/O）</li>
</ol>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞IO是很常见的一种IO模型。 在这种模型中，<strong>用户态的应用程序会执行一个操作系统的调用， 检查内核的数据是否准备好。如果内核的数据已经准备好， 就把数据复制到用户应用进程。如果内核没有准备好数据， 那么用户应用进程（线程）就阻塞，直到内核准备好数据并把数据从 内核复制到用户应用进程，</strong> 最后应用程序再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126115842261.png"></p>
<p><strong>流程描述：</strong></p>
<p>当用户进程调用了<code>recv()/recvfrom()</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>Process –&gt; system call –&gt; kernel –&gt; hardware(hard disk)</p>
<p>上图是blocking I/O发起system call <code>recvfrom()</code>时，进程将一直阻塞等待另一端Socket的数据到来。在这种I/O模型下，我们不得不为每一个Socket都分配一个线程，这会造成很大的资源浪费。</p>
</blockquote>
<p><strong>阻塞IO是同步阻塞的：</strong></p>
<ol>
<li>阻塞IO的同步体现在：<strong>内核只有准备好数据并把数据复制到用户应用进程才会返回。</strong></li>
<li>阻塞IO的阻塞体现在：<strong>用户应用进程等待内核准备数据和把数据从用户态拷贝到内核态的这整个过程，用户应用进程都必须一直等待。</strong> 当然，如果是本地磁盘IO，内核准备数据的时间可能会很短。 但网络IO就不一样了，因为服务端不知道客户端何时发送数据，内核就仍需要等待socket数据，时间就可能会很长。</li>
</ol>
<p><strong>优缺点：</strong></p>
<p><strong>阻塞IO的优点是对于数据是能够保证无延时的，因为应用程序进程会一直阻塞直到IO完成。</strong> 但应用程序的阻塞就意味着应用程序进程无法执行其他任务， 这会大大降低程序性能。一个不太可行的办法是为每个客户端 socket 都分配一个线程， 这样就会提升server处理请求的能力。不过操作系统的线程资源是有限的， 如果请求过多，可能造成线程资源耗尽，系统卡死等后果。</p>
<h3 id="非阻塞IO（网络IO模型）"><a href="#非阻塞IO（网络IO模型）" class="headerlink" title="非阻塞IO（网络IO模型）"></a>非阻塞IO（网络IO模型）</h3><p>在非阻塞IO模型中，用户态的应用程序也会执行一个操作系统的调用， 检查内核的数据是否准备完成。<strong>如果内核没有准备好数据, 内核会立刻返回结果，用户应用进程不用一直阻塞等待内核准备数据， 而是可以执行其他任务，但仍需要不断的向内核发起系统调用，检测数据是否准备好， 这个过程就叫轮询。</strong>轮询直到内核准备好数据，然后内核把数据拷贝到用户应用进程， 再进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p>
<p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ’被‘ CPU光顾”。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126120717900.png"></p>
<p><strong>流程描述：</strong></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<p>同样发起system call <code>recvfrom</code>，凭什么在blocking I/O会阻塞，而在这里kernel的数据还没就绪就直接返回<code>EWOULDBLOCK</code>呢？我们看看<code>recvfrom</code>函数定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里能看到<code>recvfrom</code>有个参数叫flags，默认情况下阻塞。可以设置flag为非阻塞让kernel在数据未就绪时直接返回。详细见<a href="https://linux.die.net/man/2/recvfrom">recvfrom</a>。</p>
<p>非阻塞IO的非阻塞体现在：<strong>用户应用进程发起I/O操作时，不会因为数据还没就绪而阻塞（即不用阻塞在对内核的系统调用上）</strong></p>
<p><strong>优缺点：</strong></p>
<p>非阻塞IO的优点在于用户应用进程在轮询阶段可以执行其它任务。 但这也是它的缺点，轮询就代表着用户应用进程不是时刻都会发起系统调用。 <strong>可能数据准备好了，而用户应用进程可能等待其它任务执行完毕才会发起系统调用， 这就意味着数据可能会被延时获取，导致整体数据吞吐量的降低。</strong></p>
<h3 id="IO多路复用（网络IO模型）"><a href="#IO多路复用（网络IO模型）" class="headerlink" title="IO多路复用（网络IO模型）"></a>IO多路复用（网络IO模型）</h3><p>由于同步非阻塞方式需要<strong>不断主动轮询</strong>，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果<strong>轮询不是进程的用户态</strong>，而是有人帮忙就好了。这就是所谓的 “<strong>IO 多路复用</strong>”。</p>
<p>上面介绍的I/O模型都是<strong>直接发起I/O操作</strong>，而I/O Multiplexing首先向kernel发起system call，传入file descriptor和感兴趣的事件（readable、writable等）<strong>让kernel监测</strong>，当其中一个或多个fd数据就绪，就会返回结果。程序再发起真正的I/O操作<code>recvfrom</code>读取数据。</p>
<p>在linux中，有3种system call可以让内核监测file descriptors，分别是select、poll、epoll。</p>
<p>select调用是<strong>内核级别</strong>的，select轮询相对非阻塞的轮询的区别在于前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行<code>recvform</code>系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的<strong>select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理</strong>。如何知道有一部分数据到达了呢？监视的事情交给了内核，<strong>内核负责数据到达的处理</strong>。也可以理解为”非阻塞”吧。</p>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻<strong>塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</strong>。而且可以<strong>同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时</strong>（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>
<p>对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，<strong>多个IO之间的顺序变得不确定了</strong>，当然也可以针对不同的编号。</p>
<p>在IO多路复用模型中，<strong>用户应用进程会调用操作系统的select/poll/epoll函数，它会使内核同步的轮询指定的socket（在NIO中，socket就是注册到Selector上的SocketChannel，可以允许多个）直至监听的socket有数据可读或可写，select/poll/epoll函数才会返回，用户应用进程也会阻塞的等待 select/poll/epoll函数返回。</strong> 当 select/poll/epoll函数返回后，即某个socket有事件发生了，用户应用进程就会发起系统调用，处理事件，将socket数据复制到用户进程内，然后进行数据处理。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126122722800.png"></p>
<blockquote>
<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call（select 和 recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，<strong>用select的优势在于它可以同时处理多个connection</strong>。</p>
</blockquote>
<p><strong>流程描述：</strong></p>
<p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。<strong>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的process其实是一直被block的。只不过<strong>process是被select这个函数block，而不是被socket IO给block</strong>。所以<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong></p>
<p><strong>IO多路复用模型是同步阻塞的：</strong></p>
<ol>
<li>IO多路复用模型的同步体现在：<strong>select函数只有监听到某个socket有事件才会返回</strong>。</li>
<li>IO多路复用模型的阻塞体现在：<strong>用户应用进程会阻塞在对select函数上的调用上</strong>。</li>
</ol>
<blockquote>
<p>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，<strong>用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞</strong>。所以，把IO多路复用归为同步阻塞模式。</p>
</blockquote>
<p><strong>IO多路复用的优点在于内核可以处理多个socket， 相当于一个用户进程（线程）就可以处理多个socket连接。</strong> 这样不仅降低了系统的开销，并且对于需要高并发的应用是非常有利的。 而非阻塞IO和阻塞IO的一个用户应用进程只能处理一个socket， 要想处理多socket，只能新开进程或线程，但这样很消耗系统资源。</p>
<p><strong>PS：在IO多路复用模型中, socket一般应该为非阻塞的， 这就是Java中NIO被称为非阻塞IO的原因。 但实际上NIO属于IO多路复用，它是同步阻塞的IO。 具体原因见 <a href="https://www.zhihu.com/question/37271342">知乎讨论</a></strong></p>
<p>目前支持I/O多路复用的系统调用有 <code>select</code>，<code>pselect</code>，<code>poll</code>，<code>epoll</code>，I/O多路复用就是<strong>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。但<code>select</code>，<code>pselect</code>，<code>poll</code>，<code>epoll</code>本质上都是<strong>同步I/O</strong>，因为他们都需要在<strong>读写事件就绪后自己负责进行读写</strong>，也就是说这个<strong>读写过程是阻塞的</strong>，而<strong>异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</strong>。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><strong>基本原理：</strong></p>
<p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p><strong>函数定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">  fd_set *exceptfds, struct timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select函数可以传入3个fd_set，分别对应了不同事件的file descriptor。返回值是一个int值，代表了就绪的fd数量，这个数量是3个fd_set就绪fd数量总和。</p>
<p>当程序发起system call select时流程如下</p>
<ol>
<li>程序阻塞等待kernel返回</li>
<li>kernel发现有fd就绪，返回数量</li>
<li>程序轮询3个fd_set寻找就绪的fd</li>
<li>发起真正的I/O操作(read、recvfrom等)</li>
</ol>
<p><strong>优点:</strong></p>
<ol>
<li>select目前几乎在所有的平台上支持（良好跨平台支持）</li>
<li>一次让kernel监测多个fd</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li><p>最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<blockquote>
<p>一般来说这个数目和系统内存关系很大，具体数目可以<code>cat/proc/sys/fs/file-max</code>察看。32位机默认是1024个。64位机默认是2048。</p>
</blockquote>
</li>
<li><p>kernel返回后，对socket进行扫描时是线性扫描，需要轮询所有fd找出就绪的fd，随着fd数量增加，性能会逐渐下降</p>
<blockquote>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<strong>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</strong>，这正是epoll与kqueue做的。</p>
</blockquote>
</li>
<li><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>
</li>
</ol>
<p>更多的介绍请点击<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec3.html">select函数</a>查看。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>基本原理：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>函数定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pollfd结构体如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">  <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数fds是一个结构体数组（基于链表来存储），因此poll<strong>不受限FD_SETSIZE的值</strong>（没有最大连接数的限制）。</p>
<p>缺点：</p>
<ol>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
<li>只有linux支持poll。</li>
</ol>
<p><strong>注意：</strong></p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>select和poll都是等待内核返回后轮询集合寻找就绪的fd，有没有一种机制，当某个fd就绪，kernel直接返回就绪的fd呢？这就是epoll。</p>
<p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，<strong>没有描述符限制</strong>。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个<strong>事件表</strong>中，这样在用户空间和内核空间的copy只需一次。</p>
<p><strong>基本原理：</strong></p>
<p>epoll支持<strong>水平触发</strong>和<strong>边缘触发</strong>，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<blockquote>
<p>epoll是一种<strong>I/O事件通知机制</strong>，linux kernel 2.5.44开始提供这个功能，用于取代select和poll。</p>
</blockquote>
<p>epoll内部结构用<strong>红黑树</strong>实现，用于监听程序注册的fd。和epoll相关的函数共有3个，分别如下</p>
<ul>
<li><code>epoll_create1</code>：创建一个epoll实例并返回它的fd</li>
<li><code>epoll_ctl</code>：操作epoll实例，可往里面新增、删除fd</li>
<li><code>epoll_wait</code>：等待epoll实例中有fd就绪，且返回就绪的fd</li>
</ul>
<h5 id="epoll-create1"><a href="#epoll-create1" class="headerlink" title="epoll_create1"></a>epoll_create1</h5><p>创建一个epoll实例并返回它的file descriptor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>        *ptr;</span><br><span class="line">  <span class="keyword">int</span>          fd;</span><br><span class="line">  <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">  <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>epoll_ctl</code>用来操作epoll实例监听的fd，可以往epoll实例中新增、删除。参数解释如下：</p>
<ul>
<li><code>epdf</code>：即<code>epoll_create1</code>返回的fd</li>
<li>op是operation的缩写，可为EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL</li>
<li>fd即要监控的fd</li>
<li>event即要注册的事件集合（可读、可写之类的）</li>
</ul>
<h5 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用epoll_wait函数会阻塞，直到epoll实例监控的fd中有一个或多个fd就绪，或timeout。就绪的fd会被kernel添加到events数组中。</p>
<ul>
<li><code>epfd</code>：即<code>epoll_create1</code>返回的fd</li>
<li><code>events</code>：<code>events</code>数组，就绪的fd将会放在这里</li>
<li>最大的事件数量</li>
<li>超时时间</li>
</ul>
<p>epoll是一种性能很高的同步I/O方案。现在linux中的高性能网络框架（tomcat、netty等）都有epoll的实现。缺点是只有linux支持epoll，BSD内核的kqueue类似于epoll。</p>
<p>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p><strong>注意：</strong></p>
<p>如果没有大量的<code>idle-connection</code>或者<code>dead-connection</code>，epoll的效率并不会比select/poll高很多，但是当遇到大量的<code>idle-connection</code>，就会发现epoll的效率大大高于select/poll。</p>
<h4 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h4><table>
<thead>
<tr>
<th>函数</th>
<th>支持一个进程所能打开的最大连接数</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>单个进程所能打开的最大连接数有 FD_ SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32* 32，同理64位机器上 FD_ SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td>
</tr>
<tr>
<td>poll</td>
<td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>FD剧增后带来的IO效率问题</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th><strong>消息传递方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody></table>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p>
<ol>
<li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li>
</ol>
<p><strong>epoll的优点：</strong></p>
<ol>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递；即epoll使用<code>mmap</code>减少复制开销。</li>
</ol>
<p><strong>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p>
<ul>
<li>LT模式（水平触发）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式（边缘触发）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到 <code>EAGAIN</code> 错误。</li>
</ul>
<p><strong>LT模式</strong></p>
<p>LT（level triggered）是<strong>缺省工作方式</strong>，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p><strong>ET模式</strong></p>
<p>ET（edge-triggered）是<strong>高速工作方式</strong>，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="多路复用的适用场景"><a href="#多路复用的适用场景" class="headerlink" title="多路复用的适用场景"></a>多路复用的适用场景</h4><p>在I/O编程过程中，<strong>当需要同时处理多个客户端接入请求时</strong>，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是<strong>系统开销小</strong>，系统<strong>不需要创建新的额外进程或者线程</strong>，也<strong>不需要维护</strong>这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p>
<ul>
<li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>
</li>
<li><p>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p>
</li>
<li><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>
<blockquote>
<p>一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>
</blockquote>
</li>
<li><p>服务器需要同时处理多种网络协议的套接字。</p>
<blockquote>
<p>例如：一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>
</blockquote>
</li>
<li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>
</li>
</ul>
<p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong>他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询</strong>，两个阶段过程：</p>
<blockquote>
<p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p>
<p>第二个阶段都是阻塞的。</p>
</blockquote>
<p><strong>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。</strong></p>
<p><strong>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式</strong>。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种<strong>高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</strong></p>
<h3 id="信号驱动IO（网络IO模型）"><a href="#信号驱动IO（网络IO模型）" class="headerlink" title="信号驱动IO（网络IO模型）"></a>信号驱动IO（网络IO模型）</h3><p>在信号驱动IO模型中，<strong>用户应用进程发起sigaction系统调用，内核收到并立即返回。 用户应用进程可以继续执行其他任务，不会阻塞。当内核准备好数据后向用户应用进程 发送SIGIO信号，应用进程收到信号后，发起系统调用，将数据从内核拷贝到用户进程，</strong> 然后进行数据处理。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126174228791.png"></p>
<p>个人感觉在内核收到系统调用就立刻返回这一点很像异步IO的方式了，不过与异步IO仍有很大差别。</p>
<p>Singal-Driven I/O模型有点复杂，且存在一些限制。有兴趣请点击<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch25lev1sec2.html#ch25lev1sec2">Signal-Driven I/O for Sockets</a>查看。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>在异步IO模型中，<strong>用户进程发起aio_read系统调用，无论内核的数据是否准备好，都会立即返回。用户应用进程不会阻塞，可以继续执行其他任务。当内核准备好socket数据，会直接把数据复制到用户应用进程。最后内核会通知用户应用进程IO完成。IO两个阶段，进程都是非阻塞的</strong></p>
<blockquote>
<p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。</p>
</blockquote>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126174546502.png"></p>
<blockquote>
<p>请留意图片细节，程序不需要再次发起读取数据的system call，因为kernel会把数据复制到user space再通知进程处理，整个过程不存在任何阻塞。</p>
</blockquote>
<p>流程描述：</p>
<p>用户进程发起<code>aio_read</code>操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它收到一个<code>asynchronous read</code>之后，首先它会立刻返回，所以不会对用户进程产生任何<code>block</code>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p>
<p><strong>异步IO的异步体现在：内核不用等待数据准备好就立刻返回， 所以内核肯定需要在IO完成后通知用户应用进程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb *aiocbp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aiocb</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">  <span class="comment">/* The order of these fields is implementation-dependent */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>             aio_fildes;     <span class="comment">/* File descriptor */</span></span><br><span class="line">  <span class="keyword">off_t</span>           aio_offset;     <span class="comment">/* File offset */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">void</span>  *aio_buf;        <span class="comment">/* Location of buffer */</span></span><br><span class="line">  <span class="keyword">size_t</span>          aio_nbytes;     <span class="comment">/* Length of transfer */</span></span><br><span class="line">  <span class="keyword">int</span>             aio_reqprio;    <span class="comment">/* Request priority */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>   <span class="comment">/* Notification method */</span></span><br><span class="line">  <span class="keyword">int</span>             aio_lio_opcode; <span class="comment">/* Operation to be performed;</span></span><br><span class="line"><span class="comment">                                       lio_listio() only */</span></span><br><span class="line">  <span class="comment">/* Various implementation-internal fields not shown */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<p><strong>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务</strong>。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<strong>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</strong>。</p>
<p>如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。</p>
<p>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
<p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此<strong>通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制</strong>。</p>
<p><strong>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p>
<p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机：</p>
<ul>
<li>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</li>
<li>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</li>
<li>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。</li>
</ul>
<p>IO多路复用除了需要阻塞之外，select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。</p>
<h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h3><h4 id="blocking和non-blocking区别"><a href="#blocking和non-blocking区别" class="headerlink" title="blocking和non-blocking区别"></a>blocking和non-blocking区别</h4><p>阻塞I/O发起真正的 I/O操作时（如read、recvfrom等）将会阻塞等待kernel数据就绪。非阻塞I/O在kernel还准备数据的情况下会立刻返回并且会不断发起system call，直到kernel数据就绪。</p>
<h4 id="synchronous-IO和asynchronous-IO区别"><a href="#synchronous-IO和asynchronous-IO区别" class="headerlink" title="synchronous IO和asynchronous IO区别"></a>synchronous IO和asynchronous IO区别</h4><p>POSIX对这两个术语定义如下：</p>
<ul>
<li>同步I/O操作将会造成请求进程阻塞，直到I/O操作完成</li>
<li>异步I/O操作不会造成进程阻塞</li>
</ul>
<p>根据上面的定义我们可以看出，前面4种I/O模型都是同步I/O，因为它们的I/O操作(<code>recvfrom</code>)都会造成进程阻塞。只有最后一个I/O模型匹配异步I/O的定义。</p>
<blockquote>
<p>POSIX defines these two terms as follows:</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
<p>Using these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.</p>
</blockquote>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h4 id="I-O-Multiplexing是非阻塞I-O吗？"><a href="#I-O-Multiplexing是非阻塞I-O吗？" class="headerlink" title="I/O Multiplexing是非阻塞I/O吗？"></a>I/O Multiplexing是非阻塞I/O吗？</h4><p>很多人会混淆两者的关系，很显然，不是！</p>
<p>不管是select、poll、epoll都会导致进程阻塞。发起真正的IO操作时(比如recvfrom)，进程也会阻塞。</p>
<p>I/O Multiplexing优点在于一次性可以监控大量的file descriptors。</p>
<p><strong>特别注意：select、poll、epoll并不是I/O操作，read、recvfrom这些才是。</strong></p>
<h4 id="5种IO模型的比较"><a href="#5种IO模型的比较" class="headerlink" title="5种IO模型的比较"></a>5种IO模型的比较</h4><p>从上述五种 IO 模型可以看出，应用进程对内核发起 IO 系统调用后，内核会经过两个阶段来完成数据的传输：</p>
<ul>
<li>第一阶段：等待数据。即应用进程发起 IO 系统调用后，会一直等待数据；当有数据传入服务器，会将数据放入内核空间，此时数据准备好。</li>
<li>第二阶段：将数据从内核空间复制到用户空间，并返回给应用程序成功标识。</li>
</ul>
<p><strong>各个IO Model的比较如图所示：</strong></p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220127180434891.png" style="zoom: 80%;" />

<blockquote>
<p>前四种模型的第二阶段是相同的，都是处于阻塞状态，其主要区别在第一阶段。而异步 IO 模型则不同，应用进程在这两个阶段是完全不阻塞的。</p>
</blockquote>
<p>通过上面的图片，可以发现<code>non-blocking IO</code>和<code>asynchronous IO</code>的区别还是很明显的。在<code>non-blocking IO</code>中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而<code>asynchronous IO</code>则完全不同。它就像是用户进程将整个IO操作交给了它人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<table>
<thead>
<tr>
<th>IO 模型</th>
<th>第一阶段</th>
<th>第二阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞式IO</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>非阻塞式IO</td>
<td>非阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>IO多路程复用</td>
<td>阻塞（Select）</td>
<td>阻塞</td>
</tr>
<tr>
<td>信号驱动式IO</td>
<td>异步</td>
<td>阻塞</td>
</tr>
<tr>
<td>异步IO</td>
<td>异步</td>
<td>异步</td>
</tr>
</tbody></table>
<p>文章总结来源：</p>
<p><a href="https://qsjzwithguang19forever.gitee.io/framework-learning/gitbook_doc/jdk-jvm-juc/Linux_IO.html">framework-learning-Linux IO</a></p>
<p><a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型 </a></p>
<p><a href="https://segmentfault.com/a/1190000039898780">浅聊Linux的五种IO模型</a></p>
<p><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/371508875">聊聊同步、异步、阻塞与非阻塞</a></p>
<p><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java项目开发命名规范</title>
    <url>/post/158b228/</url>
    <content><![CDATA[<h2 id="Java中的命名规范"><a href="#Java中的命名规范" class="headerlink" title="Java中的命名规范"></a>Java中的命名规范</h2><p>好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速理清程序的脉络。不同语言中采用的命名形式大相径庭，Java 中常用到的命名形式共有三种，既首字母大写的 UpperCamelCase ，首字母小写的 lowerCamelCase 以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，<strong>类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。</strong></p>
<span id="more"></span>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">约束</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">项目名</td>
<td align="left">全部小写，多个单词用中划线分隔 ‘-’</td>
<td align="left">spring-cloud</td>
</tr>
<tr>
<td align="left">包名</td>
<td align="left">全部小写</td>
<td align="left">com.alibaba.fastjson</td>
</tr>
<tr>
<td align="left">类名</td>
<td align="left">单词首字母大写</td>
<td align="left">Feature, ParserConfig,DefaultFieldDeserializer</td>
</tr>
<tr>
<td align="left">变量名</td>
<td align="left">首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td>
<td align="left">password, userName</td>
</tr>
<tr>
<td align="left">常量名</td>
<td align="left">全部大写，多个单词，用‘_’分隔</td>
<td align="left">CACHE_EXPIRED_TIME</td>
</tr>
<tr>
<td align="left">方法</td>
<td align="left">同变量</td>
<td align="left">read(), readObject(), getById()</td>
</tr>
</tbody></table>
<h2 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h2><p><strong>包名</strong>统一使用<strong>小写</strong>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p>
<p>包名的构成可以分为以下几四部分<strong>【前缀】 【发起者名】【项目名】【模块名】</strong>。常见的前缀可以分为以下几种：</p>
<table>
<thead>
<tr>
<th align="left">前缀名</th>
<th align="left">例</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indi（或onem ）</td>
<td align="left">indi.发起者名.项目名.模块名.……</td>
<td align="left">个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。</td>
</tr>
<tr>
<td align="left">pers</td>
<td align="left">pers.个人名.项目名.模块名.……</td>
<td align="left">个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人</td>
</tr>
<tr>
<td align="left">priv</td>
<td align="left">priv.个人名.项目名.模块名.……</td>
<td align="left">私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。</td>
</tr>
<tr>
<td align="left">team</td>
<td align="left">team.团队名.项目名.模块名.……</td>
<td align="left">团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有</td>
</tr>
<tr>
<td align="left">顶级域名</td>
<td align="left">com.公司名.项目名.模块名.……</td>
<td align="left">公司项目，copyright由项目发起的公司所有</td>
</tr>
</tbody></table>
<h2 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h2><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用<strong>形容词或形容词短语</strong>，如 Cloneable，Callable 等，<strong>表示实现该接口的类有某种功能或能力</strong>。对于<strong>测试类则以它要测试的类开头，以 Test 结尾</strong>，如 HashMapTest。</p>
<p>对于一些特殊<strong>特有名词缩写也可以使用全大写</strong>命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest 命名，对于这种特殊的缩写，原则是统一就好。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">约束</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">抽象类</td>
<td align="left">Abstract 或者 Base 开头</td>
<td align="left">BaseUserService</td>
</tr>
<tr>
<td align="left">枚举类</td>
<td align="left">Enum 作为后缀</td>
<td align="left">GenderEnum</td>
</tr>
<tr>
<td align="left">工具类</td>
<td align="left">Utils 作为后缀</td>
<td align="left">StringUtils</td>
</tr>
<tr>
<td align="left">异常类</td>
<td align="left">Exception 结尾</td>
<td align="left">RuntimeException</td>
</tr>
<tr>
<td align="left">接口实现类</td>
<td align="left">接口名 + Impl</td>
<td align="left">UserServiceImpl</td>
</tr>
<tr>
<td align="left">领域模型相关</td>
<td align="left">/DO/DTO/VO/DAO</td>
<td align="left">正例：UserDAO 反例： UserDo， UserDao</td>
</tr>
<tr>
<td align="left">设计模式相关类</td>
<td align="left">Builder，Factory等</td>
<td align="left">当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td>
</tr>
<tr>
<td align="left">处理特定功能的</td>
<td align="left">Handler，Predicate，Validator</td>
<td align="left">表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td>
</tr>
<tr>
<td align="left">测试类</td>
<td align="left">Test 结尾</td>
<td align="left">UserServiceTest， 表示用来测试UserService类的</td>
</tr>
<tr>
<td align="left">MVC分层</td>
<td align="left">Controller，Service，ServiceImpl，DAO后缀</td>
<td align="left">UserManageController，UserManageDAO</td>
</tr>
</tbody></table>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即<strong>动词 + 名词</strong>。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>
<h3 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h3><p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">is</td>
<td align="left">对象是否符合期待的状态</td>
<td align="left">isValid</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">can</td>
<td align="left">对象能否执行所期待的动作</td>
<td align="left">canRemove</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">should</td>
<td align="left">调用方执行某个命令或方法是好还是不好，应不应该，或者说推荐还是不推荐</td>
<td align="left">shouldMigrate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">has</td>
<td align="left">对象是否持有所期待的数据和属性</td>
<td align="left">hasObservers</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">needs</td>
<td align="left">调用方是否需要执行某个命令或方法</td>
<td align="left">needsMigrate</td>
</tr>
</tbody></table>
<h3 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ensure</td>
<td align="left">检查是否为期待的状态，不是则抛出异常或返回error code</td>
<td align="left">ensureCapacity</td>
</tr>
<tr>
<td align="left">validate</td>
<td align="left">检查是否为正确的状态，不是则抛出异常或返回error code</td>
<td align="left">validateInputs</td>
</tr>
</tbody></table>
<h3 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Suffix</td>
<td align="left">IfNeeded</td>
<td align="left">需要的时候执行，不需要的时候什么都不做</td>
<td align="left">drawIfNeeded</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">might</td>
<td align="left">同上</td>
<td align="left">mightCreate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">try</td>
<td align="left">尝试执行，失败时抛出异常或是返回errorcode</td>
<td align="left">tryCreate</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">OrDefault</td>
<td align="left">尝试执行，失败时返回默认值</td>
<td align="left">getOrDefault</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">OrElse</td>
<td align="left">尝试执行、失败时返回实际参数中指定的值</td>
<td align="left">getOrElse</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">force</td>
<td align="left">强制尝试执行，error抛出异常或是返回值</td>
<td align="left">forceCreate, forceStop</td>
</tr>
</tbody></table>
<h3 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">blocking</td>
<td align="left">线程阻塞方法</td>
<td align="left">blockingGetUser</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">InBackground</td>
<td align="left">执行在后台的线程</td>
<td align="left">doInBackground</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">Async</td>
<td align="left">异步方法</td>
<td align="left">sendAsync</td>
</tr>
<tr>
<td align="left">Suffix</td>
<td align="left">Sync</td>
<td align="left">对应已有异步方法的同步方法</td>
<td align="left">sendSync</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">schedule</td>
<td align="left">Job和Task放入队列</td>
<td align="left">schedule, scheduleJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">post</td>
<td align="left">同上</td>
<td align="left">postJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">execute</td>
<td align="left">执行异步方法（注：我一般拿这个做同步方法名）</td>
<td align="left">execute, executeTask</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">start</td>
<td align="left">同上</td>
<td align="left">start, startJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">cancel</td>
<td align="left">停止异步方法</td>
<td align="left">cancel, cancelJob</td>
</tr>
<tr>
<td align="left">Prefix or Alone</td>
<td align="left">stop</td>
<td align="left">同上</td>
<td align="left">stop, stopJob</td>
</tr>
</tbody></table>
<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Prefix</td>
<td align="left">on</td>
<td align="left">事件发生时执行</td>
<td align="left">onCompleted</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">before</td>
<td align="left">事件发生前执行</td>
<td align="left">beforeUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">pre</td>
<td align="left">同上</td>
<td align="left">preUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">will</td>
<td align="left">同上</td>
<td align="left">willUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">after</td>
<td align="left">事件发生后执行</td>
<td align="left">afterUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">post</td>
<td align="left">同上</td>
<td align="left">postUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">did</td>
<td align="left">同上</td>
<td align="left">didUpdate</td>
</tr>
<tr>
<td align="left">Prefix</td>
<td align="left">should</td>
<td align="left">确认事件是否可以发生时执行</td>
<td align="left">shouldUpdate</td>
</tr>
</tbody></table>
<h3 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">initialize</td>
<td align="left">初始化。也可作为延迟初始化使用</td>
<td align="left">initialize</td>
</tr>
<tr>
<td align="left">pause</td>
<td align="left">暂停</td>
<td align="left">onPause ，pause</td>
</tr>
<tr>
<td align="left">stop</td>
<td align="left">停止</td>
<td align="left">onStop，stop</td>
</tr>
<tr>
<td align="left">abandon</td>
<td align="left">销毁的替代</td>
<td align="left">abandon</td>
</tr>
<tr>
<td align="left">destroy</td>
<td align="left">同上</td>
<td align="left">destroy</td>
</tr>
<tr>
<td align="left">dispose</td>
<td align="left">同上</td>
<td align="left">dispose</td>
</tr>
</tbody></table>
<h3 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contains</td>
<td align="left">是否持有与指定对象相同的对象</td>
<td align="left">contains</td>
</tr>
<tr>
<td align="left">add</td>
<td align="left">添加</td>
<td align="left">addJob</td>
</tr>
<tr>
<td align="left">append</td>
<td align="left">添加</td>
<td align="left">appendJob</td>
</tr>
<tr>
<td align="left">insert</td>
<td align="left">插入到下标 n 的位置</td>
<td align="left">insertJob</td>
</tr>
<tr>
<td align="left">put</td>
<td align="left">添加与key对应的元素</td>
<td align="left">putJob</td>
</tr>
<tr>
<td align="left">remove</td>
<td align="left">移除元素</td>
<td align="left">removeJob</td>
</tr>
<tr>
<td align="left">enqueue</td>
<td align="left">添加到队列的最末位</td>
<td align="left">enqueueJob</td>
</tr>
<tr>
<td align="left">dequeue</td>
<td align="left">从队列中头部取出并移除</td>
<td align="left">dequeueJob</td>
</tr>
<tr>
<td align="left">push</td>
<td align="left">添加到栈头</td>
<td align="left">pushJob</td>
</tr>
<tr>
<td align="left">pop</td>
<td align="left">从栈头取出并移除</td>
<td align="left">popJob</td>
</tr>
<tr>
<td align="left">peek</td>
<td align="left">从栈头取出但不移除</td>
<td align="left">peekJob</td>
</tr>
<tr>
<td align="left">find</td>
<td align="left">寻找符合条件的某物</td>
<td align="left">findById</td>
</tr>
</tbody></table>
<h3 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
<th align="left">例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">create</td>
<td align="left">新创建</td>
<td align="left">createAccount</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">新创建</td>
<td align="left">newAccount</td>
</tr>
<tr>
<td align="left">from</td>
<td align="left">从既有的某物新建，或是从其他的数据新建</td>
<td align="left">fromConfig</td>
</tr>
<tr>
<td align="left">to</td>
<td align="left">转换</td>
<td align="left">toString</td>
</tr>
<tr>
<td align="left">update</td>
<td align="left">更新既有某物</td>
<td align="left">updateAccount</td>
</tr>
<tr>
<td align="left">load</td>
<td align="left">读取</td>
<td align="left">loadAccount</td>
</tr>
<tr>
<td align="left">fetch</td>
<td align="left">远程读取</td>
<td align="left">fetchAccount</td>
</tr>
<tr>
<td align="left">delete</td>
<td align="left">删除</td>
<td align="left">deleteAccount</td>
</tr>
<tr>
<td align="left">remove</td>
<td align="left">删除</td>
<td align="left">removeAccount</td>
</tr>
<tr>
<td align="left">save</td>
<td align="left">保存</td>
<td align="left">saveAccount</td>
</tr>
<tr>
<td align="left">store</td>
<td align="left">保存</td>
<td align="left">storeAccount</td>
</tr>
<tr>
<td align="left">commit</td>
<td align="left">保存</td>
<td align="left">commitChange</td>
</tr>
<tr>
<td align="left">apply</td>
<td align="left">保存或应用</td>
<td align="left">applyChange</td>
</tr>
<tr>
<td align="left">clear</td>
<td align="left">清除数据或是恢复到初始状态</td>
<td align="left">clearAll</td>
</tr>
<tr>
<td align="left">reset</td>
<td align="left">清除数据或是恢复到初始状态</td>
<td align="left">resetAll</td>
</tr>
</tbody></table>
<h3 id="成对出现的动词"><a href="#成对出现的动词" class="headerlink" title="成对出现的动词"></a>成对出现的动词</h3><table>
<thead>
<tr>
<th align="left">单词</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">get 获取</td>
<td align="left">set 设置</td>
</tr>
<tr>
<td align="left">add 增加</td>
<td align="left">remove 删除</td>
</tr>
<tr>
<td align="left">create 创建</td>
<td align="left">destory 移除</td>
</tr>
<tr>
<td align="left">start 启动</td>
<td align="left">stop 停止</td>
</tr>
<tr>
<td align="left">open 打开</td>
<td align="left">close 关闭</td>
</tr>
<tr>
<td align="left">read 读取</td>
<td align="left">write 写入</td>
</tr>
<tr>
<td align="left">load 载入</td>
<td align="left">save 保存</td>
</tr>
<tr>
<td align="left">create 创建</td>
<td align="left">destroy 销毁</td>
</tr>
<tr>
<td align="left">begin 开始</td>
<td align="left">end 结束</td>
</tr>
<tr>
<td align="left">backup 备份</td>
<td align="left">restore 恢复</td>
</tr>
<tr>
<td align="left">import 导入</td>
<td align="left">export 导出</td>
</tr>
<tr>
<td align="left">split 分割</td>
<td align="left">merge 合并</td>
</tr>
<tr>
<td align="left">inject 注入</td>
<td align="left">extract 提取</td>
</tr>
<tr>
<td align="left">attach 附着</td>
<td align="left">detach 脱离</td>
</tr>
<tr>
<td align="left">bind 绑定</td>
<td align="left">separate 分离</td>
</tr>
<tr>
<td align="left">view 查看</td>
<td align="left">browse 浏览</td>
</tr>
<tr>
<td align="left">edit 编辑</td>
<td align="left">modify 修改</td>
</tr>
<tr>
<td align="left">select 选取</td>
<td align="left">mark 标记</td>
</tr>
<tr>
<td align="left">copy 复制</td>
<td align="left">paste 粘贴</td>
</tr>
<tr>
<td align="left">undo 撤销</td>
<td align="left">redo 重做</td>
</tr>
<tr>
<td align="left">insert 插入</td>
<td align="left">delete 移除</td>
</tr>
<tr>
<td align="left">add 加入</td>
<td align="left">append 添加</td>
</tr>
<tr>
<td align="left">clean 清理</td>
<td align="left">clear 清除</td>
</tr>
<tr>
<td align="left">index 索引</td>
<td align="left">sort 排序</td>
</tr>
<tr>
<td align="left">find 查找</td>
<td align="left">search 搜索</td>
</tr>
<tr>
<td align="left">increase 增加</td>
<td align="left">decrease 减少</td>
</tr>
<tr>
<td align="left">play 播放</td>
<td align="left">pause 暂停</td>
</tr>
<tr>
<td align="left">launch 启动</td>
<td align="left">run 运行</td>
</tr>
<tr>
<td align="left">compile 编译</td>
<td align="left">execute 执行</td>
</tr>
<tr>
<td align="left">debug 调试</td>
<td align="left">trace 跟踪</td>
</tr>
<tr>
<td align="left">observe 观察</td>
<td align="left">listen 监听</td>
</tr>
<tr>
<td align="left">build 构建</td>
<td align="left">publish 发布</td>
</tr>
<tr>
<td align="left">input 输入</td>
<td align="left">output 输出</td>
</tr>
<tr>
<td align="left">encode 编码</td>
<td align="left">decode 解码</td>
</tr>
<tr>
<td align="left">encrypt 加密</td>
<td align="left">decrypt 解密</td>
</tr>
<tr>
<td align="left">compress 压缩</td>
<td align="left">decompress 解压缩</td>
</tr>
<tr>
<td align="left">pack 打包</td>
<td align="left">unpack 解包</td>
</tr>
<tr>
<td align="left">parse 解析</td>
<td align="left">emit 生成</td>
</tr>
<tr>
<td align="left">connect 连接</td>
<td align="left">disconnect 断开</td>
</tr>
<tr>
<td align="left">send 发送</td>
<td align="left">receive 接收</td>
</tr>
<tr>
<td align="left">download 下载</td>
<td align="left">upload 上传</td>
</tr>
<tr>
<td align="left">refresh 刷新</td>
<td align="left">synchronize 同步</td>
</tr>
<tr>
<td align="left">update 更新</td>
<td align="left">revert 复原</td>
</tr>
<tr>
<td align="left">lock 锁定</td>
<td align="left">unlock 解锁</td>
</tr>
<tr>
<td align="left">check out 签出</td>
<td align="left">check in 签入</td>
</tr>
<tr>
<td align="left">submit 提交</td>
<td align="left">commit 交付</td>
</tr>
<tr>
<td align="left">push 推</td>
<td align="left">pull 拉</td>
</tr>
<tr>
<td align="left">expand 展开</td>
<td align="left">collapse 折叠</td>
</tr>
<tr>
<td align="left">begin 起始</td>
<td align="left">end 结束</td>
</tr>
<tr>
<td align="left">start 开始</td>
<td align="left">finish 完成</td>
</tr>
<tr>
<td align="left">enter 进入</td>
<td align="left">exit 退出</td>
</tr>
<tr>
<td align="left">abort 放弃</td>
<td align="left">quit 离开</td>
</tr>
<tr>
<td align="left">obsolete 废弃</td>
<td align="left">depreciate 废旧</td>
</tr>
<tr>
<td align="left">collect 收集</td>
<td align="left">aggregate 聚集</td>
</tr>
</tbody></table>
<h2 id="变量-amp-常量命名"><a href="#变量-amp-常量命名" class="headerlink" title="变量&amp;常量命名"></a>变量&amp;常量命名</h2><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量是指在程序运行中可以改变其值的量，包括<strong>成员变量</strong>和<strong>局部变量</strong>。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称<strong>骆驼式命名法（也称驼峰命名法）</strong>，如 computedValues，index、变量命名时，<strong>尽量简短且能清楚的表达变量的作用</strong>，命名体现具体的业务含义即可。</p>
<p><strong>变量名不应以下划线或美元符号开头</strong>，尽管这在语法上是允许的。变量名应<strong>简短且富于描述</strong>。变量名的选用应该易于记忆，即，能够指出其用途。<strong>尽量避免单个字符的变量名，除非是一次性的临时变量</strong>。pojo中的布尔变量，都不要加is（数据库中的布尔字段全都要加 is_ 前缀）。</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量命名CONSTANT_CASE，一般采用<strong>全部大写（作为方法参数时除外）</strong>，<strong>单词间用下划线分割</strong>。那么什么是常量呢？</p>
<p>常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，<strong>全局常量（public static final修饰）</strong>，<strong>类内常量（private static final 修饰）</strong>以及<strong>局部常量（方法内，或者参数中的常量）</strong>，<strong>局部常量比较特殊，通常采用小驼峰命名即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(正例)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_MESSAGE_CACHE_EXPIRE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(反例，命名不清晰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MESSAGE_CACHE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">&quot; error message&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印 &#123;<span class="doctag">@code</span> message&#125; 信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体，局部常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量一般都有自己的业务含义，<strong>不要害怕长度过长而进行省略或者缩写</strong>。如：用户消息缓存过期时间的表示，哪种方式更佳清晰，交给你来评判。</p>
<h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol>
<li>尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。 正例： BeiJing， HangZhou 反例： validateCanShu</li>
<li>命名过程中尽量不要出现特殊的字符，常量除外。</li>
<li>尽量不要和 jdk或者框架中已存在的类重名，也不能使用 java中的关键字命名。</li>
<li>妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。 如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。</li>
</ol>
<h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="注解的原则"><a href="#注解的原则" class="headerlink" title="注解的原则"></a>注解的原则</h3><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p>
<ol>
<li><p><strong>Nothing is strange</strong> 没有注解的代码对于阅读者非常不友好，哪怕代码写的再清楚，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还要说清楚修改的逻辑。</p>
</li>
<li><p><strong>Less is more</strong> 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取信息【废话注解】</span></span><br><span class="line">getMessageById(id)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Advance with the time</strong> 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</p>
</li>
</ol>
<h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成 JavaAPI为外部用户提供有效的支持 javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。</p>
<h4 id="包注解"><a href="#包注解" class="headerlink" title="包注解"></a>包注解</h4><p>包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 落地也质量检测</span></span><br><span class="line"><span class="comment"> * 1. 用来解决什么问题</span></span><br><span class="line"><span class="comment"> * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 如何实现</span></span><br><span class="line"><span class="comment"> * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意： 网络环境配置信息&#123;<span class="doctag">@link</span> cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum&#125;目前使用是常规速度，可以根据实际情况进行调整</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/12/7 20:3 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.mycookies.landingpagecheck;</span><br></pre></td></tr></table></figure>

<h4 id="类注接"><a href="#类注接" class="headerlink" title="类注接"></a>类注接</h4><p>javadoc注解中，每个类都必须有注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (C), 2019-2020, Jann  balabala...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>   类创建者姓名 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>     创建日期 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>  版本号 保持对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h4><p>在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 提示信息 */</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>

<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法的详细说明，能干嘛，怎么实现的，注意事项...</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx   参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回结果的说明， 不同情况下会返回怎样的结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h4 id="构造方法注释"><a href="#构造方法注释" class="headerlink" title="构造方法注释"></a>构造方法注释</h4><p>在每个构造方法前面必须加上注释，注释模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法的详细说明</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx   参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<p>而简单注解往往是需要工程师自己定义，在使用注解时应该注意一下几点：</p>
<ol>
<li><strong>枚举类的各个属性值都要使用注解</strong>，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。</li>
<li><strong>保持排版整洁，不要使用行尾注释</strong>；<strong>双斜杠和星号之后要用1个空格分隔</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">1</span>;<span class="comment">// 反例：不要使用行尾注释</span></span><br><span class="line"><span class="comment">//反例：换行符与注释之间没有缩进</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 正例：姓名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 多行注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 对于不同的逻辑说明，可以用空行分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<p>文章来源：<a href="https://www.cnblogs.com/liqiangchn/p/12000361.html">告别编码5分钟，命名2小时！史上最全的Java命名规范参考！</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC</title>
    <url>/post/eff096d5/</url>
    <content><![CDATA[<h2 id="Spring-IOC是什么？"><a href="#Spring-IOC是什么？" class="headerlink" title="Spring IOC是什么？"></a>Spring IOC是什么？</h2><p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而<strong>IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建</strong>；</p>
<ul>
<li><p><strong>谁控制谁？当然是IoC 容器控制了对象；</strong></p>
</li>
<li><p><strong>控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p>
<span id="more"></span></li>
<li><p><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；</p>
</li>
<li><p><strong>为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；</strong></p>
</li>
<li><p><strong>哪些方面反转了？依赖对象的获取被反转了。</strong></p>
</li>
</ul>
<p>传统程序设计，都是主动去创建相关对象然后再组合起来：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/261421378318292.jpg"></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了：</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/M4WDLSB3%5B__W1$PJZ1%60%7DXGF.png"></p>
<p><strong>Spring所倡导的开发方式</strong>：<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p>
<h2 id="IoC能做什么？"><a href="#IoC能做什么？" class="headerlink" title="IoC能做什么？"></a>IoC能做什么？</h2><p>​        <strong>IoC 不是一种技术，只是一种思想</strong>，一个重要的<strong>面向对象编程的法则</strong>，它能指导我们如何设计出<strong>松耦合</strong>、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>​        其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p>
<p>​        <strong>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p>
<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>　<strong>DI—Dependency Injection</strong>，即“依赖注入”：组件之间依赖关系由容器在<strong>运行期决定</strong>，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>DI是如何实现的呢？ Java 1.3之后一个重要特征是<strong>反射（reflection）</strong>，它允许程序<strong>在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的</strong>。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><strong>谁依赖于谁：</strong>当然是<strong>应用程序依赖于IoC容器</strong>；</li>
<li><strong>为什么需要依赖：</strong> <strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</li>
<li><strong>谁注入谁：</strong>很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</li>
<li><strong>注入了什么：</strong>就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</li>
</ul>
<p><strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“</strong> <strong>依赖注入”</strong> <strong>明确描述了“被注入对象依赖IoC</strong> <strong>容器配置依赖对象”。</strong></p>
<h2 id="对IoC-控制反转-和DI-依赖注入-的理解"><a href="#对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="对IoC(控制反转)和DI(依赖注入)的理解"></a>对IoC(控制反转)和DI(依赖注入)的理解</h2><p>​        在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像<code>new object()</code> 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p>
<p>　　所以<strong>控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方</strong>，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p>
<hr>
<p>相关文章：</p>
<p> <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection </a></p>
<p> <a href="https://link.zhihu.com/?target=https://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a> </p>
<p><a href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析</a></p>
<p>参考总结来源：</p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">谈谈对Spring IOC的理解</a></p>
]]></content>
      <categories>
        <category>开发框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>curl</title>
    <url>/post/3e01b4d/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>cURL</strong>是一个开源项目，主要的产品是curl（<strong>命令行工具</strong>）和libcurl（C语言的API库），两者功能均是：基于网络协议，对指定URL进行网络传输（发出网络请求）。curl可以得到和提取数据，显示在”标准输出”（stdout）上面。</p>
<p>cURL涉及是任何网络协议传输，不涉及对具体数据的具体处理。（如：html的渲染等）</p>
<p>curl 支持多种协议，下面举例讲解如何将它用于网站开发。</p>
<span id="more"></span>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h3><p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址<a href="http://www.mi.com为例（选择该网址，主要因为它的网页代码较短）：">www.mi.com为例（选择该网址，主要因为它的网页代码较短）：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl www.mi.com</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Moved Permanently<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The document has moved <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.sina.com.cn/&quot;</span>&gt;</span>here<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="服务器的回应保存成文件"><a href="#服务器的回应保存成文件" class="headerlink" title="服务器的回应保存成文件"></a>服务器的回应保存成文件</h3><p><code>-o</code>参数将服务器的回应保存成文件，等同于<code>wget</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o [文件名] www.mi.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o example.html https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令将 <code>www.example.com </code>保存成 <code>example.html</code>。</p>
<p><code>-O</code>参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://www.example.com/foo/bar.html</span><br></pre></td></tr></table></figure>

<p>上面命令将服务器回应保存成文件，文件名为<code>bar.html</code>。</p>
<h3 id="自动跳转（重定向）"><a href="#自动跳转（重定向）" class="headerlink" title="自动跳转（重定向）"></a>自动跳转（重定向）</h3><p><code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L www.sina.com</span><br></pre></td></tr></table></figure>

<p>键入上面的命令，结果就自动跳转为<a href="http://www.sina.com.cn./">www.sina.com.cn。</a></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L -d <span class="string">&#x27;tweet=hi&#x27;</span> https://api.twitter.com/tweet</span><br></pre></td></tr></table></figure>



<h3 id="显示头信息"><a href="#显示头信息" class="headerlink" title="显示头信息"></a>显示头信息</h3><p><code>-i </code>参数可以<strong>显示http response的头信息，连同网页代码一起</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -i www.mi.com</span><br></pre></td></tr></table></figure>

<p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">TP/1.1 302 Moved Temporarily</span><br><span class="line">Server: kngx/1.10.2</span><br><span class="line">Date: Fri, 04 Feb 2022 09:49:31 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 160</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://www.mi.com/</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">x-link-via: zzct010:80;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>kngx/1.10.2<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>-I</code> 参数则是<strong>只显示http response的头信息</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令输出服务器对 HEAD 请求的回应。</p>
<p><code>--head</code>参数等同于<code>-I</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --head https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="显示通信过程"><a href="#显示通信过程" class="headerlink" title="显示通信过程"></a>显示通信过程</h3><p><code>-v </code>参数可以<strong>显示一次http通信的整个过程</strong>（用于调试），包括端口连接和http request头信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v https://www.example.com</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v www.mi.com</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  Trying 240e:93c:210:3::6:80...</span><br><span class="line">* Connected to www.mi.com (240e:93c:210:3::6) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: www.mi.com</span><br><span class="line">&gt; User-Agent: curl/7.74.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP/1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: kngx/1.10.2</span><br><span class="line">&lt; Date: Fri, 04 Feb 2022 09:52:02 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 160</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: https://www.mi.com/</span><br><span class="line">&lt; Cache-Control: max-age=0</span><br><span class="line">&lt; x-link-via: zzct010:80;</span><br><span class="line">&lt;</span><br><span class="line">&#123; [160 bytes data]</span><br><span class="line">100   160  100   160    0     0   4444      0 --:--:-- --:--:-- --:--:--  4444<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>302 Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>kngx/1.10.2<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">* Connection #0 to host www.mi.com left intact</span><br></pre></td></tr></table></figure>

<p>如果你觉得上面的信息还不够，那么下面的命令<strong>可以查看更详细的通信过程</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace output.txt www.mi.com</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace-ascii output.txt www.mi.com</span><br></pre></td></tr></table></figure>

<p>运行后，请打开 output.txt文件查看。</p>
<p><code>--trace</code>参数也可以用于调试，还会输出原始的二进制数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace - https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="发送表单信息"><a href="#发送表单信息" class="headerlink" title="发送表单信息"></a>发送表单信息</h3><p><strong>发送表单信息有GET和POST两种方法</strong>。GET方法相对简单，只要把数据附在网址后面就行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure>

<p><code>-G</code>参数用来构造 URL 的查询字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -G -d <span class="string">&#x27;q=kitties&#x27;</span> -d <span class="string">&#x27;count=20&#x27;</span> https://google.com/search</span><br></pre></td></tr></table></figure>

<p>上面命令会发出一个 GET 请求，实际请求的 URL 为<code>https://google.com/search?q=kitties&amp;count=20</code>。如果省略<code>--G</code>，会发出一个 POST 请求。</p>
<p>如果数据需要 URL 编码，可以结合<code>--data--urlencode</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -G --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>



<h4 id="发送-POST-请求的数据体"><a href="#发送-POST-请求的数据体" class="headerlink" title="发送 POST 请求的数据体"></a>发送 POST 请求的数据体</h4><p>POST方法必须把数据和网址分开，curl就要用到 <code>--data</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST --data <span class="string">&quot;data=xxx&quot;</span> example.com/form.cgi</span><br></pre></td></tr></table></figure>



<p><code>-d</code>参数用于发送 POST 请求的数据体。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d<span class="string">&#x27;login=emma＆password=123&#x27;</span>-X POST https://google.com/login</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;login=emma&#x27;</span> -d <span class="string">&#x27;password=123&#x27;</span> -X POST  https://google.com/login</span><br></pre></td></tr></table></figure>

<p>使用 <code>-d</code> 参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p>
<p><code>-d</code> 参数可以读取本地文本文件的数据，向服务器发送。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;@data.txt&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p>
<p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p>
<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST--data-urlencode <span class="string">&quot;date=April 1&quot;</span> example.com/form.cgi</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p>
<h3 id="HTTP-请求的代理"><a href="#HTTP-请求的代理" class="headerlink" title="HTTP 请求的代理"></a>HTTP 请求的代理</h3><p><code>-x</code>参数指定 HTTP 请求的代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令指定 HTTP 请求通过<code>myproxy.com:8080</code>的 socks5 代理发出。</p>
<p>如果没有指定代理协议，默认为 HTTP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x james:cats@myproxy.com:8080 https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令中，请求的代理使用 HTTP 协议。</p>
<h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p><code>-X</code>参数指定 HTTP 请求的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令对<code>https://www.example.com</code>发出 POST 请求。</p>
<p><strong>curl默认的HTTP动词是GET</strong>，<strong>使用</strong> <code>-X</code> <strong>参数可以支持其他动词</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST www.example.com</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>假定文件上传的表单是下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&#x27;multipart/form-data&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;upload.cgi&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">press</span> <span class="attr">value</span>=<span class="string">&quot;OK&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以用curl这样上传文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure>



<p><code>-F</code>参数用来向服务器上传二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p>
<p><code>-F</code>参数可以指定 MIME 类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png;type=image/png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令指定 MIME 类型为<code>image/png</code>，否则 curl 会把 MIME 类型设为<code>application/octet-stream</code>。</p>
<p><code>-F</code>参数也可以指定文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png;filename=me.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure>

<p>上面命令中，原始文件名为<code>photo.png</code>，但是服务器接收到的文件名为<code>me.png</code>。</p>
<h3 id="Referer字段"><a href="#Referer字段" class="headerlink" title="Referer字段"></a>Referer字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure>

<p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -e <span class="string">&#x27;https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>Referer</code>标头设为<code>https://google.com?q=example</code>。</p>
<p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Referer: https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure>



<h3 id="User-Agent字段"><a href="#User-Agent字段" class="headerlink" title="User Agent字段"></a>User Agent字段</h3><p>这个字段是用来表示<strong>客户端的设备信息</strong>。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p>
<p>iPhone4的User Agent是</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4<span class="built_in">_</span>0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure>

<p>curl可以这样模拟：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --user-agent <span class="string">&quot;[User Agent]&quot;</span> [URL]</span><br></pre></td></tr></table></figure>



<p><code>-A</code>参数指定客户端的用户代理标头，即<code>User-Agent</code>。curl 的默认用户代理字符串是<code>curl/[version]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将<code>User-Agent</code>改成 Chrome 浏览器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A <span class="string">&#x27;&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令会移除<code>User-Agent</code>标头。</p>
<p>也可以通过<code>-H</code>参数直接指定标头，更改<code>User-Agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;User-Agent: php/1.0&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>



<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>使用 <code>--cookie</code> 参数，可以让curl发送cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --cookie <span class="string">&quot;name=xxx&quot;</span> www.example.com</span><br></pre></td></tr></table></figure>

<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -c cookies http://example.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -c cookies.txt https://www.google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件<code>cookies.txt</code>。</p>
<p><code>-b</code>参数用来向服务器发送 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b cookies http://example.com</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">&#x27;foo=bar&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令会生成一个标头<code>Cookie: foo=bar</code>，向服务器发送一个名为<code>foo</code>、值为<code>bar</code>的 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">&#x27;foo1=bar;foo2=bar2&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令发送两个 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b cookies.txt https://www.google.com</span><br></pre></td></tr></table></figure>

<p>上面命令读取本地文件<code>cookies.txt</code>，里面是服务器设置的 Cookie（参见<code>-c</code>参数），将其发送到服务器。</p>
<h3 id="增加头信息"><a href="#增加头信息" class="headerlink" title="增加头信息"></a>增加头信息</h3><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --header <span class="string">&quot;Content-Type:application/json&quot;</span> http://example.com</span><br></pre></td></tr></table></figure>



<p><code>-H</code>参数添加 HTTP 请求的标头。</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令添加 HTTP 标头<code>Accept-Language: en-US</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> -H <span class="string">&#x27;Secret-Message: xyzzy&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令添加两个 HTTP 标头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令添加 HTTP 请求的标头是<code>Content-Type: application/json</code>，然后用<code>-d</code>参数发送 JSON 数据。</p>
<h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>有些网域需要HTTP认证，这时curl需要用到 <code>--user</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --user name:password example.com</span><br></pre></td></tr></table></figure>



<h3 id="跳过-SSL-检测"><a href="#跳过-SSL-检测" class="headerlink" title="跳过 SSL 检测"></a>跳过 SSL 检测</h3><p><code>-k</code>参数指定跳过 SSL 检测。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令不会检查服务器的 SSL 证书是否正确。</p>
<h3 id="限制-HTTP-请求和回应的带宽"><a href="#限制-HTTP-请求和回应的带宽" class="headerlink" title="限制 HTTP 请求和回应的带宽"></a>限制 HTTP 请求和回应的带宽</h3><p><code>--limit-rate</code>用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --limit-rate 200k https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令将带宽限制在每秒 200K 字节。</p>
<h3 id="错误信息的输出"><a href="#错误信息的输出" class="headerlink" title="错误信息的输出"></a>错误信息的输出</h3><p><code>-s</code> 参数将不输出错误和进度信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://www.example.com</span><br></pre></td></tr></table></figure>

<p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p>
<p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o /dev/null https://google.com</span><br></pre></td></tr></table></figure>



<p><code>-S</code>参数指定只输出错误信息，通常与<code>-s</code>一起使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -S -o /dev/null https://google.com</span><br></pre></td></tr></table></figure>

<p>上面命令没有任何输出，除非发生错误。</p>
<h3 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h3><p><code>-u</code> 参数用来设置服务器认证的用户名和密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;bob:12345&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令设置用户名为<code>bob</code>，密码为<code>12345</code>，然后将其转为 HTTP 标头<code>Authorization: Basic Ym9iOjEyMzQ1</code>。</p>
<p>curl 能够识别 URL 里面的用户名和密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://bob:12345@google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;bob&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure>

<p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</p>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><p>​        curl命令作用 curl命令是一个功能强大的网络工具，它能够通过http、ftp等方式下载文件，也能够上传文件，同时支持HTTPS等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。其实curl远不止前面所说的那些功能，大家可以通过man curl阅读手册页获取更多的信息。类似的工具还有wget。curl命令使用了libcurl库来实现，libcurl库常用在C程序中用来处理HTTP请求，curlpp是libcurl的一个C++封装，这几个东西可以用在抓取网页、网络监控等方面的开发，而curl命令可以帮助来解决开发过程中遇到的问题。</p>
<p>常用参数 curl命令参数很多，这里只列出我曾经用过、特别是在shell脚本中经常用到过的那些。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-a/--append 上传文件时，附加到目标文件</span><br><span class="line"></span><br><span class="line">-A:随意指定自己这次访问所宣称的自己的浏览器信息</span><br><span class="line"></span><br><span class="line">-b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置，使用option来把上次的cookie信息追加到http request里面去。</span><br><span class="line"></span><br><span class="line">-c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中</span><br><span class="line"></span><br><span class="line">-C/--continue-at &lt;offset&gt;  断点续转</span><br><span class="line"></span><br><span class="line">-d/--data &lt;data&gt;   HTTP POST方式传送数据</span><br><span class="line"></span><br><span class="line">    --data-ascii &lt;data&gt;	以ascii的方式post数据</span><br><span class="line">     --data-binary &lt;data&gt;	以二进制的方式post数据</span><br><span class="line">     --negotiate	使用HTTP身份验证</span><br><span class="line">     --digest	使用数字身份验证</span><br><span class="line">     --disable-eprt	禁止使用EPRT或LPRT</span><br><span class="line">     --disable-epsv	禁止使用EPSV</span><br><span class="line">-D/--dump-header &lt;file&gt; 把header信息写入到该文件中</span><br><span class="line"></span><br><span class="line">     --egd-file &lt;file&gt;  为随机数据(SSL)设置EGD socket路径</span><br><span class="line"></span><br><span class="line">     --tcp-nodelay     使用TCP<span class="built_in">_</span>NODELAY选项</span><br><span class="line"></span><br><span class="line">-e/--referer &lt;URL&gt;  指定引用地址</span><br><span class="line"></span><br><span class="line">-F/--form &lt;name=content&gt;   模拟http表单提交数据</span><br><span class="line"></span><br><span class="line">     --form-string &lt;name=string&gt; 模拟http表单提交数据</span><br><span class="line"></span><br><span class="line">-G/--get    以get的方式来发送数据</span><br><span class="line"></span><br><span class="line">-H/--header &lt;header&gt; 指定请求头参数</span><br><span class="line"></span><br><span class="line">    --ignore-content-length  忽略的HTTP头信息的长度</span><br><span class="line"></span><br><span class="line">-i/--include     输出时包括protocol头信息</span><br><span class="line"></span><br><span class="line">-I/--head 仅返回头部信息，使用HEAD请求</span><br><span class="line"></span><br><span class="line">-k/--insecure  允许不使用证书到SSL站点</span><br><span class="line"></span><br><span class="line">-K/--config    指定的配置文件读取</span><br><span class="line"></span><br><span class="line">-l/--list-only   列出ftp目录下的文件名称</span><br><span class="line"></span><br><span class="line">    --limit-rate &lt;rate&gt; 设置传输速度</span><br><span class="line"></span><br><span class="line">     --local-port&lt;NUM&gt;  强制使用本地端口号</span><br><span class="line"></span><br><span class="line">-m/--max-time &lt;seconds&gt; 指定处理的最大时长</span><br><span class="line"></span><br><span class="line">     --max-redirs &lt;num&gt;    设置最大读取的目录数</span><br><span class="line"></span><br><span class="line">     --max-filesize &lt;bytes&gt;  设置最大下载的文件总量</span><br><span class="line"></span><br><span class="line">-o/--output &lt;file&gt;   指定输出文件名称</span><br><span class="line"></span><br><span class="line">-O/--remote-name  把输出写到该文件中，保留远程文件的文件名</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">-v/--verbose  小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</span><br><span class="line"></span><br><span class="line">-s/--slient 减少输出的信息，比如进度</span><br><span class="line"></span><br><span class="line">--connect-timeout &lt;seconds&gt; 指定尝试连接的最大时长</span><br><span class="line"></span><br><span class="line">-x/--proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">-u/--user &lt;user[:password]&gt;设置服务器的用户和密码</span><br><span class="line"></span><br><span class="line">-r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line"></span><br><span class="line">   --range-file 读取（SSL）的随机文件</span><br><span class="line"></span><br><span class="line">-R/--remote-time   在本地生成文件时，保留远程文件时间</span><br><span class="line"></span><br><span class="line">    --retry &lt;num&gt;   指定重试次数</span><br><span class="line"></span><br><span class="line">    --retry-delay &lt;seconds&gt;   传输出现问题时，设置重试间隔时间</span><br><span class="line"></span><br><span class="line">    --retry-max-time &lt;seconds&gt;  传输出现问题时，设置最大重试时间</span><br><span class="line"></span><br><span class="line">-s/--silent  静默模式。不输出任何东西</span><br><span class="line"></span><br><span class="line">-S/--show-error  显示错误</span><br><span class="line"></span><br><span class="line">    --socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口</span><br><span class="line"></span><br><span class="line">    --socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口</span><br><span class="line"></span><br><span class="line">    --stderr &lt;file&gt;</span><br><span class="line"></span><br><span class="line">-x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理</span><br><span class="line"></span><br><span class="line">-X/--request &lt;command&gt; 指定什么命令。curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。</span><br><span class="line"></span><br><span class="line">-T/--upload-file &lt;file&gt; 指定上传文件路径</span><br></pre></td></tr></table></figure>





<p>文章总结来源：</p>
<p><a href="https://www.ruanyifeng.com/blog/2011/09/curl.html">curl网站开发指南</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a></p>
<p><a href="https://handerfly.github.io/linux/2019/05/26/curl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">curl命令详解</a></p>
<p>更多内容查看：</p>
<p><a href="https://curl.se/docs/manpage.html">curl 用户手册</a></p>
]]></content>
      <categories>
        <category>命令行工具</category>
      </categories>
      <tags>
        <tag>命令行工具</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/post/f92eff5d/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯算法</a> 实际上一个<strong>类似枚举的搜索尝试过程</strong>，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“<strong>通用解题方法</strong>”的美称。</p>
<span id="more"></span>
<h3 id="与穷举的联系"><a href="#与穷举的联系" class="headerlink" title="与穷举的联系"></a>与穷举的联系</h3><p>回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。</p>
<p>回溯法的特点是<strong>深度优先遍历</strong>，也就是该问题的遍历顺序是1-&gt;2-&gt;3，然后从子节点3返回，从子节点2返回，再到1-&gt;3-&gt;2，以此类推。</p>
<p>状态的返回只有当前的节点不再满足问题的条件或者我们已经找到了问题的一个解时，才会返回，否则会以深度优先一直在<strong>解空间树</strong>内遍历下去。</p>
<p>当然，对于某些问题如果其解空间过大，即使用回溯法进行计算也有很高的时间复杂度，因为回溯法会尝试解空间树中所有的分支。</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>所以根据这类问题，有一些优化剪枝策略以及启发式搜索策略。</p>
<p><strong>优化剪枝策略</strong>：判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</p>
<p><strong>启发式搜索策略</strong>：给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</p>
<h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>回溯算法也叫<strong>试探法</strong>，它是一种系统地搜索问题的解的方法。</p>
<p>用回溯算法解决问题的一般步骤：</p>
<ol>
<li><strong>针对</strong>所给<strong>问题</strong>，<strong>定义问题的解空间</strong>，它至少包含问题的一个（最优）解。</li>
<li><strong>确定</strong>易于搜索的<strong>解空间结构</strong>，使得能用回溯法方便地搜索整个解空间 。</li>
<li><strong>以深度优先的方式搜索解空间</strong>，并且在<strong>搜索过程中</strong>用<strong>剪枝</strong>函数避免无效搜索。</li>
</ol>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。<br><strong>回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</strong></p>
<p>回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的的搜索算法。</p>
<p>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。<br>算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。<br>如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。<br>否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。<br>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</p>
<p>这种以<strong>深度优先</strong>的方式<strong>系统地搜索</strong>问题的解的算法称为回溯法，它适用于解一些<strong>组合数较大的问题</strong>。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td>
<td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">通俗易懂+动画演示 17. 电话号码的字母组合</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td>
<td><a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">回溯算法 + 剪枝（回溯经典例题详解）</a><br/><a href="https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-feyl-lj9e/">回溯 + 剪枝</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></td>
<td><a href="https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/">回溯算法（Java）</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></td>
<td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/">回溯算法、优化（使用动态规划预处理数组）</a></td>
</tr>
</tbody></table>
<p>文章转载来源：<a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-backtracking">五大基本算法之回溯算法 backtracking</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/post/2633a26/</url>
    <content><![CDATA[<h2 id="常用的位操作"><a href="#常用的位操作" class="headerlink" title="常用的位操作"></a>常用的位操作</h2><ol>
<li><p><strong>利用或操作 <code>|</code> 和空格将英文字符转换为小写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;b&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">(<span class="string">&#x27;B&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p><strong>利用异或操作 <code>^</code> 和空格进行英文字符大小写互换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">(<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。</p>
</li>
<li><p><strong>判断两个数是否异号</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = -<span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">bool f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">2</span>;</span><br><span class="line">bool f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。</p>
</li>
<li><p><strong>不用临时变量交换两个数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"><span class="comment">// 现在 a = 2, b = 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>加一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">n = -~n;</span><br><span class="line"><span class="comment">// 现在 n = 2</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>减一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">n = ~-n;</span><br><span class="line"><span class="comment">// 现在 n = 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。</p>
</blockquote>
</li>
</ol>
<p>详细理解参见 <a href="https://labuladong.gitee.io/algo/4/30/116/">常用的位操作</a> 评论区</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串反转</title>
    <url>/post/8de7ec78/</url>
    <content><![CDATA[<p><strong>1、用stringBuffer或者stringBuilder自带的reverse方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、将字符串拆分为char数组后使用 <a href="https://feyl.github.io/post/2633a26/">不用临时变量交换两个数技巧</a> 依次顺序交换前后两个字符</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = charArray.length - <span class="number">1</span>; l &lt; r; l++, r--) &#123;</span><br><span class="line">        charArray[l] ^= charArray[r];<span class="comment">//采用异或</span></span><br><span class="line">        charArray[r] ^= charArray[l];</span><br><span class="line">        charArray[l] ^= charArray[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>3、stringBuffer倒序拼接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sb.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、利用栈的先进后出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    Stack stk = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        stk.push(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">        sb.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、切割递归反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(s.substring(<span class="number">1</span>)) + s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、二分递归反转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    String l = s.substring(<span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">    String r = s.substring(n / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> reverse(r) + reverse(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集</title>
    <url>/post/6b44eb7a/</url>
    <content><![CDATA[<h2 id="何为字符集？"><a href="#何为字符集？" class="headerlink" title="何为字符集？"></a>何为字符集？</h2><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>
<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>
<p>我们要将这些字符和二级制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。</p>
<p>将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>
<span id="more"></span>


<h2 id="有哪些常见的字符集？"><a href="#有哪些常见的字符集？" class="headerlink" title="有哪些常见的字符集？"></a>有哪些常见的字符集？</h2><p>常见的字符集有 ASCII、GB2312、GBK、UTF-8……。</p>
<p>不同的字符集的主要区别在于：</p>
<ul>
<li>可以表示的字符范围</li>
<li>编码方式</li>
</ul>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>
<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>
<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 <strong>128（2^7）</strong>个字符。</p>
<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 <strong>256（2^8）</strong>个字符。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" alt="ASCII字符编码"></p>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>
<p><strong>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</strong></p>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>
<blockquote>
<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>
</blockquote>
<h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>
<h3 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h3><p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>
<h3 id="Unicode-amp-UTF-8编码"><a href="#Unicode-amp-UTF-8编码" class="headerlink" title="Unicode &amp; UTF-8编码"></a>Unicode &amp; UTF-8编码</h3><p>为了更加适合本国语言，诞生了很多种字符集。</p>
<p>不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>
<p>就比如说使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>
<p>可以通过这个网站在线进行编码和解码：<a href="https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan">https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</a></p>
<p>乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>
<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>
<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>
<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>
<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>
<p>UTF-8 使用 <strong>1</strong> 到 <strong>4</strong> 个字节为每个字符编码， UTF-16 使用 <strong>2</strong> 或 <strong>4</strong> 个字节为每个字符编码，UTF-32 <strong>固定位 4</strong> 个字节为每个字符编码。</p>
<p><strong>UTF-8 可以根据不同的符号自动选择编码的长短</strong>，像<strong>英文字符只需要 1 个字节</strong>就够了，这一点 ASCII 字符集一样 。因此，<strong>对于英语字符，UTF-8 编码和 ASCII 码是相同的</strong>。</p>
<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>
<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220121232511210.png"></p>
<h2 id="MySQL-字符集"><a href="#MySQL-字符集" class="headerlink" title="MySQL 字符集"></a>MySQL 字符集</h2><p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5… 可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220121232441500.png"></p>
<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>
<p>不过，这里有一个小坑。</p>
<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>
<ul>
<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>
<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>
</ul>
<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：<br>        MySQL字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4，其中 utf8 是一个字最多占据3字节空间的编码实现；而 utf8mb4 则是一个字最多占据4字节空间的编码实现，也就是 UTF-8 的完整实现。这是由于 MySQL 在 4.1 版本开始支持 UTF-8 编码（当时参考 UTF-8草案版本为 RFC 2279）时，为2003年，并且在同年 9 月限制了其实现的 UTF-8 编码的空间占用最多为 3 字节，而 UTF-8 正式形成标准化文档(RFC 3629)是其之后。限制 UTF-8 编码实现的编码空间占用一般被认为是考虑到数据库文件设计的兼容性和读取最优化，但实际上并没有达到目的，而且在 UTF-8 编码开始出现需要存入非基本多文种平面的 Unicode 字符（例如 emoj 字符）时导致无法存入（由于 3 字节的实现只能存入基本多文种平面内的字符）。直到 2010 年在 5.5 版本推出 utf8mb4 来代替，utf8 重命名为 utf8mb3 并调整 utf8 为 utf8mb3 的别名，并不建议使用旧 utf8 编码，以此修正遗留问题。</p>
<p>因此，如果你需要存储 <code>emoji</code> 类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为 <code>utf8mb4</code>  而不是 <code>utf8</code>  ，要不然存储的时候就会报错了。</p>
<p>演示一下吧！（环境：MySQL 5.7+）</p>
<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">66</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`, `name`, `phone`, `password`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">&#x27;A00003&#x27;</span>, <span class="string">&#x27;guide哥😘😘😘&#x27;</span>, <span class="string">&#x27;181631312312&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Incorrect string value: &#x27;\xF0\x9F\x98\x98\xF0\x9F...&#x27; for column &#x27;name&#x27; at row 1</span><br></pre></td></tr></table></figure>



<p>文章转载自：<a href="https://javaguide.cn/database/%E5%AD%97%E7%AC%A6%E9%9B%86/">https://javaguide.cn/database/%E5%AD%97%E7%AC%A6%E9%9B%86/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟</title>
    <url>/post/d1f7904c/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模拟就是用计算机来模拟题目中要求的操作。</p>
<p>模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。</p>
<p>模拟算法是一种最基本的算法思想，是对程序员基本编程能力的一种考查，其解决方法就是<strong>根据题目给出的规则对题目要求的相关过程进行编程模拟。</strong>在解决模拟类问题时，需要注意字符串处理、<strong>特殊情况处理</strong>和<strong>对题目意思的理解</strong>。在程序设计过程中，可使用随机函数来模拟自然界中发生的不可预测情况。在解题时，需要<strong>仔细分析题目给出的规则</strong>，要<strong>尽可能地做到全面地考虑所有可能出现的情况</strong>，这是解模拟类问题的关键点之一。</p>
<span id="more"></span>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>写模拟题时，遵循以下的建议有可能会提升做题速度：</p>
<ul>
<li>在动手写代码之前，在草纸上尽可能地写好要实现的流程。</li>
<li>在代码中，<strong>尽量把每个部分模块化，</strong>写成函数、结构体或类。</li>
<li><strong>对于一些可能重复用到的概念，可以统一转化，方便处理</strong>：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。</li>
<li>调试时<strong>分块调试</strong>。模块化的好处就是可以方便的单独调某一部分。</li>
<li>写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。</li>
</ul>
<p>实际上，上述步骤在解决其它类型的题目时也是很有帮助的。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></td>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/">官方题解</a><br><a href="https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/">优化版竖式(打败99.4%)</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">C++ 详细题解</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">Spiral Matrix II （模拟法，设定边界，代码简短清晰）</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/post/9a0369ec/</url>
    <content><![CDATA[<h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><p>首先，我们需要了解布隆过滤器的概念。</p>
<p>布隆过滤器（<strong>Bloom Filter</strong>）是一个叫做 Bloom 的老哥于 1970 年提出的。我们<strong>可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构</strong>。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207002507111.png" style="zoom:80%;" />

<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p>
<p>总结：<strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</strong></p>
<h2 id="布隆过滤器的原理介绍"><a href="#布隆过滤器的原理介绍" class="headerlink" title="布隆过滤器的原理介绍"></a>布隆过滤器的原理介绍</h2><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>举个简单的例子：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207002716080.png" style="zoom:80%;" />

<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>
<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h2 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h2><p><strong>判断给定数据是否存在：</strong>比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）、邮箱的垃圾邮件过滤、黑名单功能等等。</p>
<p><strong>去重：</strong>比如爬给定网址的时候对已经爬取过的 URL 去重。</p>
<h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><h3 id="通过-Java-编程手动实现布隆过滤器"><a href="#通过-Java-编程手动实现布隆过滤器" class="headerlink" title="通过 Java 编程手动实现布隆过滤器"></a>通过 Java 编程手动实现布隆过滤器</h3><p>我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。</p>
<p>如果你想要手动实现一个的话，你需要：</p>
<ol>
<li>一个合适大小的位数组保存数据</li>
<li>几个不同的哈希函数</li>
<li>添加元素到位数组（布隆过滤器）的方法实现</li>
<li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li>
</ol>
<p>下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建 6 个不同的哈希函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SEEDS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> SimpleHash[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBloomFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> SimpleHash(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.set(f.hash(value), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(<span class="keyword">int</span> cap, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">            <span class="keyword">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == <span class="keyword">null</span>) ? <span class="number">0</span> : Math.abs(seed * (cap - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String value1 = <span class="string">&quot;https://javaguide.cn/&quot;</span>;</span><br><span class="line">	String value2 = <span class="string">&quot;https://github.com/Snailclimb&quot;</span>;</span><br><span class="line">	MyBloomFilter filter = <span class="keyword">new</span> MyBloomFilter();</span><br><span class="line">	System.out.println(filter.contains(value1));</span><br><span class="line">	System.out.println(filter.contains(value2));</span><br><span class="line">	filter.add(value1);</span><br><span class="line">	filter.add(value2);</span><br><span class="line">	System.out.println(filter.contains(value1));</span><br><span class="line">	System.out.println(filter.contains(value2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer value1 = <span class="number">13423</span>;</span><br><span class="line">    Integer value2 = <span class="number">22131</span>;</span><br><span class="line">    MyBloomFilter filter = <span class="keyword">new</span> MyBloomFilter();</span><br><span class="line">    System.out.println(filter.contains(value1));</span><br><span class="line">    System.out.println(filter.contains(value2));</span><br><span class="line">    filter.add(value1);</span><br><span class="line">    filter.add(value2);</span><br><span class="line">    System.out.println(filter.contains(value1));</span><br><span class="line">    System.out.println(filter.contains(value2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<h3 id="利用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#利用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="利用 Google 开源的 Guava 中自带的布隆过滤器"></a>利用 Google 开源的 Guava 中自带的布隆过滤器</h3><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">        Funnels.integerFunnel(),</span><br><span class="line">        <span class="number">1500</span>,</span><br><span class="line">        <span class="number">0.01</span>);</span><br><span class="line">    <span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">    filter.put(<span class="number">1</span>);</span><br><span class="line">    filter.put(<span class="number">2</span>);</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p>
<h2 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：<a href="https://redis.io/modules">https://redis.io/modules</a></p>
<p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a> 其他还有：</p>
<ul>
<li><a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter">redis-lua-scaling-bloom-filter（lua 脚本实现）</a></li>
<li><a href="https://github.com/seomoz/pyreBloom">pyreBloom（Python 中的快速 Redis 布隆过滤器）</a></li>
<li>……</li>
</ul>
<p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p>
<h3 id="使用-Docker-安装"><a href="#使用-Docker-安装" class="headerlink" title="使用 Docker 安装"></a>使用 Docker 安装</h3><p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！直接在 Google 搜索 <strong>docker redis bloomfilter</strong> 然后在排除广告的第一条搜素结果就找到了我们想要的答案，具体地址：<a href="https://hub.docker.com/r/redislabs/rebloom/">https://hub.docker.com/r/redislabs/rebloom/</a> 。</p>
<p><strong>具体操作如下：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">➜  ~ docker <span class="keyword">run</span><span class="bash"> -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span></span><br><span class="line">➜  ~ docker exec -it redis-redisbloom bash</span><br><span class="line">root@<span class="number">21396</span>d02c252:/data<span class="comment"># redis-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常用命令一览"><a href="#常用命令一览" class="headerlink" title="常用命令一览"></a>常用命令一览</h3><blockquote>
<p>注意： key：布隆过滤器的名称，item：添加的元素。</p>
</blockquote>
<ol>
<li><code>BF.ADD</code>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD &#123;key&#125; &#123;item&#125;</code>。</li>
<li><code>BF.MADD</code>：将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD &#123;key&#125; &#123;item&#125; [item ...]</code> 。</li>
<li><code>BF.EXISTS</code>：确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS &#123;key&#125; &#123;item&#125;</code>。</li>
<li><code>BF.MEXISTS</code> ：确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS &#123;key&#125; &#123;item&#125; [item ...]</code>。</li>
</ol>
<p>另外， <code>BF.RESERVE</code> 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<p><code>BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion]</code> 。</p>
<p>下面简单介绍一下每个参数的具体含义：</p>
<ul>
<li>key：布隆过滤器的名称</li>
<li>error_rate：期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li>
<li>capacity：过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ul>
<p>可选参数：</p>
<ul>
<li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li>
</ul>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter github</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>



<p>文章总结来源：</p>
<p><a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">布隆过滤器</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>理解linux中的file descriptor(文件描述符)</title>
    <url>/post/1e8930fb/</url>
    <content><![CDATA[<p>file descriptor（以下简称fd）又叫文件描述符，它是一个抽象的指示符，用一个整数表示（非负整数）。它指向了由系统内核维护的一个file table中的某个条目（entry）。这个解释可能过于抽象，不过在正式详细介绍fd之前，有必要先了解用户程序和系统内核之间的工作过程。</p>
<p>注：本文描述的所有场景仅限于类unix系统环境，在windows中叫file handle（句柄）。</p>
<span id="more"></span>
<h2 id="User-space-amp-Kernel-space"><a href="#User-space-amp-Kernel-space" class="headerlink" title="User space &amp; Kernel space"></a>User space &amp; Kernel space</h2><p>现代操作系统会把内存划分为2个区域，分别为Use space(用户空间) 和 Kernel space(内核空间)。用户的程序在User space执行，系统内核在Kernel space中执行。</p>
<p>用户的程序没有权限直接访问硬件资源，但系统内核可以。比如读写本地文件需要访问磁盘，创建socket需要网卡等。因此用户程序想要读写文件，必须要向内核发起读写请求，这个过程叫system call。</p>
<p>内核收到用户程序system call时，负责访问硬件，并把结果返回给程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">fis.read(buf);</span><br></pre></td></tr></table></figure>

<p>上面代码的流程如下图所示：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126181103666.png" style="zoom:50%;" />



<h2 id="File-Descriptor"><a href="#File-Descriptor" class="headerlink" title="File Descriptor"></a>File Descriptor</h2><p>上面简单介绍了User space和Kernel space，这对于理解fd有很大的帮助。fd会存在，就是因为用户程序无法直接访问硬件，因此当程序向内核发起system call打开一个文件时，在用户进程中必须有一个东西标识着打开的文件，这个东西就是fd。</p>
<h3 id="file-tables"><a href="#file-tables" class="headerlink" title="file tables"></a>file tables</h3><p>和fd相关的一共有3张表，分别是file descriptor、file table、inode table，如下图所示。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126181152940.png"></p>
<ul>
<li><p>file descriptors</p>
<p>file descriptors table由用户进程所有，每个进程都有一个这样的表，这里记录了进程打开的文件所代表的fd，fd的值映射到file table中的条目(entry)。</p>
<p>另外，每个进程都会预留3个默认的fd: stdin、stdout、stderr;它们的值分别是0、1，2。</p>
<table>
<thead>
<tr>
<th align="center">Integer value</th>
<th align="center">Name</th>
<th align="center">symbolic constant</th>
<th align="center">file stream</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
</li>
<li><p>file table</p>
<p>file table是全局唯一的表，由系统内核维护。这个表记录了所有进程打开的文件的状态（是否可读、可写等状态），同时它也映射到inode table中的entry。</p>
</li>
<li><p>inode table</p>
<p>inode table同样是全局唯一的，它指向了真正的文件地址（磁盘中的位置），每个entry全局唯一。</p>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当程序向内核发起system call <code>open()</code>，内核将会</p>
<ol>
<li>允许程序请求</li>
<li>创建一个entry插入到file table，并返回file descriptor</li>
<li>程序把fd插入到fds中。</li>
</ol>
<p>当程序再次发起<code>read()</code>system call时，需要把相关的fd传给内核，内核定位到具体的文件(fd –&gt; file table –&gt; inode table)向磁盘发起读取请求，再把读取到的数据返回给程序处理。</p>
<p>下面是<code>read</code>这个函数的定义，第一个参数<code>fd</code>即file descriptor。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同样的，<code>write</code>system call函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从上面的结果来看，fd就是file table的一个索引，指向了file table中的entry。</p>
<h2 id="查看进程的file-descriptors"><a href="#查看进程的file-descriptors" class="headerlink" title="查看进程的file descriptors"></a>查看进程的file descriptors</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>linux系统可以通过<code>/proc/pid/fd</code>文件夹查看进程的fd，比如我的redis进程id为96104，执行以下命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /proc/96104/fd</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126182056967.png" style="zoom:67%;" />

<p>上图中的数字即fd。</p>
<h3 id="mac-os-x"><a href="#mac-os-x" class="headerlink" title="mac os x"></a>mac os x</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p pid</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126194304823.png" style="zoom: 67%;" />

<h2 id="操作file-descriptors"><a href="#操作file-descriptors" class="headerlink" title="操作file descriptors"></a>操作file descriptors</h2><p>下面是一些系统函数。当程序发起system call，大多需要传递fd到这些函数中，kernel去访问具体的资源。</p>
<ul>
<li>open()</li>
<li>read()</li>
<li>write()</li>
<li>select()</li>
<li>poll()</li>
</ul>
<p>更多系统函数可以参考维基百科<a href="https://en.wikipedia.org/wiki/File_descriptor">File Descriptor</a>，整理了大量常见的函数</p>
<h2 id="Java中的File-Descriptor"><a href="#Java中的File-Descriptor" class="headerlink" title="Java中的File Descriptor"></a>Java中的File Descriptor</h2><p>Java封装了<code>FileDescriptor</code>类表示fd，FileInputStrem和FileOutputStream中都会持有这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> fd;  </span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以看到fd和之前描述的一致，是一个整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* File Descriptor - handle to the open file */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">      security.checkRead(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;Invalid file path&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fd在输入输出流的构造器中创建，JVM会发起system call <code>open()</code>初始化资源并返回fd。</p>
<p><strong>stand stream fd</strong></p>
<p>下面代码可以查看标准输入/输出/错误流中的fd，用debug启动即可在面板中看到fd的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FDTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedInputStream in = (BufferedInputStream) System.in;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        PrintStream err = System.err;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192812494.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192838936.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192905490.png" style="zoom:50%;" />

<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220126192934419.png" style="zoom:50%;" />





<p>文章来源：<a href="https://wiyi.org/linux-file-descriptor.html">理解linux中的file descriptor(文件描述符)</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索</title>
    <url>/post/cb5e0eb8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记忆化搜索是一种典型的<strong>空间换时间</strong>的思想。</p>
<p>一般说来，动态规划总要遍历所有的状态，而<strong>搜索可以排除一些无效状态</strong>。更重要的是<strong>搜索</strong>还可以<strong>剪枝</strong>，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。<strong>记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解</strong>了。这种方法综合了搜索和动态规划两方面的优点，因而还是很有实用价值的。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>函数有返回值</li>
<li>函数返回结果和输入参数有关，和其他全局状态无关</li>
<li>参数列表中传入哈希表或者其他用于记录计算结果的数据结构</li>
</ul>
<p>在递归函数中, 在函数返回前，记录函数的返回结果。在下一次以同样参数访问函数时直接返回记录下的结果。也就是对递归树进行剪枝，遇到已经计算过的节点就不再继续往下计算，直接返回储存在哈希表或者其他数据结构中的值。</p>
<blockquote>
<p>本质上是自顶向下的动态规划加备忘录。</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><table>
<thead>
<tr>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/multiply-strings/"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></a></td>
<td><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">官方题解</a><br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/hua-jie-suan-fa-70-pa-lou-ti-by-guanpengchn/">画解算法：70. 爬楼梯</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></td>
<td><a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/">「手画图解」剖析三种解法: DFS, BFS, 动态规划 </a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></td>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/329-ju-zhen-zhong-de-zui-chang-di-zeng-l-64yg/">DFS（记忆化搜索）</a></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td>
<td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/">官方题解</a><br/><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">【宫水三叶】一题三解 :「DFS/BFS」&amp;「贪心（位运算）」</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础知识</title>
    <url>/post/1ad06ab1/</url>
    <content><![CDATA[<h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2><p><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p>
<p><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p>
<p><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</p>
<p><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</p>
<span id="more"></span>
<p>数据库系统基本构成如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" alt="数据库系统基本构成"></p>
<h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2><p><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</p>
<p><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</p>
<p><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</p>
<blockquote>
<p>例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</p>
</blockquote>
<p><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</p>
<p><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p>
<p><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。</p>
<blockquote>
<p>比如关系 工人（工号，身份证号，姓名，性别，部门）， 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</p>
</blockquote>
<p><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。</p>
<blockquote>
<p>比如关系 学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</p>
</blockquote>
<h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h2><ul>
<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2 id="为什么不推荐使用外键与级联"><a href="#为什么不推荐使用外键与级联" class="headerlink" title="为什么不推荐使用外键与级联?"></a>为什么不推荐使用外键与级联?</h2><p>对于外键和级联，阿里巴巴开发手册这样说到：</p>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>​        说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群</strong>；<strong>级联更新是强阻塞，存在数据库更新风暴的风险</strong>；<strong>外键影响数据库的插入速度</strong>。</p>
<p>为什么不要用外键呢？大部分人可能会这样回答：</p>
<ol>
<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦，测试数据极为不方便；b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>
<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增、删、更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>
<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>
<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>
<li>……</li>
</ol>
<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>
<ol>
<li>保证了数据库数据的一致性和完整性；</li>
<li>级联操作方便，减轻了程序代码量；</li>
<li>……</li>
</ol>
<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>
<h2 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h2><p>做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p>
<p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p>
<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是<strong>多对多（M: N）</strong>。另外，还有其他两种关系是：<strong>1 对 1（1:1）</strong>、<strong>1 对多（1: N）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png" alt="ER图示例"></p>
<p>试着将上面的 ER 图转换成数据库实际的关系模型（实际设计中，我们通常会将任课教师也作为一个实体来处理）：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png" alt="关系模型"></p>
<h2 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗?"></a>数据库范式了解吗?</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
<h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。</p>
<blockquote>
<p>表：学号、课程号、姓名、学分</p>
</blockquote>
<p>这个表明显说明了两个事务：学生信息，课程信息；由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p>
<p><strong>可能会存在问题：</strong></p>
<ul>
<li>数据冗余：每条记录都含有相同信息；</li>
<li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li>
<li>插入异常：学生未选课，无法记录进数据库；</li>
<li>更新异常：调整课程学分，所有行都调整。</li>
</ul>
<p>解决办法：将不符合第二范式的数据库表进行拆分。</p>
<p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p>
<h3 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h3><p><strong>函数依赖（Functional dependency）</strong>：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</p>
<p><strong>部分函数依赖（Partial functional dependency）</strong>：如果 X→Y，并且存在 X 的一个真子集 X<del>0</del>，使得 X<del>0</del>→Y，则称 Y 对 X 部分函数依赖。</p>
<blockquote>
<p>比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</p>
</blockquote>
<p><strong>完全函数依赖（Full functional dependency）</strong>：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</p>
<blockquote>
<p>比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt; (姓名)不成立，（班级）-&gt; (姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</p>
</blockquote>
<p><strong>传递函数依赖（Transitive functional dependency）</strong>： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传<strong>递函数依赖会导致数据冗余和异常</strong>。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</p>
<blockquote>
<p>比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</p>
</blockquote>
<p><strong>3NF(第三范式)</strong></p>
<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>
<p><strong>总结</strong></p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
<h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p>
<p>〖例〗：如订单表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>
<p>在<code>Rose 2002</code>中，规定列有两种类型：<strong>数据列</strong>和<strong>计算列</strong>。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。</p>
<h3 id="范式化设计和反范式化设计的优缺点"><a href="#范式化设计和反范式化设计的优缺点" class="headerlink" title="范式化设计和反范式化设计的优缺点"></a>范式化设计和反范式化设计的优缺点</h3><p><strong>范式化</strong></p>
<p>优点：</p>
<ul>
<li>可以尽量的减少数据冗余</li>
<li>数据表更新快体积小</li>
<li>范式化的更新操作比反范式化更快</li>
<li>范式化的表通常比反范式化更小</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于查询需要对多个表进行关联导致性能降低</li>
<li>更难进行索引优化</li>
</ul>
<p><strong>反范式化</strong></p>
<p>优点：</p>
<ul>
<li>可以减少表的关联</li>
<li>可以更好的进行索引优化</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在数据冗余及数据维护异常</li>
<li>对数据的修改需要更多的成本</li>
</ul>
<h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h2><p>可以把存储过程看成是一些 <strong>SQL 语句的集合，中间加了点逻辑控制语句</strong>。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候就可以写有一个存储过程，这样也方便了下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为<strong>存储过程是预编译过的</strong>。</p>
<p><strong>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</strong></p>
<blockquote>
<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>
<p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<h2 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h2><h3 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h3><p><strong>drop（丢弃数据）</strong>：<code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</p>
<p><strong>truncate（清空数据）</strong>：<code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</p>
<p><strong>delete（删除数据）</strong>：<code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</p>
<p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p>
<h3 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="属于不同的数据库语言"></a>属于不同的数据库语言</h3><p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>
<p><strong>DML 语句和 DDL 语句区别：</strong></p>
<ul>
<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>
<li>DDL 是数据定义语言（Data Definition Language）的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>
</ul>
<h3 id="执行速度不同"><a href="#执行速度不同" class="headerlink" title="执行速度不同"></a>执行速度不同</h3><p>一般来说：drop&gt;truncate&gt;delete</p>
<h2 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h2><ol>
<li><strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong>：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong>：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong>：包括编程、测试和试运行。</li>
<li><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护。</li>
</ol>
<p>文章总结来源：</p>
<p><a href="https://javaguide.cn/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97">数据库基础知识</a></p>
<p><a href="https://segmentfault.com/a/1190000013695030">数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/post/f89cb603/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>红黑树是一种<strong>自平衡的二叉查找树</strong>，是一种高效的查找树。它是由 Rudolf Bayer 于1978年发明，在当时被称为 <strong>对称二叉 B 树(symmetric binary B-trees)<strong>。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的 <strong>红黑树</strong>。红黑树具有良好的效率，它</strong>可在</strong> <code>O(logN)</code> <strong>时间内完成查找、增加、删除等操作</strong>。因此，红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。考虑到红黑树是一种被广泛应用的数据结构，所以我们很有必要去弄懂它。</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207175122084.png" style="zoom:80%;" />

<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>学过二叉查找树的同学都知道，普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些<strong>自平衡的查找树</strong>，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，<strong>将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态</strong>。以红黑树为例，红黑树通过如下的性质定义实现自平衡：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</li>
</ol>
<p>有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的节点进行增删查操作时，效率也会大大降低。这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证<strong>任意节点到其每个叶子节点路径最长不会超过最短路径的2倍</strong>。原因如下：</p>
<p>当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明一下，请看下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207180835565.png" style="zoom:80%;" />

<p>上图画出了从根节点 M 出发的到其叶子节点的最长和最短路径。这里偷懒只画出了两条最长路径，实际上最长路径有4条，分别为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">M -&gt; Q -&gt; O -&gt; N</span><br><span class="line">M -&gt; Q -&gt; O -&gt; p</span><br><span class="line">M -&gt; Q -&gt; Y -&gt; X</span><br><span class="line">M -&gt; Q -&gt; Y -&gt; Z</span><br></pre></td></tr></table></figure>

<p>长度为4，最短路径为 <code>M -&gt; E</code>，长度为2。最长路径的长度正好为最短路径长度的2倍。</p>
<p>前面说了关于红黑树的一些性质，这里还需要补充一些其他方面的东西。在红黑树简介一节中说到红黑树被发明出来的时候并不叫 <code>红黑树</code>，而是叫做 <code>对称二叉 B 树</code>，从名字中可发现红黑树和 B 树（这里指的是<strong>2-3树</strong>）或许有一定的关联，事实也正是如此。如果对红黑树的性质稍加修改，就能让红黑树和B树形成一一对应的关系。关于红黑树和 B 树关系的细节这里不展开说明了，有兴趣的同学可以参考<a href="https://book.douban.com/subject/19952400/">《算法》</a>第4版，那本书上讲的很透彻。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。</p>
<h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为左旋和右旋，<strong>左旋是将某个节点旋转为其右孩子的左孩子</strong>，而<strong>右旋是节点旋转为其左孩子的右孩子</strong>。这话听起来有点绕，所以还是请看下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182356324.png" style="zoom:80%;" />

<p>上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：</p>
<ol>
<li>将节点 M 的左孩子引用指向节点 E 的右孩子</li>
<li>将节点 E 的右孩子引用指向节点 M，完成旋转</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182602018.png" style="zoom:80%;" />

<p>上面分析了右旋操作，左旋操作与此类似，大家有兴趣自己画图试试吧，这里不再赘述了。旋转操作本身并不复杂，这里先分析到这吧。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。</p>
<p>接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：</p>
<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207182903027.png" style="zoom:80%;" />

<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207183215154.png" style="zoom:80%;" />

<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所以性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152056319752.jpg" style="zoom:80%;" />

<h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><p>N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152057064115.jpg" style="zoom:80%;" />

<h4 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h4><p>N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152057476644.jpg" style="zoom:80%;" />

<h4 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h4><p>上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果<strong>叔叔节点为红色，直接变色</strong>即可。如果<strong>叔叔节点为黑色，则需要旋转，再交换颜色</strong>。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152052502152.jpg" style="zoom:80%;" />

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的<strong>前驱（该节点左子树中最大的节点）</strong>或者<strong>后继（该节点右子树中最小的节点）</strong>，然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。</p>
<p>红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。</p>
<p>在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为 <code>X</code>（至多只有一个孩子节点），其孩子节点为 <code>N</code>，<code>X</code> 的兄弟节点为 <code>S</code>，<code>S</code> 的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 <code>X</code> 被删除，节点 <code>N</code> 替换 <code>X</code> 的基础上进行的。这里说明把被删除的节点 <code>X</code> 特地拎出来说一下的原因是防止大家误以为节点 <code>N</code> 会被删除，不然后面就会看不明白。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15272593488180.jpg" style="zoom:80%;" />

<p>在上面的基础上，接下来就可以展开讨论了。红黑树删除有6种情况，分别是：</p>
<h4 id="情况一-1"><a href="#情况一-1" class="headerlink" title="情况一"></a>情况一</h4><blockquote>
<p>N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。</p>
</blockquote>
<p>上面是维基百科中关于红黑树删除的情况一说明，由于没有配图，看的有点晕。经过思考，我觉得可能会是下面这种情形：</p>
<p>要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。</p>
<p>可能还有其他情形，大家如果知道，烦请告知。</p>
<h4 id="情况二-1"><a href="#情况二-1" class="headerlink" title="情况二"></a>情况二</h4><p>S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（<code>P -&gt; X -&gt; N</code>），现在只剩两个了（<code>P -&gt; N</code>）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152097130545.jpg" style="zoom:80%;" />

<h4 id="情况三-1"><a href="#情况三-1" class="headerlink" title="情况三"></a>情况三</h4><p>N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152097574115.jpg" style="zoom:80%;" />

<h4 id="情况四-1"><a href="#情况四-1" class="headerlink" title="情况四"></a>情况四</h4><p>N 的父节点为红色，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以把 S 染成红色，把P染成黑色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致且经过 P 的路径黑色节点数不变。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220207194653272.png" style="zoom:80%;" />

<h4 id="情况五-1"><a href="#情况五-1" class="headerlink" title="情况五"></a>情况五</h4><p>S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152098446251.jpg" style="zoom:80%;" />

<h4 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h4><p>S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：</p>
<ol>
<li>该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。</li>
<li>该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。</li>
</ol>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152098765266.jpg" style="zoom:80%;" />

<h4 id="删除总结"><a href="#删除总结" class="headerlink" title="删除总结"></a>删除总结</h4><p>红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/15152095299211.jpg" style="zoom:80%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树是一种重要的二叉树，应用广泛，但在很多数据结构相关的书本中出现的次数并不多。很多书中要么不说，要么就一笔带过，并不会进行详细的分析，这可能是因为红黑树比较复杂的缘故。我在学习红黑树的时候也找了很多资料，但总体感觉讲的都不太好。尤其是在我学习删除操作的时候，很多资料是实在人看不下去，看的我很痛苦。直到我看到维基百科上关于<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a>的分析时，很是欣喜。这篇文章分析的很有条理，言简意赅，比很多资料好了太多。本文对红黑树的分析也主要参考了维基百科中的红黑树分析，并对维基百科中容易让人产生疑问和误解的地方进行了说明。同时维基百科中文版红黑树文中的图片较为模糊，这里我重新进行了绘制。需要说明的是，维基百科中文版无法打开了，文中关于维基百科的链接都是英文版的。另外在给大家推荐一个数据结构可视化的网站，里面包含常见数据结构可视化过程，地址为：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">t.cn/RZFgryr</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/19952400/">《算法》第四版</a></li>
<li> <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树 – 维基百科</a></li>
</ul>
<p>文章转载来源：<a href="https://www.tianxiaobo.com/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">红黑树详细分析</a></p>
<p>推荐阅读：</p>
<p><a href="https://zhuanlan.zhihu.com/p/24367771">红黑树深入剖析及Java实现</a></p>
<p><a href="https://brianway.github.io/2016/10/14/algorithms-data-structures-2/">常见数据结构(二)-树(二叉树，红黑树，B树)</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>自平衡树</tag>
        <tag>查找树</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目学习</title>
    <url>/post/767bf05/</url>
    <content><![CDATA[<h2 id="开源项目结构"><a href="#开源项目结构" class="headerlink" title="开源项目结构"></a>开源项目结构</h2><h3 id="阿里巴巴-Java开发手册-工程结构-应用分层"><a href="#阿里巴巴-Java开发手册-工程结构-应用分层" class="headerlink" title="阿里巴巴 Java开发手册-工程结构-应用分层"></a>阿里巴巴 Java开发手册-工程结构-应用分层</h3><ol>
<li><p>【推荐】根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示， <strong>默认上层依赖于下层</strong>，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层 （Controller 层），也可以直接依赖于 Service 层，依此类推：</p>
<span id="more"></span>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211100733345.png" style="zoom: 75%;" />

<ul>
<li>开放 API 层：可直接封装 Service 接口暴露成 <strong>RPC 接口</strong>；通过 Web 封装成 <strong>http 接口</strong>；<strong>网关控制</strong>层等。</li>
<li>终端显示层：各个端的<strong>模板渲染并执行</strong>显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li>
<li>Web 层：主要是<strong>对访问控制进行转发</strong>，<strong>各类基本参数校验</strong>，或者<strong>不复用的业务简单处理</strong>等。</li>
<li>Service 层：相对<strong>具体的业务逻辑</strong>服务层。</li>
<li>Manager 层：<strong>通用业务处理</strong>层，它有如下特征：<ol>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</li>
<li>对 Service 层<strong>通用</strong>能力的下沉，如缓存方案、中间件通用处理。</li>
<li>与 DAO 层交互，对多个 DAO 的组合复用。</li>
</ol>
</li>
<li>DAO 层：<strong>数据访问</strong>层，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。</li>
<li>第三方服务：包括<strong>其它部门 RPC 服务接口</strong>，基础平台，<strong>其它公司的 HTTP 接口</strong>，如淘宝开放平台、支付宝付款服务、高德地图服务等。</li>
<li>外部数据接口：<strong>外部（应用）数据存储服务提供的接口</strong>，多见于<strong>数据迁移场景</strong>中。</li>
</ul>
</li>
<li><p>【参考】分层异常处理规约：</p>
<ul>
<li>在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 <code>catch</code>，使用 <code>catch(Exception e)</code>方式，并 <code>throw new DAOException(e)</code>，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。</li>
<li>在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息， 相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是 单独部署，则采用与 Service 一致的处理方式。</li>
<li>Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面， 尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</li>
</ul>
</li>
<li><p>【参考】分层领域模型规约：</p>
<ul>
<li>DO（Data Object）：此对象<strong>与数据库表结构一一对应</strong>，通过 DAO 层向上传输数据源对象。</li>
<li>DTO（Data Transfer Object）：数据传输对象，<strong>Service 或 Manager 向外传输</strong>的对象。</li>
<li>BO（Business Object）：业务对象，可以<strong>由 Service 层输出</strong>的<strong>封装业务逻辑</strong>的对象。</li>
<li>Query：数据查询对象，各层<strong>接收上层的查询请求</strong>。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</li>
<li>VO（View Object）：显示层对象，通常是 <strong>Web 向模板渲染引擎层传输</strong>的对象。</li>
</ul>
</li>
</ol>
<h3 id="实际项目代码结构"><a href="#实际项目代码结构" class="headerlink" title="实际项目代码结构"></a>实际项目代码结构</h3><p><strong>通常的项目结构</strong></p>
<blockquote>
<p><strong>首先说在前面的是</strong>：这东西并没有一套通用的标准，不同公司或者团队的使用习惯和规范也不尽相同。</p>
</blockquote>
<p>以当下非常火热的Spring Boot典型项目结构为例，创建出来的项目应该总体分为三大层：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211103507042.png" style="zoom:80%;" />

<ul>
<li><code>项目根目录/src/main/java</code>：放置项目Java<strong>源代码</strong></li>
<li><code>项目根目录/src/main/resources</code>：放置项目<strong>静态资源和配置文件</strong></li>
<li><code>项目根目录/src/test/java</code>：放置项目<strong>测试用例代码</strong></li>
</ul>
<p>而位于 <code>/src/main/java</code> 目录下的Java源代码的组织结构大家比较关心，这地方也只能给出一个通常典型的结构，毕竟不同项目和团队实践不一样，稍许有区别，但整体安排应该差不多。而且如果是<strong>多模块</strong>的项目的话，下面的结构应该只对应其中一个模块，其他模块的代码组织也大致差不多。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211103646545.png" style="zoom: 65%;" />

<p>各个目录详细介绍：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|<span class="built_in">_</span>annotation：放置项目自定义注解</span><br><span class="line">|<span class="built_in">_</span>aspect：放置切面代码</span><br><span class="line">|<span class="built_in">_</span>config：放置配置类</span><br><span class="line">|<span class="built_in">_</span>constant：放置常量、枚举等定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>consist：存放常量定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>enums：存放枚举定义</span><br><span class="line">|<span class="built_in">_</span>controller：放置控制器代码</span><br><span class="line">|<span class="built_in">_</span>filter：放置一些过滤、拦截相关的代码</span><br><span class="line">|<span class="built_in">_</span>mapper：放置数据访问层代码接口</span><br><span class="line">|<span class="built_in">_</span>model：放置数据模型代码</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>entity：放置数据库实体对象定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>dto：存放数据传输对象定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>vo：存放显示层对象定义</span><br><span class="line">|<span class="built_in">_</span>service：放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>intf：存放业务逻辑接口定义</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>impl：存放业务逻辑实际实现</span><br><span class="line">|<span class="built_in">_</span>utils：放置工具类和辅助代码</span><br></pre></td></tr></table></figure>

<p>然后接下来 <code>/src/main/resources</code> 目录，里面主要存放静态配置文件和页面静态资源等东西：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">|<span class="built_in">_</span>mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><br><span class="line">|<span class="built_in">_</span>static：存放网页静态资源，比如下面的js/css/img</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>js：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>css：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>img：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>font：</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>等等</span><br><span class="line">|<span class="built_in">_</span>template：存放网页模板，比如thymeleaf/freemarker模板等</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>header</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>sidebar</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>bottom</span><br><span class="line">   |<span class="built_in">_</span><span class="built_in">_</span>XXX.html等等</span><br><span class="line">|<span class="built_in">_</span>application.yml       基本配置文件</span><br><span class="line">|<span class="built_in">_</span>application-dev.yml   开发环境配置文件</span><br><span class="line">|<span class="built_in">_</span>application-test.yml  测试环境配置文件</span><br><span class="line">|<span class="built_in">_</span>application-prod.yml  生产环境配置文件</span><br></pre></td></tr></table></figure>

<p>当然，这地方估计有一个<strong>很多人都会纠结的</strong>关于<code>DTO/VO/DO</code>等<strong>数据模型定义</strong>的区分。</p>
<p>这在《阿里巴巴Java开发手册》中倒是做了一个所谓的严格区分，如上所示。</p>
<p>实际项目开发时，没有必要刻意照搬去定义这么多层对象，这样后续做对象转换非常麻烦。出于简单起见，个人觉得，只要保证业务逻辑层 <code>Service</code> 和数据库 <code>DAO</code> 层的操作对象严格划分出来，确保互相不渗透，不混用，问题应该就不大。</p>
<blockquote>
<p>比如在我上面举例的这个项目的代码结构中，<code>Service</code>层处理的对象都定义在了<code>dto</code>包里，而<code>DAO</code>层处理的对象都放在了<code>entity</code>包里了。</p>
</blockquote>
<h3 id="项目结构划分总结"><a href="#项目结构划分总结" class="headerlink" title="项目结构划分总结"></a>项目结构划分总结</h3><p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211123707245.png" style="zoom: 75%;" />

<p>对应代码目录的流转逻辑就是：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211124408586.png" style="zoom:65%;" />

<p><strong>每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</strong>。</p>
<p><strong>一些注意事项</strong></p>
<ol>
<li><code>Contorller </code> 层参数传递建议不要使用 <code>HashMap</code>，建议使用数据模型定义。</li>
<li><code>Controller</code> 层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到 <code>Service</code> 层代码中去做。</li>
<li><code>Service</code> 层做实际业务逻辑，可以按照功能模块做好定义和区分，相互可以调用。</li>
<li>功能模块 <code>Service</code> 之间引用时，建议不要渗透到 <code>DAO</code> 层（或者 <code>mapper</code> 层），基于 <code>Service</code> 层进行调用和复用比较合理。</li>
<li>业务逻辑层 <code>Service</code> 和数据库 <code>DAO</code> 层的操作对象不要混用。<code>Controller </code> 层的数据对象不要直接渗透到 <code>DAO</code>层（或者 <code>mapper</code> 层）；同理数据表实体对象 <code>Entity</code> 也不要直接传到 <code>Controller</code> 层进行输出或展示。</li>
</ol>
<h2 id="如何学习开源项目？"><a href="#如何学习开源项目？" class="headerlink" title="如何学习开源项目？"></a>如何学习开源项目？</h2><p><a href="https://juejin.cn/post/6844904067257352205">为什么要学习源码？学习源码对我们有用吗？</a></p>
<h3 id="学习的价值"><a href="#学习的价值" class="headerlink" title="学习的价值"></a>学习的价值</h3><p>总结起来，学习开源项目的价值主要包括以下几点：</p>
<ul>
<li><p>专业水平的提升</p>
<p>很多通用的专业知识，在专业领域内去到哪个公司都能通用，特别是底层方面的知识，可以在开源项目中学到，比如多线程处理、网络通信、操作系统处理等。 举个例子，通过学习Redis 的 RDB 持久化模式的“会将当前内存中的数据库快照保存到磁盘文件中”，可以学习到其实就是在操作系统fork一个子进程来实现，再继续深入的话，就涉及到父子进程机制， copy-on-write 技术。这些专业知识之间是可以联系起来的并且像一颗大树一样自我生长，但是当没理解透彻，自然没法产生联系，也就不能够自我生长了。当我们对开源项目的关键的点理解清晰，知识也随着自我生长，也就如滚雪球一样可以滚起来了。</p>
</li>
<li><p>解决问题能力的提升</p>
<p>通过学习开源项目的实现，出现线上问题时，可以快速定位问题症结所在，通过修改配置或者修改源代码来解决；或者当业务需求没有合适的开源项目能满足时，可以改造现有的开源项目来满足业务。 作为要优秀开发，避免陷入“<strong>API操作工</strong>”的被动局面，学习开源项目的一个很重要目的就是知道其功能点是如何实现且优化的，学习其中的知识好比公式的推导过程，掌握基本API使用好比会数学公式可以应付考试，但是理解好的推导过程根据有助于记忆和理解，<strong>知其然也要知其所以然</strong>，当遇那些没法套公式的情况下，我们也知道如何解决。</p>
</li>
<li><p>思维的提升</p>
<p>通过学习成熟的开源项目的优秀架构，可以总结和理解一些软件设计常用的架构思路，例如实现高可用，主要是通过集群的数据冗余，例如Kafka集群，HDSF集群；实现可扩展可以考虑把变化层和不变层隔离，把业务实现抽象化，例如Spring的预留的一些可扩展接口。</p>
</li>
</ul>
<h3 id="常见错误观点"><a href="#常见错误观点" class="headerlink" title="常见错误观点"></a>常见错误观点</h3><p>学习开源项目有一些常见的错误观点，导致新手容易望而生畏而轻易放弃，或者浪费大量时间而收获不大：</p>
<ol>
<li><p><strong>学习开源项目是架构师，技术大牛的事，我作为新手根本难以学会，就算学了也用不到。</strong></p>
<p>学习是一个过程，不是一朝一夕就可以成为大牛的，但是只要踏出第一步，总会有可能实现的大牛梦想的；另一方面，通过不断复盘不断总结，加以合适的方法论指导，相信是可以有所收获的，能力得到提升的。 学习之后对于逻辑思维，知识体系的构建有相信会有很大提升，即使项目没用到具体的开源项目，以后遇到相关问题可以触类旁通，举一反三，也是一种进步。</p>
</li>
<li><p><strong>数据结构和算法很重要，我只要学习这项目中的2方面就可以了</strong></p>
<p>不要只盯着数据结构和算法，这两点在开源项目中并没有那么重要，例如Netty中的超时队列是基于红黑树来实现的，我们其实只需要知道这一点就够了，除非需要改造这方面的功能。更重要的是理解系统的设计，功能的实现方案。</p>
</li>
<li><p><strong>一头扎进源码进行学习</strong></p>
<p>很多新手笃信社区论坛流行的一句话“Talk is cheap, show me the code”，一头扎进源码阅读，却最后陷入源码的泥潭中，在层层代码函数跳转中迷失了方向。</p>
<p>其实学习开源项目应该是<strong>自顶而下</strong>的，最底层的源码应该是最后才开始学习，在此之前，需要学习项目相关架构设计方面的知识，有了这些知识，就仿佛数据库有了索引，按照知识索引来进行源码针对性突破，如巡航导弹精准爆破，自然比地毯式轰炸更起到事半功倍的作用。</p>
</li>
</ol>
<h3 id="学习的4个层次"><a href="#学习的4个层次" class="headerlink" title="学习的4个层次"></a>学习的4个层次</h3><p>根据学习理解的深入程度不同，可以把学习分为4个层次</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211160458562.png" style="zoom:80%;" />

<ul>
<li>基础学习：对项目有一个<strong>大概性、基础性</strong>的了解，比如<strong>项目是什么，有什么作用，大概怎么用，解决了什么问题</strong>。在面试中，不少初入职场的人的简历写到用到众多的技术框架，实际上往往仅仅只到了这个层次，再深入往下问，便支支吾吾答不上来了。</li>
<li>检视学习：对项目有一个<strong>系统性</strong>的了解，<strong>系统的各方面功能</strong>，<strong>基本原理</strong>，<strong>优缺点</strong>，<strong>使用场景</strong>，<strong>各配置项</strong>、<strong>API使用</strong>。在实际工作中，如果作为一个团队的普通成员，达到这个级别已经可以满足基本业务开发需求，但是如果想有更高的技术追求，仅仅到此是不够的。</li>
<li>分析学习：在检视学习的基础上，对开源项目的<strong>各项性能参数</strong>，<strong>各自场景性能调优</strong>有比较全面的了解和实践经验。到达这个层次，在项目生产中，已经有独当一面的能力，有一定能力承担核心主力开发的角色。</li>
<li>主题学习：在分析学习的基础上，对开源项目的<strong>关键功能模块的源码</strong>有所了解，能够<strong>根据实际需要封装、修改源码</strong>，或者<strong>借鉴项目造出新的轮子</strong>。 到达这个层次，往往有一定能力承担技术负责人、技术带头人的角色。</li>
</ul>
<h3 id="学习的4个步骤"><a href="#学习的4个步骤" class="headerlink" title="学习的4个步骤"></a>学习的4个步骤</h3><p>针对上面提到的学习的层次，下面介绍如何“<strong>自顶而下</strong>”学习，来达到这4个层次。</p>
<h4 id="基础性了解学习"><a href="#基础性了解学习" class="headerlink" title="基础性了解学习"></a>基础性了解学习</h4><p>目标是达到基础学习的层次，对项目有<strong>大概性</strong>的了解，包括项目背景，解决的问题场景，项目功能，使用场景，基本的API使用。通过查找官方文档、相关博客、视频资料学习即可。</p>
<p>通过对系统有大概性了解之后，会自然而然有一些疑问，例如实现的原理，优缺点等，后续学习带着这些疑问进行学习会更高效。</p>
<h4 id="系统性学习与实践"><a href="#系统性学习与实践" class="headerlink" title="系统性学习与实践"></a>系统性学习与实践</h4><p>目标是达到检视学习的层次，对项目有<strong>系统性、全面性</strong>的了解，包括项目的功能、组成模块、基本原理、使用场景、配置项、API使用、与其他类似项目的优缺点比较等。</p>
<p>方法步骤如下：</p>
<ol>
<li><strong>安装运行</strong> 按照相关文档，安装运行项目。在这个过程中，需要关注：<ul>
<li><strong>系统的依赖组件</strong>：因为依赖组件是系统设计和实现的基础，可以了解系统一下关键信息，例如 Memcached最重要的依赖是高性能的网络库 <code>libevent</code>，我们就能大概推测 Memcached 的网络实现应该是 <code>Reactor</code> 模型的。</li>
<li><strong>安装目录</strong>：常见的安装目录是 <code>conf </code>存放配置文件，<code>logs</code> 存放日志文件，<code>bin</code> 存放日志文件，而不同项目有些特殊目录，比如Nginx有 <code>html</code>目录，这种目录能促使我们带着相关疑问继续去研究学习，带着问题去学习效率是最高的。</li>
<li><strong>系统提供的工具</strong>：需要特别<strong>关注命令行和配置文件</strong>，它们提供两个非常重要的关键信息，系统具备哪些能力和系统将会如何运行。这些信息是我们学习系统内部机制和原理的一个观察窗口。 通常情况下，如果对每个命令行参数和配置项的作用和原理基本掌握了解的话，基本上对系统已经很熟悉了。实践中，可以不断尝试去修改配置项，然后观察系统有什么变化。</li>
</ul>
</li>
<li><strong>系统性研究原理与特性</strong> 这点相当重要，因为只有清楚掌握技术的原理特性，才能算真正掌握这门技术，才能做架构设计的时候做出合理的选择，在这个过程中，需要重点关注：<ul>
<li><strong>关键特性的基本实现原理</strong>：关键特性是该开源项目流行的重要卖点，常见的有高性能、高可用、可扩展等特性，项目是如何做到的，这是我们需要重点关注的地方。</li>
<li><strong>优缺点比对分析</strong>：优缺点主要通过对比来分析，即：我们将两个类似的系统进行对比，看看它们的实现差异，以及不同的实现优缺点都是什么。典型的对比有 Memcached 和 Redis、Kafka和ActiveMQ、RocketMQ的比较。</li>
<li><strong>使用场景</strong>：项目在哪些场景适用，哪些场景不适用，业界适用常见案例等。</li>
</ul>
</li>
</ol>
<p>在此阶段可以通过学习官方技术设计文档，架构图，原理图，或者相关技术博客，通常比较热门的开源项目都有很多分析文档，我们可以站在前人的基础上避免重复投入。但需要注意的是，<strong>由于经验、水平、关注点、使用的版本不同等差异，不同的人分析的结论可能有差异，甚至有的是错误的</strong>，因此不能完全参照。一个比较好的方式就是多方对照，也就是说看很多篇分析文档，比较它们的内容共同点和差异点。</p>
<p>同时，如果有些技术点难以查到资料，自己又不确定，可以通过写Example进行验证，通过日志打印、调试、监测工具观察理解具体的细节。例如可以写一个简单程序使用Netty，通过抓包工具观察网络包来理解其中的实现。</p>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><p>如果是只是自己学习和研究，可以参考网上测试和分析的文档，但是<strong>如果要在生产环境投入使用必须进行测试</strong>。因为网上搜的测试结果，不一定与自己的业务场景很契合，如果简单参考别人的测试结果，很可能会得出错误的结论，或者使用的版本不同，测试结果差异也比较大。</p>
<p>要特别注意的是，测试必须建立在对这个开源项目有<strong>系统性</strong>了解的基础上，不能安装完就立马测试，否则可能会因为配置项不对，使用方法不当，导致没有根据业务的特点搭建正确的环境、没有设计合理的测试用例，从而使得最终的测试结果得出了错误结论，误导了设计决策。</p>
<p>下面提供测试常见的思路参考，需要根据具体项目具体业务进行测试用例的设计。</p>
<ul>
<li>核对每个配置项的作用和影响，识别出关键配置项</li>
<li>进行多种场景的性能测试</li>
<li>进行压力测试：连续跑几天，观察 CPU、内存、磁盘 IO等指标波动</li>
<li>进行故障测试：kill，断电、拔网线、重启 100 次以上、倒换等</li>
</ul>
<h4 id="关键源码学习"><a href="#关键源码学习" class="headerlink" title="关键源码学习"></a>关键源码学习</h4><p>钻研、领悟该项目的各种<strong>设计思想</strong>与<strong>代码实现细节</strong>，基本定位是“精通”，精益求精，学无止境。这是大神们追求的境界。如果希望成为团队技术担当、项目社区的重要贡献者，则应当以这个层次作为努力的目标。</p>
<p><strong>代码不仅是读，还要理和试，有的人连API都没有调用过，上来就看代码，以为省了时间，实际是迈向自我摧残。</strong></p>
<p>对源码进行理和试的关键如下：</p>
<ul>
<li>在IDE拿到调用栈在IDE里读。IDE里可以方便跳转，查看定义，比起网页上看效率高得多。 通过IDE工具，运行example程序进行跟踪调试，通过打断点可以得到程序运行的调用栈。<strong>尽可能编译调试。能调试的代码，几乎没有看不懂的。</strong></li>
<li>把调用栈画下来 把代码的调用逻辑梳理出来之后，再通过画图工具，把代码的图画出来，可以画：流程图、类图、调用图、时序图，更具实际情况选择最有表现力的图。</li>
</ul>
<p>此外，平时多了解一些设计模式。这样看到名字里有<code>proxy</code>, <code>builder</code>, <code>factory</code>之类的，就心领神会了。横向分层，纵向分块。代码都是分模块的，有的是<strong>core</strong>，有的是<strong>util</strong>，<strong>parser</strong>之类的，要知道看的是哪一层，那一块。</p>
<p>有的小项目分层不明显，也不必强求。要看的不只是语法上的技巧，更重要的是设计上的思路和原理。<strong>读没读懂，最简单的标准是，假如给充足的时间，有没有信心写出一个差不多的东西来</strong>。</p>
<h4 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h4><p>实际实践操作中，完整执行上面4个步骤花费时间就长，通常情况下，前面2个步骤，在研究开源项目的时候都必不可少，第3个步骤可以在工作中打算采用开源项目才实施，第4个步骤在有一定的时间和精力下灵活安排时间做。</p>
<p><strong>与其每个项目走马观花去简单了解，不如集中火力把一个项目研究吃透，即使半年才吃透一个，积累几年之后数量还是很可观的。而且很多项目的思想是共同的，例如高可用方案、分布式协议等，研究透一个，再研究类似项目，会发现学习速度非常快，因为已经把共性的部分掌握了，只需要再研究新项目差异的部分。</strong></p>
<p>同时，在学习的过程中，需要不断总结，复盘，输出学习笔记，一方面锻炼逻辑思维能力，一方面有利于建立知识索引，过一段时间回顾的时候通过索引可以快速重新掌握知识，不容易遗忘。</p>
<h2 id="读源码的7大心得总结"><a href="#读源码的7大心得总结" class="headerlink" title="读源码的7大心得总结"></a>读源码的7大心得总结</h2><p>用了这么久的 Redis，也翻了很多次源码，经常有人问我到底怎么读 Redis 源码。</p>
<p>一提到读源码，很多人都会比较畏惧，认为读源码是高手才会做的事情。他们可能遇到问题时，会更倾向于去找别人分享的答案。但往往很多时候，自己查到的资料并不能解决所有问题，尤其是比较细节的问题。</p>
<p>从我的实战经验来看，遇到这种情况，通常就需要去源码中寻找答案了，因为在源码面前，这些细节会变得「一览无余」。</p>
<p>而且我认为，掌握读源码的能力，是从<strong>只懂得如何使用 Redis，到精通 Redis 实现原理</strong>的成长之路上，必须跨越的门槛。</p>
<p>可是，面对庞大复杂的项目，我们怎样读源码才能更高效呢？</p>
<p>这篇文章我就来和你聊一聊，我读 Redis 源码的经验，以及读源码的「通用思路」，希望这些心得可以帮助到你。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165157407.png"></p>
<h3 id="找到地图"><a href="#找到地图" class="headerlink" title="找到地图"></a>找到地图</h3><p>很多开源项目的源码，代码量一般都比较庞大，如果在读代码之前，我们没有制定合理的方法，就一头扎进去读代码，势必会把自己搞晕。</p>
<p>所以，我在拿到一个项目的代码之后，并不会马上着手去读，而是会先对整个项目结构进行梳理，划分出项目具体包含的模块。这样，我就对整个项目有了一个「宏观」的了解。</p>
<p>读代码就好比去一个陌生城市旅行，这个旅途过程充满着未知。如果在出发之前，我们手里能有一张地图，那我们对自己的行程就可以有一个非常清晰的规划。</p>
<p>我们就知道，如果想要到达目的地，需要从哪里出发、经过哪些地方、通过什么方式才能到达，<strong>有了地图就有了行进方向</strong>，否则很容易迷失。</p>
<p>因此，提前花一些时间梳理整个项目的「结构和目录」，对于后面更好地阅读代码是非常有必要的。</p>
<p>就拿 Redis 来举例，在读 Redis 源码之前，我们可以先梳理出整个项目的功能模块，以及每个模块对应的代码文件（src 下的代码结构）：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165332262.png" style="zoom:80%;" />

<p>有了这张地图之后，再去看代码的时候，就可以有重点地阅读了。</p>
<h3 id="前置知识准备"><a href="#前置知识准备" class="headerlink" title="前置知识准备"></a>前置知识准备</h3><p>在梳理完整个项目结构之后，我们就可以正式进入阅读环节当中了。不过，在阅读代码之前，我们其实还需要预先掌握一些「前置知识」。</p>
<p>因为一个完整的项目，必然综合了各个领域的技术知识点，比如<strong>数据结构、操作系统、网络协议、编程语言</strong>等，如果我们提前做好一些功课，在读源码的过程中就会轻松很多。</p>
<p>以下是根据我在阅读 Redis 书籍和实战过程中，提取的读源码必备前置知识点，你可以参考下：</p>
<ul>
<li><strong>常用数据结构</strong>：数组、链表、哈希表、跳表</li>
<li><strong>网络协议</strong>：TCP 协议</li>
<li><strong>网络 IO 模型</strong>：IO 多路复用、非阻塞 IO、Reactor 网络模型</li>
<li><strong>操作系统</strong>：写时复制（Copy On Write）、常见系统调用、磁盘 IO 机制</li>
<li><strong>C 语言基础</strong>：循环、分支、结构体、指针</li>
</ul>
<p>当然，在阅读源码的过程中，我们也可以根据实际问题再去查阅相关资料，但不管怎样，提前熟悉这些方面的知识，在真正读代码时就会省下不少时间。</p>
<h3 id="从基础模块开始读"><a href="#从基础模块开始读" class="headerlink" title="从基础模块开始读"></a>从基础模块开始读</h3><p>有了地图并掌握了前置知识之后，接下来我们就要进入主题了：<strong>读代码</strong>。</p>
<p>但具体要从哪个地方开始读起呢？我认为要先从「<strong>最基础</strong>」的模块开始读起。</p>
<p>我在前面也分析了，一个完整的项目会划分很多的功能模块，但这些模块并不是孤立的，而很可能是有「依赖」关系的。</p>
<p>比如说，Redis 中的 networking.c 文件，表示处理网络 IO 的具体实现。而如果我们能在理解事件驱动模块 ae.c 的基础上，再去阅读网络 IO 模块，效率就会更高。</p>
<p>那在 Redis 源码中，哪些是最基础的模块呢？</p>
<p>想一下，我们在使用 Redis 时，接触最频繁的是哪些功能？</p>
<p>答案是<strong>各种数据类型</strong>。</p>
<p>一切操作的基础，其实都是基于这些最常用的数据类型来做的，比如 String、List、Hash、Set、Sorted Set等。所以，我们就可以从这些基础模块开始读起，也就是从 t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c 代码入手。</p>
<p>如果你对 Redis 的数据类型有所了解，就会看到这些数据类型在实现时，底层都对应了不同的数据结构。比如，String 的底层是 SDS，List 的底层是 ziplist + quicklist，Hash 底层可能是ziplist，也可能是哈希表，等等。</p>
<p><img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165549459.png"></p>
<p>由此一来，我们会发现，这些数据结构又是更为「底层」的模块，所以我们在阅读数据类型模块时，就需要重点聚焦在这些模块上，也就是 sds.c、ziplist.c、quicklist.c、dict.c、intset.c 文件，而且这些文件都是比较独立的，阅读起来就可以更加集中。</p>
<p>这样，当我们真正掌握了这些「底层数据结构」的实现后，就能更好地理解基于它们实现的各种「数据类型」了。</p>
<p><strong>这些基础模块就相当于一座大厦的地基，地基打好了，才能做到高楼耸立。</strong></p>
<h3 id="找到核心主线"><a href="#找到核心主线" class="headerlink" title="找到核心主线"></a>找到核心主线</h3><p>掌握了数据结构模块之后，这时我们的重点就需要放在「<strong>核心主线</strong>」上来了。</p>
<p>在这个阶段，我们需要找到一个明确的目标，以这个目标为主线去读代码。因为读源码一个很常见的需求，就是为了了解这个项目最「核心功能」的实现细节，我们只有以此为目标，找到这条主线去读代码，才能达到最终目的。</p>
<p>那么在读 Redis 源码时，什么才是它的核心主线呢？这里我分享一个非常好用的技巧，就是根据「<strong>Redis 究竟是怎么处理客户端发来的命令的？</strong>」 为主线来梳理。</p>
<p>举个例子，当我们在执行 <code>SET testkey testval EX 60</code> 这样一条命令时，就需要搞清楚 Redis 是怎么执行这条命令的。</p>
<p>也就是要明确，<strong>Redis 从收到客户端请求，到把数据存到 Redis 中、设置过期时间，最后把响应结果返回给客户端</strong>，整个过程的每一个环节，到底是如何处理的。</p>
<p>有了这条主线，我们就有了非常明确的目标，而且沿着这条主线去读代码，我们还可以很清晰地把多个模块「串联」起来。比如从前面的例子中，我们会看到一条命令的执行，主要包含了这样几个阶段。</p>
<ul>
<li><strong>Redis Server 初始化</strong>：加载配置、监听端口、注册连接建立事件、启动事件循环（server.c、anet.c）。</li>
<li><strong>接收、解析客户端请求</strong>：初始化 client、注册读事件、读客户端 socket（networking.c）。</li>
<li><strong>处理具体的命令</strong>：找到对应的命令函数、执行命令（server.c、t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c）。</li>
<li><strong>返回响应给客户端</strong>：写客户端缓冲区、注册写事件、写客户端 socket（networking.c）。</li>
</ul>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211165810148.png" style="zoom:80%;" />

<p>沿着这条主线去读代码，我们就可以掌握一条命令的执行全过程。</p>
<p>而且，由于这条主线的代码逻辑，已经覆盖了「所有命令」的执行流程，我们下次再去读其它命令时，比如 SADD，就只需要关注「处理命令」部分的逻辑即可，其它逻辑有 80% 都是相同的。</p>
<h3 id="先整体后细节"><a href="#先整体后细节" class="headerlink" title="先整体后细节"></a>先整体后细节</h3><p>当然，在阅读主线代码的过程中，肯定也会遇到过于「<strong>复杂</strong>」的函数，第一次在读这种函数时，很容易就会「陷进去」，导致整个主线代码的阅读，无法继续推进下去。</p>
<p>遇到这种情况其实是很正常的，可这时我们应该怎么办呢？</p>
<p>这里我的做法是，前期读到这种逻辑时，不要马上陷入到细节中去，而是要先「抓整体」。</p>
<p>具体来说，对于复杂的函数逻辑，我们刚开始并不需要知道它的每一个细节是如何实现的，而是只需知道这个函数「大致」做了几件事情即可。</p>
<p>举个例子，在执行 HSET 命令时，有一段代码很复杂，其中包括了很多分支判断，一次很难读懂：</p>
<img src="E:\Typora\images\image-20220211165931298.png" style="zoom:80%;" />

<p>那么，我在读这段代码时，就可以先简化逻辑，把握整体思路：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211170007546.png" style="zoom:80%;" />

<p>之后，再了解每个分支大致做了哪些事情：</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211170050814.png" style="zoom:80%;" />

<p>这样做的好处，一是不会被复杂的细节逻辑搞晕，打击自己的自信心，二是可以有效避免阅读的连贯性被打断，从而能持续推进我们把整个主线逻辑读完。</p>
<p>所以，这里的重点就是：<strong>先把复杂代码的主逻辑搞清楚，知道涉及的每个方法完成了什么事，心里要先搭建一个简单的「框架」，等有了框架之后，我们再去给框架填充「细节」。</strong></p>
<p>这样通过「先整体后细节」的方式，我们就可以不再畏惧代码中的复杂逻辑。</p>
<h3 id="先主线后支线"><a href="#先主线后支线" class="headerlink" title="先主线后支线"></a>先主线后支线</h3><p>不过，在阅读主线代码的过程中，我们肯定还会遇到各种「支线」逻辑，比如<strong>数据过期、替换淘汰、持久化、主从复制</strong>等。</p>
<p>其实，在阅读主线逻辑的时候，我们并不需要去重点关注这些支线，而当整个主线逻辑「清晰」起来之后，我们再去读这些支线模块，就会容易很多了。</p>
<p>这时，我们就可以从这些支线中，选取下一个「目标」，带着这个目标去阅读，比如说：</p>
<ul>
<li>过期策略是怎么实现的？（expire.c、lazyfree.c）</li>
<li>淘汰策略是如何实现的？（evict.c）</li>
<li>持久化 RDB、AOF 是怎么做的？（rdb.c、aof.c）</li>
<li>主从复制是怎么做的？（replication.c）</li>
<li>哨兵如何完成故障自动切换？（sentinel.c）</li>
<li>分片逻辑如何实现？（cluster.c）</li>
<li>…</li>
</ul>
<p>有了新的支线目标后，我们依旧可以采用前面提到的「先整体后细节」的思路阅读相关模块，这样下来，整个项目的每个模块，就可以被「逐一击破」了。</p>
<h3 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="查漏补缺"></a>查漏补缺</h3><p>最后，我们还需要「查漏补缺」。</p>
<p>按照前面提到的方法，基本就可以把整个项目的主要模块读得七七八八了，这时我们基本已经对整个项目有了整体的「把控」。</p>
<p>不过，当我们在工作中遇到问题时，很有可能会发现，在当时读代码的过程中，有很多并不在意的「细节」被忽略了。</p>
<p>所以这时，我们就可以再带着「具体问题」出发，聚焦这个问题相关的模块，再一次去读源码。这样一来，我们就可以填补当时阅读源码的「空白区」。</p>
<p>举个例子，当我们在阅读 String 底层数据结构 SDS（简单动态字符串）的实现时，我们会看到当 SDS 需要追加新内容时会进行扩容，而我们之前阅读这块代码时，<strong>很有可能只是了解到有这样的逻辑存在，但并没有在意扩容的相关细节（一次扩容多大）。</strong></p>
<p>所以，当我们在工作中遇到这个细节问题后，就可以把目光聚焦在 SDS 的扩容逻辑上（sds.c 的sdsMakeRoomFor函数），而此时我们会发现，当需要申请的新内存小于 1MB 时，Redis 就会翻倍申请内存，否则按 1MB 申请新内存。</p>
<p>采用这个方法进行查漏补缺，我们就可以对整个项目了解得更深入、更全面，真正把项目「吃透」。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、<strong>找到地图</strong>：拿到项目代码后，提前梳理整个项目结构，知晓整个项目的模块划分，以及对应的代码文件。</p>
<p>2、<strong>前置知识准备</strong>：提前掌握项目中用到的前置知识，比如数据结构、操作系统原理、网络协议、网络 IO 模型、编程语言语法等等。</p>
<p>3、<strong>从基础模块开始读</strong>：从最底层的基础模块开始入手，先掌握了这些模块，之后基于它们构建的模块读起来会更加高效。</p>
<p>4、<strong>找到核心主线</strong>：找到整个项目中最核心的主线逻辑，以此为目标，了解各模块为了完成这个功能，是如何协作和组织的。</p>
<p>5、<strong>先整体后细节</strong>：对于复杂函数，不要上来就陷入细节，前期阅读只需了解这个函数大致做了什么事情，建立框架，等搭建起框架之后，再去填充细节。</p>
<p>6、<strong>先主线后支线</strong>：整个主线逻辑清晰之后，再去延伸阅读支线逻辑，因为支线逻辑肯定是服务主线逻辑的，读完主线后再去读这些支线，也会变得更简单。</p>
<p>7、<strong>查漏补缺</strong>：在工作中遇到具体问题，带着这些实际的问题出发再次去读源码，进行查漏补缺，填补之前读源码时没有注意到的地方。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>你可以看到，上面介绍的阅读源码的方法，其实并不局限于读 Redis 代码。</p>
<p>这 7 个步骤，可以算是一个的「通用思路」，我也经常用这个思路来读其它项目的源码，非常有用，你也可以试试。</p>
<p>另外，我认为很多人读源码觉得难，<strong>一是因为心理上自认为自己读不懂，不敢迈步这一步，二是因为找不到合理的方法，在读源码时屡次受挫，最终知难而退。</strong></p>
<p>我在读源码时也经历过这些，这里再分享一下我的经验。</p>
<p>1、<strong>永远不要给自己设限</strong>：想想看，曾经以为很多自己做不到的事，在有压力的情况下，是不是慢慢都做到了，而且发现做得还挺好？学习技术也是一样，技术是死的，东西就那么多，一遍不行来两遍，总有一次能搞懂，所以心态上一定不要先「否定」自己，凡事先迈一小步进去试试看，好的开始就是成功的一半。</p>
<p>2、<strong>找到对的学习方法</strong>：正所谓「学会学习，再学习」，科学高效的方法，能帮你事半功倍，这篇文章分享的方法论，就是属于学习方法的范畴，你可以结合自己的实际情况试试看。</p>
<h2 id="开源软件的许可协议"><a href="#开源软件的许可协议" class="headerlink" title="开源软件的许可协议"></a>开源软件的许可协议</h2><p>世界上现在有 60 多种被开源促进组织（<strong>Open Source Initiative</strong>）认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。<br>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。<br>对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。</p>
<h3 id="常见开源协议"><a href="#常见开源协议" class="headerlink" title="常见开源协议"></a>常见开源协议</h3><p><strong>GNU GPL（GNU General Public License，GNU通用公共许可证）</strong></p>
<p>只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是<strong>必须开源免费，不能闭源收费</strong>，因此这个协议并不适合商用软件。</p>
<p>遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。</p>
<p><strong>GPL 开源协议的主要特点：</strong></p>
<ul>
<li><strong>复制自由：</strong>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</li>
<li><strong>传播自由：</strong>允许软件以各种形式进行传播。</li>
<li><strong>收费传播：</strong>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</li>
<li><strong>修改自由：</strong>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。</li>
</ul>
<p><strong>BSD（Berkeley Software Distribution，伯克利软件发布版）协议</strong></p>
<p>BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：</p>
<p>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。<br>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。<br>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</p>
<p><strong>Apache 许可证版本（Apache License Version）协议</strong></p>
<p>Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为<strong>开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由</strong>。</p>
<p>现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件：</p>
<ul>
<li>该软件及其衍生品必须继续使用 Apache 许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li>
</ul>
<p><strong>MIT（Massachusetts Institute of Technology）协议</strong></p>
<p>目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p>
<p>使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p>
<p><strong>GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）</strong></p>
<p>LGPL 是 GPL 的一个衍生版本，也被称为 <strong>GPL V2</strong>，该协议<strong>主要是为类库设计的开源协议</strong>。</p>
<p>LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<h3 id="如何选择开源协议"><a href="#如何选择开源协议" class="headerlink" title="如何选择开源协议"></a>如何选择开源协议</h3><p>世界上的开源协议有上百种，很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。</p>
<p>乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220211094515896.png" style="zoom:80%;" />



<p><strong>开源等于免费吗？</strong></p>
<p>首先，开源软件和免费软件是两个概念：</p>
<ul>
<li><strong>开源软件是指公开源代码的软件。</strong>开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</li>
<li><strong>免费软件就是免费提供给用户使用的软件。</strong>但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</li>
</ul>
<p>免费软件的例子比比皆是，QQ、微信、迅雷、酷狗、360 等都是免费软件，你可以随意使用，尽情蹂躏；但是，如果你嫌弃它们复杂，自己删除了一些无用的功能，然后在网上发布了一个精简版本供大家下载，那么你就离法院的传票不远了。</p>
<p>开源软件是不抵触商业的，开源的目的也不是做慈善事业，而是通过更多人的参与，减少软件的缺陷，丰富软件的功能，同时也避免了少数人在软件里留一些不正当的后门。开源软件最终还会反哺商业，让商业公司为用户提供更好的产品。</p>
<p>Android 就是大众最熟知的一款开源操作系统，它除了用在手机上，还用在汽车、平板电脑、电视、智能手表等其它硬件平台，小米、华为、OPPO、三星等都是 Android 的受益者，他们都赚得盆满钵满。</p>
<p>很多著名的开源项目背后都有商业公司支撑，它们的开发者也都有正式的工作，享受和我们一样的社会福利；如果一个成功的开源项目背后没有商业公司，这反而是不健康的，社会需要开源和商业之间的互补来促进技术的革新。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://gitee.com/opensource-guide/">开源指北</a></li>
</ul>
<p>文章总结来源：</p>
<p><a href="https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg">看完这篇，别人的开源项目结构应该能看懂了</a></p>
<p>阿里巴巴 Java开发手册（嵩山版）</p>
<p><a href="https://juejin.cn/post/6844903657348022280">谈谈如何高效学习开源项目</a></p>
<p><a href="https://mp.weixin.qq.com/s/eWN7I8eHGE2exrdF3xziIA">读懂Redis源码，我总结了这7大心得</a></p>
<p><a href="https://mp.weixin.qq.com/s/ojGRSWSaJutAsBC0i5_6jA">开源软件的许可协议</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>开源项目</tag>
        <tag>学习经验</tag>
      </tags>
  </entry>
  <entry>
    <title>面试规则</title>
    <url>/post/d13fc60c/</url>
    <content><![CDATA[<p><strong>规则一：面试的本质是寻找同类（同道中人）</strong></p>
<ul>
<li>知识密集型岗位（需要共鸣）</li>
</ul>
<p><strong>规则二：问题之间是可以转化的</strong></p>
<blockquote>
<p>可以将面试官问的问题转化为对应的具体的知识点，例如：</p>
<p>有没有高并发经验？ -&gt; 分库分表、缓冲区的使用、高并发网络IO如何处理</p>
</blockquote>
<span id="more"></span>
<p><strong>规则三：问题是可以被拆解的</strong></p>
<blockquote>
<p>有没有做过大项目？</p>
<p>拆解：什么样的大项目？</p>
<p>项目大在哪里？</p>
<ul>
<li>需求特别多？排期特别长？</li>
<li>沟通复杂？团队多？</li>
<li>技术特别难？</li>
</ul>
</blockquote>
<blockquote>
<p>类似的问题：</p>
<ul>
<li>Java做过几年？</li>
<li>有没有大项目经验？</li>
<li>有没有高并发经验？</li>
<li>有没有XXX方向的经验？</li>
</ul>
<p>应对方法：学会拆解问题，避虛就实，用硬核知识突破面试</p>
</blockquote>
<p><strong>规则四：永远不要被面试官牵着鼻子走</strong></p>
<blockquote>
<p>应对方法：“引导”面试官提问自己熟悉的知识，从而展示自己学习能力和对知识的学习深度（是否透彻）。</p>
</blockquote>
<p><strong>规则五：给面试官有思想深度的回答</strong></p>
<blockquote>
<p>如何说？<br>正着说、反着说、折中说、避免「背诵」</p>
<p>例如：</p>
<p>面试官：给我解释下高并发?</p>
<ul>
<li>高并发的核心是开发成本和硬件成本之间找到一个折中可行的方案</li>
<li>简单点说解决高并发是在延迟和丢包率可控的情况下，追求吞吐量</li>
<li>解决高并发要关注线程和I/O模型、数据库选型、缓存优化、缓冲区设计、解耦和消息队列、分布式服务设计等等方面的设计</li>
</ul>
<p>应对方法：只有自己<strong>对知识理解透彻</strong>的情况下，才能用自己的语言正确的表述出来。</p>
</blockquote>
<blockquote>
<p><strong>非官方、简短而本质的回答</strong></p>
<ul>
<li>LinkedHashMap是一个元素间用链表相连的哈希表</li>
<li>HashMap就是哈希表实现的Map，TreeMap是用树实现的Map，Map是一种映射关系</li>
<li>AQS解决Java语言没有实现同步元语底层框架的问题</li>
<li>B+树是一棵支持区间查找的B树</li>
<li>DNS是一个经典的分布式设计、BigTable是另一个</li>
<li>元编程是程序改写程序</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试软技能</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/post/2e152a56/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">跳跃列表</a> 的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素，当工作中遇到某些场景时，需要想到可以使用跳表解决问题即可。毕竟平时的工作都是直接使用封装好的跳表，例如：java.util.concurrent 下的 ConcurrentSkipListMap()。</p>
<span id="more"></span>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="理解跳表，从单链表开始说起"><a href="#理解跳表，从单链表开始说起" class="headerlink" title="理解跳表，从单链表开始说起"></a>理解跳表，从单链表开始说起</h3><p>下图是一个简单的<strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115621197.png" style="zoom:67%;" />

<p>现在我们有个场景，想快速找到上图链表中的 10 这个元素，只能从头开始遍历链表，直到找到我们需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度很高O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115700024.png" style="zoom:67%;" />

<p>先在索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，于是不往后找了，而是通过 9 找到原始链表的 9，然后再往后遍历找到了我们要找的 10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p>
<p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115735116.png" style="zoom:67%;" />

<p>可能同学们会想，从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208115830967.png" style="zoom:67%;" />

<p>到这里大家应该已经明白了什么是跳表。跳表是<strong>可以实现二分查找的有序链表</strong>。</p>
<h2 id="操作-amp-时空复杂度分析"><a href="#操作-amp-时空复杂度分析" class="headerlink" title="操作 &amp; 时空复杂度分析"></a>操作 &amp; 时空复杂度分析</h2><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><p>既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。</p>
<p>先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2<sup>k</sup>个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2<sup>h</sup>，即 h = log2<sup>n</sup> - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2<sup>n</sup>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120216604.png" style="zoom:67%;" />

<p>我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？</p>
<p>图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p>
<p>跳表的索引高度 h = log2<sup>n</sup>，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 <code>O(3*logn)</code>，省略常数即：<code>O(logn)</code>。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“<strong>空间换时间</strong>”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？</p>
<p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，空间复杂度是 <code>O(n)</code>。</p>
<p>如下图所示：如果每三个结点抽一个结点做为索引，索引总和数就是 n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据我们的应用场景来控制这个阈值，看我们更注重时间还是空间。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120715377.png" style="zoom:67%;" />

<p>但是，索引结点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号（int 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据看起来也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。如下图所示，要插入数据6，整个过程类似于查找6，整个的查找路径为 1、1、1、4、4、5。查找到第底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。整个时间复杂度为查找元素的时间复杂度 <code>O(logn)</code>。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208120902084.png" style="zoom:67%;" />

<p>如下图所示，假如一直往原始列表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 O(logn) 退化为 O(n)。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208121034389.png" style="zoom:67%;" />

<p>比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删掉全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。</p>
<p>那有没有其他效率比较高的方式来维护索引呢？假如跳表每一层的晋升概率是 1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素做为一级索引。换种说法，<strong>我们在原始链表中随机的选 n/2 个元素做为一级索引是不是也能通过索引提高查找的效率呢？</strong> 当然可以了，因为一般随机选的元素相对来说都是比较均匀的。如下图所示，随机选择了n/2 个元素做为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素 16，仍然可以通过一级索引，使得遍历路径较少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素 1、3、4、5、7、8，那么查找效率确实没有提升，但是这样的概率太小了。我们可以认为：当原始链表中<strong>元素数量足够大</strong>，且<strong>抽取足够随机</strong>的话，我们得到的索引是均匀的。我们要清楚设计良好的数据结构都是为了应对大数据量的场景，如果原始链表只有 5 个元素，那么依次遍历 5 个元素也没有关系，因为数据量太少了。所以，我们可以维护一个这样的索引：<strong>随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208121650431.png" style="zoom:67%;" />

<p>那代码该如何实现，才能使跳表满足上述这个样子呢？可以在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮我们把控这个 1/2、1/4、1/8 … ，<strong>当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。下面开始讲解这个概率算法代码如何实现。</p>
<p>我们可以实现一个 <code>randomLevel()</code> 方法，该方法会随机生成 <code>1~MAX_LEVEL</code> 之间的数（<code>MAX_LEVEL</code>表示索引的最高层数），且该方法<strong>有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推</strong>。</p>
<ul>
<li><code>randomLevel()</code> 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）</li>
<li><code>randomLevel()</code> 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）</li>
<li><code>randomLevel()</code> 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）</li>
<li><code>randomLevel()</code> 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）</li>
<li>…（以此类推）</li>
</ul>
<p>所以，通过 <code>randomLevel()</code> 方法，我们可以控制整个跳表各级索引中元素的个数。<strong>重点来了</strong>：<code>randomLevel()</code> 方法返回 2 的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的 1/2，但是 <code>randomLevel()</code> 方法返回 2 的概率为 1/4，那是不是有矛盾呢？明明说好的 1/2，结果一级索引元素个数怎么变成了原始链表的 1/4？我们先看下图，应该就明白了。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208122204227.png" style="zoom:67%;" />

<p>假设我们在插入元素 6 的时候，<code>randomLevel()</code> 方法返回 1，则我们不会为 6 建立索引。插入 7 的时候，<code>randomLevel()</code> 方法返回3 ，所以我们需要为元素 7 建立二级索引。这里我们发现了一个特点：当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。所以，一级索引中元素的个数等于 [ 原始链表元素个数 ] * [ <code>randomLevel()</code> 方法返回值 &gt; 1 的概率 ]。因为 <code>randomLevel()</code> 方法返回值 &gt; 1就会建索引，凡是建索引，无论几级索引必然有一级索引，<strong>所以一级索引中元素个数占原始数据个数的比率为 randomLevel() 方法返回值 &gt; 1 的概率</strong>。那 <code>randomLevel()</code> 方法返回值 &gt; 1 的概率是多少呢？因为 <code>randomLevel()</code> 方法随机生成 <code>1~MAX_LEVEL</code> 的数字，且 <code>randomLevel()</code> 方法返回值 1 的概率为 1/2，则 <code>randomLevel()</code> 方法返回值 &gt; 1 的概率为 1 - 1/2 = 1/2。即<strong>通过上述流程实现了一级索引中元素个数占原始数据个数的 1/2</strong>。</p>
<p>同理，当 <code>randomLevel()</code> 方法返回值 &gt; 2 时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此<strong>二级索引中元素个数占原始数据的比率为 randomLevel() 方法返回值 &gt; 2 的概率</strong>。 <code>randomLevel()</code> 方法返回值 &gt; 2 的概率为 1 减去 <code>randomLevel()</code> = 1 或 =2 的概率，即 1 - 1/2 - 1/4 = 1/4。OK，达到了我们设计的目标：<strong>二级索引中元素个数占原始数据的 1/4</strong>。</p>
<p>以此类推，可以得出，遵守以下两个条件：</p>
<ul>
<li><code>randomLevel()</code> 方法，随机生成 <code>1~MAX_LEVEL</code> 之间的数（<code>MAX_LEVEL</code>表示索引的最高层数），且<strong>有 1/2的概率返回 1、1/4的概率返回 2、1/8的概率返回 3 …</strong></li>
<li><code>randomLevel()</code> 方法返回 1 不建索引、返回 2 建一级索引、返回 3 建二级索引、返回 4 建三级索引 …</li>
</ul>
<p>就可以满足我们想要的结果，即：一级索引中元素个数应该占原始数据的 1/2，二级索引中元素个数占原始数据的 1/4，三级索引中元素个数占原始数据的 1/8 ，依次类推，一直到最顶层索引。</p>
<p>但是问题又来了，怎么设计这么一个 <code>randomLevel()</code> 方法呢？直接撸代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span></span><br><span class="line"><span class="comment">//        1/2 的概率返回 1</span></span><br><span class="line"><span class="comment">//        1/4 的概率返回 2</span></span><br><span class="line"><span class="comment">//        1/8 的概率返回 3 以此类推</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1</span></span><br><span class="line">  <span class="keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)</span><br><span class="line">    level += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以实现我们的功能，而且，我们的案例中晋升概率 SKIPLIST_P 设置的 1/2，即：每两个结点抽出一个结点作为上一级索引的结点。如果我们想节省空间利用率，可以适当的降低代码中的 SKIPLIST_P，从而减少索引元素个数，Redis 的 zset 中 SKIPLIST_P 设定的 0.25。下图所示，是Redis <a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c">t_zset.c</a> 中 zslRandomLevel 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 源码中 <code>(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)</code>  在功能上等价于我代码中的 <code>Math.random() &lt; SKIPLIST_P</code> ，只不过 Redis 作者 <a href="https://github.com/antirez">antirez</a> 使用位运算来提高浮点数比较的效率。</p>
<p>整体思路大家应该明白了，那插入数据时维护索引的时间复杂度是多少呢？元素插入到单链表的时间复杂度为 <code>O(1)</code>，我们索引的高度最多为 <code>logn</code>，当插入一个元素 x 时，最坏的情况就是元素 x 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 <code>O(logn)</code>。</p>
<p>过程大概理解了，再通过一个例子描述一下跳表插入数据的全流程。现在我们要插入数据 6 到跳表中，首先 randomLevel() 返回 3，表示<strong>需要建二级索引</strong>，即：一级索引和二级索引需要增加元素 6。该跳表目前最高三级索引，首先找到三级索引的 1，发现 6 比 1大比 13小，所以，从 1 下沉到二级索引。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125241674.png" style="zoom:67%;" />

<p>下沉到二级索引后，发现 6 比 1 大比 7 小，此时需要在二级索引中 1 和 7 之间加一个元素6 ，并从元素 1 继续下沉到一级索引。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125308947.png" style="zoom:67%;" />

<p>下沉到一级索引后，发现 6 比 1 大比 4 大，所以往后查找，发现 6 比 4 大比 7 小，此时需要在一级索引中 4 和 7 之间加一个元素 6 ，并把二级索引的 6 指向 一级索引的 6，最后，从元素 4 继续下沉到原始链表。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125342542.png" style="zoom:67%;" />

<p>下沉到原始链表后，就比较简单了，发现 4、5 比 6小，7比6大，所以将6插入到 5 和 7 之间即可，整个插入过程结束。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125414593.png" style="zoom:67%;" />

<p>整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 <code>O(1)</code>，所以整个插入的时间复杂度是 <code>O(logn)</code>。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p>
<img src="https://gitee.com/Feyl/picgo/raw/master/img/image-20220208125528595.png" style="zoom:67%;" />

<p>跳表中，删除元素的时间复杂度是多少呢？</p>
<p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <code>O(1)</code>，索引层数为 <code>logn</code> 表示最多需要删除 <code>logn</code> 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> 加 <em>删除 logn个元素的时间</em> 为 <code>O(logn) + O(logn) = 2 O(logn)</code>，忽略常数部分，删除元素的时间复杂度为 <code>O(logn)</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>跳表是可以实现二分查找的有序链表；</li>
<li>每个元素插入时随机生成它的 level；</li>
<li>最底层包含所有的元素；</li>
<li>如果一个元素出现在 <code>level(x)</code>，那么它肯定出现在 x 以下的 level中；</li>
<li>每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</li>
</ol>
<h2 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h2><p>Redis 中的有序集合(<code>zset</code>) 支持的操作：</p>
<ol>
<li>插入一个元素</li>
<li>删除一个元素</li>
<li>查找一个元素</li>
<li>有序输出所有元素</li>
<li>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</li>
</ol>
<p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 <code>O(logn)</code> 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p>
<h2 id="工业上其他使用跳表的场景"><a href="#工业上其他使用跳表的场景" class="headerlink" title="工业上其他使用跳表的场景"></a>工业上其他使用跳表的场景</h2><p>在博客上从来没有见过有同学讲述 HBase MemStore 的数据结构，其实 HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的<strong>有序文件</strong>，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 <code>java.util.concurrent</code> 下的 <code>ConcurrentSkipListMap()</code>。</p>
<p>Google 开源的 <code>key/value</code> 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，他们内部的 MemTable 都是使用了跳表这种数据结构。</p>
<p>文章转载来源：<a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一）</a></p>
<p>推荐阅读：</p>
<p><a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c">Redis zset源码</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>跳表</tag>
        <tag>双向链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
